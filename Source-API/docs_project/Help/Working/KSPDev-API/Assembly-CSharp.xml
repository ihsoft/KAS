<?xml version="1.0"?>
<doc>
    <assembly>
        <name>XMLDocumentation</name>
    </assembly>
    <members>
        <member name="T:ApplicationLauncher">
            <summary>
            The application launcher is the set of buttons that appear in the upper right, including
            for example the resource tab. You can add your own buttons to this toolbar. 
            
            See http://forum.kerbalspaceprogram.com/threads/86682-Appilcation-Launcher-and-Mods?p=1303921#post1303921
            </summary>
        </member>
        <member name="F:ApplicationLauncher.Ready">
            <summary>
            Don't try to add buttons before ApplicationLauncher.Ready is true. If it's currently false, you
            can register for the GameEvents.onGUIApplicationLauncherReady event which will fire when the
            application launcher becomes ready to have buttons added to it.
            </summary>
        </member>
        <member name="M:ApplicationLauncher.AddModApplication(RUIToggleButton.OnTrue,RUIToggleButton.OnFalse,RUIToggleButton.OnHover,RUIToggleButton.OnHoverOut,RUIToggleButton.OnEnable,RUIToggleButton.OnDisable,ApplicationLauncher.AppScenes,PackedSprite)">
            <summary>
            Add a MOD(3rd party) application to the Application Launcher. Use ApplicationLauncherButton.VisibleInScenes to set where the button should be displayed.
            </summary>
            <remarks>
            Note that the application launcher is destroyed when the player exits to the main menu. If the player then 
            loads up a new save the application launcher will be recreated and you will have to re-add your button. 
            Register for GameEvents.onGUIApplicationLauncherDestroyed and GameEvents.onGUIApplicationLauncherReady
            to detect when the application launcher has been destroyed and when it has been re-created.
            </remarks>
            <param name="onTrue">Callback for when the button is toggeled on</param>
            <param name="onFalse">Callback for when the button is toggeled off</param>
            <param name="onHover">Callback for when the mouse is hovering over the button</param>
            <param name="onHoverOut">Callback for when the mouse hoveris off the button</param>
            <param name="onEnable">Callback for when the button is shown or enabled by the application launcher</param>
            <param name="onDisable">Callback for when the button is hidden or disabled by the application launcher</param>
            <param name="visibleInScenes">The "scenes" this button will be visible in. For example VisibleInScenes = ApplicationLauncher.AppScenes.FLIGHT | ApplicationLauncher.AppScenes.MAPVIEW;</param>
            <param name="sprite">The 38x38 PackedSprite animation to use for the button icon. Use ApplicationLauncherButton.PlayAnim() to play the animation.</param>
            <returns></returns>
        </member>
        <member name="M:ApplicationLauncher.AddModApplication(RUIToggleButton.OnTrue,RUIToggleButton.OnFalse,RUIToggleButton.OnHover,RUIToggleButton.OnHoverOut,RUIToggleButton.OnEnable,RUIToggleButton.OnDisable,ApplicationLauncher.AppScenes,UnityEngine.Texture)">
            <summary>
            Add a MOD(3rd party) application to the Application Launcher. Use ApplicationLauncherButton.VisibleInScenes to set where the button should be displayed.
            </summary>
            <remarks>
            Note that the application launcher is destroyed when the player exits to the main menu. If the player then 
            loads up a new save the application launcher will be recreated and you will have to re-add your button. 
            Register for GameEvents.onGUIApplicationLauncherDestroyed and GameEvents.onGUIApplicationLauncherReady
            to detect when the application launcher has been destroyed and when it has been re-created.
            </remarks>
            <param name="onTrue">Callback for when the button is toggeled on</param>
            <param name="onFalse">Callback for when the button is toggeled off</param>
            <param name="onHover">Callback for when the mouse is hovering over the button</param>
            <param name="onHoverOut">Callback for when the mouse hoveris off the button</param>
            <param name="onEnable">Callback for when the button is shown or enabled by the application launcher</param>
            <param name="onDisable">Callback for when the button is hidden or disabled by the application launcher</param>
            <param name="visibleInScenes">The "scenes" this button will be visible in. For example VisibleInScenes = ApplicationLauncher.AppScenes.FLIGHT | ApplicationLauncher.AppScenes.MAPVIEW;</param>
            <param name="texture">The 38x38 Texture to use for the button icon.</param>
            <returns></returns>
        </member>
        <member name="M:ApplicationLauncher.AddOnHideCallback(ApplicationLauncher.OnHide)">
            <summary>
            Register a method that will be called when the ApplicationLauncher GUI hides itself.
            </summary>
            <param name="del"></param>
        </member>
        <member name="M:ApplicationLauncher.AddOnRepositionCallback(ApplicationLauncher.OnReposition)">
            <summary>
            Register a method that will be called when the ApplicationLauncher moves from the top
            right to the bottom right, or vice versa.
            </summary>
            <param name="del"></param>
        </member>
        <member name="M:ApplicationLauncher.AddOnShowCallback(ApplicationLauncher.OnShow)">
            <summary>
            Register a method that will be called when the ApplicationLauncher GUI shows itself.
            </summary>
            <param name="del"></param>
        </member>
        <member name="M:ApplicationLauncher.DisableMutuallyExclusive(ApplicationLauncherButton)">
            <summary>
            Reverses the effect of EnableMutuallyExclusive()
            </summary>
            <param name="launcherButton"></param>
        </member>
        <member name="M:ApplicationLauncher.EnableMutuallyExclusive(ApplicationLauncherButton)">
            <summary>
            Makes your application hide the stock applications when opened, and  makes stock applications hide
            your appliction when opened.
            </summary>
            <param name="launcherButton"></param>
        </member>
        <member name="M:ApplicationLauncher.RemoveModApplication(ApplicationLauncherButton)">
            <summary>
            Removes your button from the application launcher toolbar.
            </summary>
            <param name="button"></param>
        </member>
        <member name="M:ApplicationLauncher.RemoveOnHideCallback(ApplicationLauncher.OnHide)">
            <summary>
            Un-register a method that will be called when the ApplicationLauncher GUI hides itself.
            </summary>
            <param name="del"></param>
        </member>
        <member name="M:ApplicationLauncher.RemoveOnRepositionCallback(ApplicationLauncher.OnReposition)">
            <summary>
            Un-register a method that will be called when the ApplicationLauncher moves from the top
            right to the bottom right, or vice versa.
            </summary>
            <param name="del"></param>
        </member>
        <member name="M:ApplicationLauncher.RemoveOnShowCallback(ApplicationLauncher.OnShow)">
            <summary>
            Un-register a method that will be called when the ApplicationLauncher GUI shows itself.
            </summary>
            <param name="del"></param>
        </member>
        <member name="P:ApplicationLauncher.Instance">
            <summary>
            The single instance of ApplicationLauncher; call all the methods of this class using this instance.
            </summary>
        </member>
        <member name="P:ApplicationLauncher.IsPositionedAtTop">
            <summary>
            Whether the application launcher toolbar is positioned in the top right or in the bottom right
            (it's in the bottom right in the editor).
            </summary>
        </member>
        <member name="T:ApplicationLauncher.AppScenes">
            <summary>
            Or together these flags and pass them to AddModApplication to specify when your button
            should appear on the application launcher toolbar.
            </summary>
        </member>
        <member name="T:AtmosphericEngine">
            <summary>
            The old, deprecated class that implemented jet engine parts before PartModules.
            Use an appropriately configured ModuleEngines instead of this class.
            </summary>
        </member>
        <member name="T:Part">
            <summary>
            Each part on a vessel is represented by a Part object. Plugins can add new functionality to parts by defining new
            PartModules, which can then be added to Parts. It is also possible to define new subclasses of Part, but this
            is deprecated in favor of PartModules.
            </summary>
        </member>
        <member name="F:Part.ActivatesEvenIfDisconnected">
            <summary>
            Whether this part will actually activate if it schedule to be activated in the same stage as it 
            is decoupled from the rocket. In particular, sepratrons must have ActivatesEvenIfDisconnected set
            to true if they are to function properly.
            </summary>
        </member>
        <member name="F:Part.attachMode">
            <summary>
            Whether this part is attached to its parent via a stack AttachNode or a surface AttachNode.
            </summary>
        </member>
        <member name="F:Part.attachNodes">
            <summary>
            An AttachNode represents the link between two attached parts. attachNodes is a list of possible nodes to
            which other parts can be attached to this part. You can find the parts that actually are attached using
            AttachNode.attachedPart. 
            </summary>
        </member>
        <member name="F:Part.children">
            <summary>
            The parts that are children of this part in the part tree (parts that were attached to this part in the editor
            after this part was already part of the vessel).
            </summary>
        </member>
        <member name="F:Part.CrewCapacity">
            <summary>
            How many crew members this part can fit.
            </summary>
        </member>
        <member name="F:Part.dragModel">
            <summary>
            Unused?
            </summary>
        </member>
        <member name="F:Part.dragModelType">
            <summary>
            Unused?
            </summary>
        </member>
        <member name="F:Part.flightID">
            <summary>
            A unique identifider for this part. Note that despite the name, each part on the same vessel will still have a different value in this field.
            This value is persistent and not affected by game load or docking/undocking or similar.
            This is the 'uid' value at the PART level of the persistent.sfs file.
            </summary>
        </member>
        <member name="F:Part.fuelCrossFeed">
            <summary>
            Whether this part allows fuel crossfeed.
            </summary>
        </member>
        <member name="F:Part.fuelLookupTargets">
            <summary>
            In the flight scene, fuelLookupTargets is the list of fuel lines through
            which this part can draw fuel. Also if this part is a docking node docked
            to a another docking node through which it can draw fuel, then the attached
            docking node will also be in fuelLookupTargets.
            </summary>
        </member>
        <member name="F:Part.inverseStage">
            <summary>
            The stage in which this part will activate, as shown in the staging display. (Possibly called inverseStage
            because the stages in KSP count down instead of up).
            </summary>
        </member>
        <member name="F:Part.mass">
            <summary>
            The DRY mass of this part, not including the mass of any resources it contains
            </summary>
        </member>
        <member name="F:Part.maximum_drag">
            <summary>
            The drag coefficient of this part is equal to (total mass) * (maximum_drag)
            </summary>
        </member>
        <member name="F:Part.maxTemp">
            <summary>
            The temperature at which this part will explode.
            </summary>
        </member>
        <member name="F:Part.minimum_drag">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="F:Part.missionID">
            <summary>
            A unique identifier assigned to the part when the vessel it is a part of is created.
            All parts on the vessel get the same missionID and it does not change.
            Splitting a vessel with a decoupler will result with two vessels whose parts have the same missionID.
            When two vessels spawned seperately dock, each part keeps its original missionID, undocking does not change this field either.
            </summary>
        </member>
        <member name="F:Part.NoCrossFeedNodeKey">
            <summary>
            Specifies the name of a node through which this part will NOT draw resources. See the part.cfg of the 
            stock tricoupler for an example of using this to prevent fuel from flowing backwards.
            </summary>
        </member>
        <member name="F:Part.OnEditorAttach">
            <summary>
            Add a function to this callback and it will be called when your part is attached to another part in the editor.
            </summary>
        </member>
        <member name="F:Part.OnEditorDestroy">
            <summary>
            Add a function to this callback and it will be called when your part is deleted in the editor.
            </summary>
        </member>
        <member name="F:Part.OnEditorDetach">
            <summary>
            Add a function to this callback and it will be called when your part is detached, or is part of a set of parts
            that are detached, in the editor.
            </summary>
        </member>
        <member name="F:Part.OnJustAboutToBeDestroyed">
            <summary>
            Add a function to this callback and it will be called when your part is about to be destroyed during flight.
            </summary>
        </member>
        <member name="F:Part.parent">
            <summary>
            The parent of this part in the part tree: the part to which this part was attached in the editor.
            </summary>
        </member>
        <member name="F:Part.partInfo">
            <summary>
            Some of the part info that is displayed about this part in the editor.
            </summary>
        </member>
        <member name="F:Part.physicalSignificance">
            <summary>
            If physicalSignificance == Part.PhysicalSignificance.NONE, then this part doesn't actually
            have any physics. In particular, it has no mass, regardless of what its "mass" field is set to, and no drag.
            </summary>
        </member>
        <member name="F:Part.PhysicsSignificance">
            <summary>
            Unused?
            </summary>
        </member>
        <member name="F:Part.srfAttachNode">
            <summary>
            IF this part is surface-attached to its parent, srfAttachNode is the attach node describing this connection.
            </summary>
        </member>
        <member name="F:Part.stackIcon">
            <summary>
            The sicon shown for this part in the staging display.
            </summary>
        </member>
        <member name="F:Part.temperature">
            <summary>
            The temperature of this part, in some arbitrary units.
            </summary>
        </member>
        <member name="F:Part.uid">
            <summary>
            The purpose of uid is unknown. It changes everytime a vessel is swithched to, even within the same flight scene. 
            Swith to a nearby vessel and back with [ and ] and the uid of the parts on a vessel will change.
            This value does not save to persistent.sfs, the uid value at the PART level is the part.flightID value instead.
            </summary>
        </member>
        <member name="F:Part.vessel">
            <summary>
            The vessel to which this part belongs. Beware that vessel == null in the editor.
            </summary>
        </member>
        <member name="M:Part.AddModule(System.String)">
            <summary>
            Add a PartModule to this part. PartModules that are dynamically added to parts and don't exist in the original
            part.cfg will not be properly restored from persistence.
            </summary>
            <param name="moduleName">The class name of the PartModule to add, as a string</param>
            <returns>The added PartModule</returns>
        </member>
        <member name="M:Part.DrainFuel(System.Single)">
            <summary>
            Deprecated.
            </summary>
            <param name="amount"></param>
            <returns></returns>
        </member>
        <member name="M:Part.explode">
            <summary>
            Calling this causes the part to explode. But you guessed that, didn't you?
            </summary>
        </member>
        <member name="M:Part.findAttachNode(System.String)">
            <summary>
            Find an AttachNode by its name, as a string.
            </summary>
            <param name="nodeId">The name of the node to search for. The names of nodes are found in the part.cfg. For instance,
            node_stack_top describes a node with name "stack_top."</param>
            <returns>The AttachNode of the given name.</returns>
        </member>
        <member name="M:Part.findAttachNodeByPart(Part)">
            <summary>
            Given a child part of this part, find the AttachNode representing the connection between this
            part and that child.
            </summary>
            <param name="connectedPart">A child part of this part.</param>
            <returns>The AttachNode connecting this part to the given child.</returns>
        </member>
        <member name="M:Part.force_activate">
            <summary>
            Activates the part now, regardless of when it was scheduled to be activated in the staging order.
            </summary>
        </member>
        <member name="M:Part.GetResourceMass">
            <summary>
            The total mass of the resources held by the part. The total mass of the part is <code>mass + GetResourceMass()</code>
            </summary>
            <returns>Total resource mass, in tonnes</returns>
        </member>
        <member name="M:Part.RequestFuel(Part,System.Single,System.UInt32)">
            <summary>
            Deprecated.
            </summary>
            <param name="source"></param>
            <param name="amount"></param>
            <param name="reqId"></param>
            <returns></returns>
        </member>
        <member name="M:Part.RequestRCS(System.Single,System.Int32)">
            <summary>
            Deprecated.
            </summary>
            <param name="amount"></param>
            <param name="earliestStage"></param>
            <returns></returns>
        </member>
        <member name="P:Part.orbit">
            <summary>
            Don't use this; use Vessel.orbit instead.
            </summary>
        </member>
        <member name="P:Part.Resources">
            <summary>
            A list of the resources contained by this part. You can loop over them with
            <code>foreach(PartResource resource in part.Resources) { ... }</code>
            </summary>
        </member>
        <member name="P:Part.Rigidbody">
            <summary>
            The rigidbody of this part. See the Unity documentation on rigidbodies for more information.
            </summary>
        </member>
        <member name="T:Part.PhysicalSignificance">
            <summary>
            Represents whether a part has physics.
            </summary>
        </member>
        <member name="F:Part.PhysicalSignificance.FULL">
            <summary>
            Part is a normal, physics-enabled part.
            </summary>
        </member>
        <member name="F:Part.PhysicalSignificance.NONE">
            <summary>
            Part has no physics, and in particular no mass or drag.
            </summary>
        </member>
        <member name="T:AttachNode">
            <summary>
            An AttachNode represents the physical connection between a Part and its parent Part.
            </summary>
        </member>
        <member name="F:AttachNode.attachedPart">
            <summary>
            The part attached to this node. Null if no part is attached.
            </summary>
        </member>
        <member name="F:AttachNode.nodeType">
            <summary>
            Whether this node is a surface-attach node, a stack node, or a docking node.
            </summary>
        </member>
        <member name="F:AttachNode.ResourceXFeed">
            <summary>
            Wether or not resource cross feed can pass through this node.
            </summary>	
        </member>
        <member name="F:AttachNode.NodeType.Stack">
            <summary>
            A stack node, like the connections between stacked fuel tanks
            </summary>
        </member>
        <member name="F:AttachNode.NodeType.Surface">
            <summary>
            A surface node, like the connection between a radial decoupler and its parent.
            </summary>
        </member>
        <member name="F:AttachNode.NodeType.Dock">
            <summary>
            The type of node that connects two docking ports?
            </summary>
        </member>
        <member name="T:AvailablePart">
            <summary>
            An AvailablePart object contains the summary information about a single type of part
            which is shown in the editor.
            </summary>
        </member>
        <member name="F:AvailablePart.category">
            <summary>
            Which tab this part shows up in in the editor.
            </summary>
        </member>
        <member name="F:AvailablePart.cost">
            <summary>
            The cost of this part, as displayed in the editor.
            </summary>
        </member>
        <member name="F:AvailablePart.description">
            <summary>
            The description of this part, as displayed in the editor? 
            Does this include the GetInfo() of the part's PartModules?
            </summary>
        </member>
        <member name="F:AvailablePart.name">
            <summary>
            The name of this kind of part, as specified in the "name =" line of its part.cfg.
            </summary>
        </member>
        <member name="F:AvailablePart.partPrefab">
            <summary>
            The object that gets cloned when you create a new instance of this part in the editor?
            </summary>
        </member>
        <member name="T:BaseAction">
            <summary>
            A BaseAction object is the basic action object.
            There is one of these automatically created for each 'KSPAction' field in a partModule
            </summary>
        </member>
        <member name="F:BaseAction.actionGroup">
            <summary>
            Unconfirmed: The action groups this action is currently assigned to.
            </summary>
        </member>
        <member name="F:BaseAction.active">
            <summary>
            Is this action available? Setting this false disables the action so it will not show in the available actions list.
            </summary>
        </member>
        <member name="F:BaseAction.defaultActionGroup">
             <summary>
            Unconfirmed: Assign this action to action groups upon creation ('Gear' group for landing legs)
             </summary>
        </member>
        <member name="F:BaseAction.guiName">
            <summary>
            Name shown in editor action groups panel
            </summary>
        </member>
        <member name="F:BaseAction.listParent">
            <summary>
            Information about what the action is attached to.
            listParent.module = partModule this action is a memeber of
            listParent.part = part this action is a member of
            </summary>
        </member>
        <member name="F:BaseAction.name">
            <summary>
            Name of the action group as seen in code where the KSPAction field exists
            </summary>
        </member>
        <member name="M:BaseAction.Invoke(KSPActionParam)">
            <summary>
            Activate this action. Note that there is no toggle activation, you must check state yourself in code
            and activate or deactivate as appropriate
            
            **Example code start to activate an action: KSP version 0.24.2**
            
            <code>
            KSPActionParam actParam = new KSPActionParam(KSPActionGroup.None, KSPActionType.Activate); //okay to create this new just before invoking
            exampleAction.Invoke(actParam); //action defined as a KSPAction in a partModule
            </code>
            
            **Example code start to deactivate an action: KSP version 0.24.2**
            
            <code>
            KSPActionParam actParam = new KSPActionParam(KSPActionGroup.None, KSPActionType.Deactivate); //okay to create this new just before invoking
            exampleAction.Invoke(actParam); //action defined as a KSPAction in a partModule
            </code>
            </summary>
        </member>
        <member name="T:BaseActionList">
            <summary>
            A BaseActionList is an object to manipulate actions.
            </summary>
        </member>
        <member name="F:BaseActionList.module">
            <summary>
            The partModule this list of actions belongs to
            </summary>
        </member>
        <member name="F:BaseActionList.part">
            <summary>
            The Part this list of actions belongs to
            </summary>
        </member>
        <member name="T:KSP.IO.BinaryReader">
            <summary>
            Identical to System.IO.BinaryReader, but with added IDisposable methods (for use in using structures), and a factory method instead of constructors.
            </summary>
        </member>
        <member name="M:KSP.IO.BinaryReader.CreateForType``1(System.String,Vessel)">
            <summary>
            Create a binary reader with the desired filename.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.BinaryReader.Dispose">
            <summary>
            Close the stream and any resources (e.g. files) it has open.
            </summary>
        </member>
        <member name="M:KSP.IO.BinaryReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from the stream.
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.BinaryReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Read a block of chars from the stream.
            </summary>
            <param name="buffer"></param>
            <param name="index"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:KSP.IO.BinaryWriter">
            <summary>
            Identical to System.IO.BinaryWriter, but with added IDisposable methods (for use in using structures), and a factory method instead of constructors.
            </summary>
        </member>
        <member name="M:KSP.IO.BinaryWriter.CreateForType``1(System.String,Vessel)">
            <summary>
            Create a binary file writer.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="T:CelestialBody">
            <summary>
            The Sun, the planets, and the moons are all CelestialBodies.
            </summary>
        </member>
        <member name="F:CelestialBody.angularV">
            <summary>
            The magnitude of the angular velocity of the body's rotation, in radians per second.
            </summary>
        </member>
        <member name="F:CelestialBody.angularVelocity">
            <summary>
            The body's angular velocity vector, in rotations per second. This points along the axis of
            rotation and its magnitude is the rotation rate in radians per second.
            </summary>
        </member>
        <member name="F:CelestialBody.atmosphere">
            <summary>
            Whether this body has an atmosphere
            </summary>
        </member>
        <member name="F:CelestialBody.atmosphereContainsOxygen">
            <summary>
            Presumably, whether jet engines will work in this body's atmosphere
            </summary>
        </member>
        <member name="F:CelestialBody.atmosphereMultiplier">
            <summary>
            Seems to be the pressure of the body's atmosphere at sea level, in units of Kerbin atmospheres at sea level.
            Appears to only have an effect when useLegacyAtmosphere is toggled on
            </summary>
        </member>
        <member name="F:CelestialBody.atmosphereScaleHeight">
            <summary>
            The atmosphere's scale height, in KILOMETERS (not meters). The atmospheric pressure at a given altitude
            above sea level is proportional to Math.Exp(-altitude / atmosphereScaleHeight).
            </summary>
        </member>
        <member name="F:CelestialBody.bodyName">
            <summary>
            The name of the body, as a string.
            </summary>
        </member>
        <member name="F:CelestialBody.GeeASL">
            <summary>
            The gravitational acceleration of the body at sea level, in units of gees (1 gee = 9.81 m/s^2)
            </summary>
        </member>
        <member name="F:CelestialBody.gMagnitudeAtCenter">
            <summary>
            The gravitational acceleration (in m/s^2) at a radius r (in m) from the body's center is gMagnitudeAtCenter / r^2
            </summary>
        </member>
        <member name="F:CelestialBody.gravParameter">
            <summary>
            The gravitational parameter GM is the universal gravitational constant G times the mass M of the body. 
            In KSP the gravitational constant G is exactly 6.673 m^3 / (kg s^2), and the body mass is measured in
            kilograms.
            </summary>
        </member>
        <member name="F:CelestialBody.hillSphere">
            <summary>
            Unused?
            </summary>
        </member>
        <member name="F:CelestialBody.Mass">
            <summary>
            The mass of the body in kilograms. Computed 
            </summary>
        </member>
        <member name="F:CelestialBody.maxAtmosphereAltitude">
            <summary>
            The height of the upper edge of the body's atmosphere, in meters above sea level. Except,
            not really. The atmosphere really cuts off at an altitude (in meters) of 
            <code>body.atmosphereScaleHeight * 1000 * Math.Log(1e6)</code>
            </summary>
        </member>
        <member name="F:CelestialBody.ocean">
            <summary>
            Whether this planet has an ocean at "sea level"
            </summary>
        </member>
        <member name="F:CelestialBody.orbitDriver">
            <summary>
            this is what gives the celestial body its orbit and makes it go along the orbit as well
            </summary>
        </member>
        <member name="F:CelestialBody.orbitingBodies">
            <summary>
            A list of this body's moons (or, in the case of the Sun, a list of the planets).
            </summary>
        </member>
        <member name="F:CelestialBody.pqsController">
            <summary>
            The pqsController computes the terrain of the planet. Note that for the Sun, pqsController = null.
            </summary>
        </member>
        <member name="F:CelestialBody.Radius">
            <summary>
            The radius of the planet in meters. Note that this is only the radius of "sea level"; the actual terrain may be higher.
            </summary>
        </member>
        <member name="F:CelestialBody.rotationPeriod">
            <summary>
            The time, in seconds, for the body to complete one rotation around its axis
            </summary>
        </member>
        <member name="F:CelestialBody.sphereOfInfluence">
            <summary>
            The radius of this body's sphere of influence (measured from the center of the body), in meters.
            </summary>
        </member>
        <member name="F:CelestialBody.tidallyLocked">
            <summary>
            Presumably, whether this body is tidally locked to the body around with it orbits.
            </summary>
        </member>
        <member name="F:CelestialBody.timeWarpAltitudeLimits">
            <summary>
            Presumably, this gives the minimum altitude you must have in order to be allowed to use each
            warp rate when in this body's sphere of influence.
            </summary>
        </member>
        <member name="F:CelestialBody.useLegacyAtmosphere">
            <summary>
            It appears that this setting toggles between old and new atmosphere system
            </summary>
        </member>
        <member name="M:CelestialBody.GetAltitude(Vector3d)">
            <summary>
            Gets the height of a given position above this body's sea level, in meters.
            </summary>
            <param name="worldPos">A position in world coordinates</param>
            <returns>Altitude in meters</returns>
        </member>
        <member name="M:CelestialBody.GetFrameVel">
            <summary>
            The velocity of the CelestialBody, {AliceWorld, Sun}. (See Orbit.cs for
            the reference frame definitions).
            </summary>
        </member>
        <member name="M:CelestialBody.GetLatitude(Vector3d)">
            <summary>
            Gets the latitude of a given position, in degrees.
            </summary>
            <param name="worldPos">A position in world coordinates</param>
            <returns>Latitude in degrees</returns>
        </member>
        <member name="M:CelestialBody.GetLongitude(Vector3d)">
            <summary>
            Gets the longitude of a given position, in degrees. Note that you CANNOT count on this value being in any particular range.
            This function may for example return 420, meaning 60 degrees east. You would be well advised to coerce it into a standard
            range like -180 to 180 before using it.
            </summary>
            <param name="worldPos">A position in world coordinates</param>
            <returns>Longitude in degrees</returns>
        </member>
        <member name="M:CelestialBody.GetRelSurfacePosition(System.Double,System.Double,System.Double)">
            <summary>
            Returns a vector pointing from the center of the body to the given latitude, longitude, and altitude.
            </summary>
            <param name="lat">Latitude in degrees</param>
            <param name="lon">Longitude in degrees</param>
            <param name="alt">Altitude above sea level in meters</param>
            <returns>A position vector relative to the center of the body</returns>
        </member>
        <member name="M:CelestialBody.getRFrmVel(Vector3d)">
            <summary>
            Returns the velocity at a given position of the frame of reference that rotates with the planet.
            This velocity is the difference between the "orbit" and "surface" velocities.
            </summary>
            <param name="worldPos">A position in world coordinates</param>
            <returns>Velocity of the rotating reference frame</returns>
        </member>
        <member name="M:CelestialBody.GetSurfaceNVector(System.Double,System.Double)">
            <summary>
            Returns a unit vector perpendicular to the surface of the body at the given latitude and
            longitude (pretending for the moment that the body is a perfect sphere).
            </summary>
            <param name="lat">Latitude in degrees</param>
            <param name="lon">Longitude in degrees</param>
            <returns>A unit normal vector to the surface</returns>
        </member>
        <member name="M:CelestialBody.GetWorldSurfacePosition(System.Double,System.Double,System.Double)">
            <summary>
            Returns the position, in world coordinates, of a given latitude, longitude, and altitude
            </summary>
            <param name="lat">Latitude in degrees</param>
            <param name="lon">Longitude in degrees</param>
            <param name="alt">Altitude above sea level in meters</param>
            <returns>Position in world coordinates</returns>
        </member>
        <member name="M:CelestialBody.RevealAltitude">
             <summary>Returns the body's altitude above the reference sphere of its primary</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:CelestialBody.RevealMass">
             <summary>Returns the body's mass, in kg</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:CelestialBody.RevealName">
             <summary>Returns the body's tracking station name</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:CelestialBody.RevealSituationString">
             <summary>Describes the state of the body</summary>
            
             <returns>A string containing the sphere of influence and trajectory of the object</returns>
             
             <example>"Orbiting the Sun"</example>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:CelestialBody.RevealSpeed">
             <summary>Returns the body's speed</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:CelestialBody.RevealType">
             <summary>Returns the type of the body</summary>
            
             <returns>One of "Sun", "Planet", or "Moon"</returns>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="P:CelestialBody.DiscoveryInfo">
            <summary>Describes to what extent this body has been explored</summary>
        </member>
        <member name="P:CelestialBody.orbit">
            <summary>
            Describes the orbit of this body around its primary.
            </summary>
        </member>
        <member name="P:CelestialBody.position">
            <summary>
            The position of the center of the body, in world coordinates.
            </summary>
        </member>
        <member name="P:CelestialBody.referenceBody">
            <summary>
            Presumably, the body this body orbits around
            </summary>
        </member>
        <member name="T:ConfigNode">
            <summary>
            A ConfigNode represents a collection of data that can be serialized to or deserialized from a file.
            A ConfigNode contains a set of values, and optionally
            one or more ConfigNodes, so they can be used recursively.
            </summary>
        </member>
        <member name="M:ConfigNode.AddNode(System.String)">
            <summary>
            Add a sub-ConfigNode with a given name to this node.
            </summary>
            <param name="name">The name of the new node</param>
            <returns>The newly created sub-ConfigNode</returns>
        </member>
        <member name="M:ConfigNode.AddValue(System.String,System.Object)">
            <summary>
            Add a new piece of data to this ConfigNode. Values show up in serialized ConfigNodes as lines of the form
            <para><code>name = value</code></para>
            </summary>
            <param name="name">The name of the new value.</param>
            <param name="value">The data to store.</param>
        </member>
        <member name="M:ConfigNode.AddValue(System.String,System.String)">
            <summary>
            Add a new piece of data to this ConfigNode. Values show up in serialized ConfigNodes as lines of the form
            <para><code>name = value</code></para>
            </summary>
            <param name="name">The name of the new value.</param>
            <param name="value">The data to store.</param>
        </member>
        <member name="M:ConfigNode.ClearData">
            <summary>
            Remove all nodes and values?
            </summary>
        </member>
        <member name="M:ConfigNode.ClearNodes">
            <summary>
            Remove all sub-ConfigNodes from this ConfigNode?
            </summary>
        </member>
        <member name="M:ConfigNode.ClearValues">
            <summary>
            Remove all values from this ConfigNode?
            </summary>
        </member>
        <member name="M:ConfigNode.CopyTo(ConfigNode)">
            <summary>
            Copies the contents of this node into a different ConfigNode
            </summary>
            <param name="node">The ConfigNode to copy this one into.</param>
        </member>
        <member name="M:ConfigNode.CreateConfigFromObject(System.Object)">
            <summary>
            Create a ConfigNode from a given object. This function will use reflection to scan the given object
            looking for fields with the [Persistent] attribute. When it finds such a field 
            it adds it as a name-value pair to the returned ConfigNode. The name wil be the name
            of the field, and the value will the the serialized version of the field's data.
            </summary>
            <param name="obj">The object to scan to create a ConfigNode</param>
            <returns>A ConfigNode containing the persistent fields of the object.</returns>
        </member>
        <member name="M:ConfigNode.CreateConfigFromObject(System.Object,System.Int32)">
            <summary>
            Like CreateConfigFromObject, but only pays attention to fields with the "pass"
            field of the [Persistent] attribute set to pass.
            </summary>
            <param name="obj">The object to scan to create a ConfigNode.</param>
            <param name="pass">A flag indicate which fields to serialize.</param>
            <returns>A ConfigNode containing the desired persistent fields of the object.</returns>
        </member>
        <member name="M:ConfigNode.LoadObjectFromConfig(System.Object,ConfigNode)">
            <summary>
            Initialize an existing object using data from the ConfigNode. This method
            will scan the object looking for fields with the [Persistent] attribute. When it
            finds such a field, it looks in the ConfigNode for a matching name-value pair, and then
            parses the value and sets the field to the result.
            </summary>
            <param name="obj">The object to initialize</param>
            <param name="node">The ConfigNode used to initialize the object.</param>
            <returns></returns>
        </member>
        <member name="M:ConfigNode.LoadObjectFromConfig(System.Object,ConfigNode,System.Int32)">
            <summary>
            Like LoadObjectFromConfig, but only pays attention to fields for which the "pass"
            field of the [Persistent] attribute is equal to pass.
            </summary>
            <param name="obj">The object to initialize</param>
            <param name="node">The ConfigNode used to initialize the object.</param>
            <param name="pass">A flag indicating which fields to initialize.</param>
            <returns></returns>
        </member>
        <member name="M:ConfigNode.Save(System.String)">
            <summary>
            Seralize this ConfigNode to a file.
            </summary>
            <param name="fileFullName">A filename (absolute path?)</param>
            <returns>?</returns>
        </member>
        <member name="M:ConfigNode.ToString">
            <summary>
            Seralizes this ConfigNode to a string.
            </summary>
            <returns>A serialized version of this ConfigNode</returns>
        </member>
        <member name="T:ControlTypes">
            <summary>
            The different controls that it is possible to lock the player out of
            using InputLockManager. You can OR them together to lock the player
            out of multiple controls at once.
            </summary>
            <remarks>
            TaranisElsu compiled this list of the binary values of the enum members as of KSP 0.24.2, which makes
            it clearer which controls are locked in each case:
            
            <code>None                                                                                          0
            PITCH                                                                                         1
            ROLL                                                                                        100
            YAW                                                                                        1000
            THROTTLE                                                                                  10000
            SAS                                                                                      100000
            PAUSE                                                                                   1000000
            STAGING                                                                                10000000
            CAMERAMODES                                                                          1 00000000
            MISC                                                                                10 00000000
            CAMERACONTROLS                                                                     100 00000000
            TIMEWARP                                                                          1000 00000000
            MAP                                                                              10000 00000000
            LINEAR                                                                          100000 00000000
            QUICKSAVE                                                                      1000000 00000000
            QUICKLOAD                                                                     10000000 00000000
            VESSEL_SWITCHING                                                            1 00000000 00000000
            CUSTOM_ACTION_GROUPS                                                       10 00000000 00000000
            GROUP_ABORT                                                               100 00000000 00000000
            GROUP_GEARS                                                              1000 00000000 00000000
            GROUP_LIGHTS                                                            10000 00000000 00000000
            GROUP_BRAKES                                                           100000 00000000 00000000
            GROUP_STAGE                                                           1000000 00000000 00000000
            GROUPS_ALL                                                            1111110 00000000 00000000
            ACTIONS_SHIP                                                         10000000 00000000 00000000
            ACTIONS_EXTERNAL                                                   1 00000000 00000000 00000000
            ACTIONS_ALL                                                        1 10000000 00000000 00000000
            RCS                                                               10 00000000 00000000 00000000
            WHEEL_STEER                                                      100 00000000 00000000 00000000
            WHEEL_THROTTLE                                                  1000 00000000 00000000 00000000
            EVA_INPUT                                                      10000 00000000 00000000 00000000
            EDITOR_ICON_HOVER                                             100000 00000000 00000000 00000000
            EDITOR_ICON_PICK                                             1000000 00000000 00000000 00000000
            EDITOR_TAB_SWITCH                                           10000000 00000000 00000000 00000000
            EDITOR_SAVE                                               1 00000000 00000000 00000000 00000000
            EDITOR_LOAD                                              10 00000000 00000000 00000000 00000000
            EDITOR_EXIT                                             100 00000000 00000000 00000000 00000000
            EDITOR_NEW                                             1000 00000000 00000000 00000000 00000000
            EDITOR_LAUNCH                                         10000 00000000 00000000 00000000 00000000
            EDITOR_UI_TOPRIGHT                                    11111 00000000 00000000 00000000 00000000
            EDITOR_PAD_PICK_PLACE                                100000 00000000 00000000 00000000 00000000
            EDITOR_PAD_PICK_COPY                                1000000 00000000 00000000 00000000 00000000
            EDITOR_EDIT_STAGES                                 10000000 00000000 00000000 00000000 00000000
            EDITOR_EDIT_NAME_FIELDS                          1 00000000 00000000 00000000 00000000 00000000
            EDITOR_ROTATE_PARTS                             10 00000000 00000000 00000000 00000000 00000000
            EDITOR_UNDO_REDO                               100 00000000 00000000 00000000 00000000 00000000
            EDITOR_SYM_SNAP                               1000 00000000 00000000 00000000 00000000 00000000
            EDITOR_OVERLAYS                              10000 00000000 00000000 00000000 00000000 00000000
            EDITOR_MODE_SWITCH                          100000 00000000 00000000 00000000 00000000 00000000
            EDITOR_UI_TOPBAR                            100001 00011111 00000000 00000000 00000000 00000000
            EDITOR_UI                                   101101 10011111 00000000 00000000 00000000 00000000
            EDITOR_SOFT_LOCK                            111110 01100000 11100000 00000000 00000000 00000000
            EDITOR_LOCK                                 111110 01100000 11100000 00000000 00000100 00000000
            TRACKINGSTATION_UI                         1000000 00000000 00000000 00000000 00000000 00000000
            TRACKINGSTATION_ALL                        1000000 00000000 00000000 00000000 00001100 00000000
            KSC_FACILITIES                            10000000 00000000 00000000 00000000 00000000 00000000
            KSC_UI                                  1 00000000 00000000 00000000 00000000 00000000 00000000
            KSC_ALL                                 1 10000000 00000000 00000000 00000000 00001100 00000000
            APPLAUNCHER_BUTTONS                    10 00000000 00000000 00000000 00000000 00000000 00000000
            ALL_SHIP_CONTROLS       11111111 11111111 11111111 11111111 11111111 11111110 00100010 10111111
            All                     11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111</code>
            
            </remarks>
        </member>
        <member name="T:Decoupler">
            <summary>
            The old, deprecated class that used to be used to implement decouplers before PartModules.
            Use ModuleDecouple or ModuleAnchoredDecoupler instead.
            </summary>
        </member>
        <member name="T:DecouplerGUI">
            <summary>
            An old, deprecated class that used to be used to implement decouplers before PartModules.
            Use ModuleDecouple or ModuleAnchoredDecoupler instead.
            </summary>
        </member>
        <member name="T:DiscoverableObjectsUtil">
            <summary>Static methods used by asteroids</summary>
        </member>
        <member name="M:DiscoverableObjectsUtil.GenerateAsteroidName">
             <summary>Generates an suitably science-y asteroid name</summary>
              
             <returns>A random string of the form "XXX-###".</returns>
            
        </member>
        <member name="T:DiscoveryInfo">
             <summary>Represents the "remote sensing" information available for an IDiscoverable</summary>
            
             <invariant>this.fadeUT = this.lastObservedTime + this.unobservedLifetime</invariant>
            
        </member>
        <member name="F:DiscoveryInfo.distance">
             <summary>Tracking station wrapper for IDiscoverable.RevealAltitude()</summary>
             
             <remarks>Requires DiscoveryLevels.StateVectors</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.situation">
             <summary>Tracking station wrapper for IDiscoverable.RevealSituationString()</summary>
             
             <remarks>Requires DiscoveryLevels.StateVectors</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.speed">
             <summary>Tracking station wrapper for IDiscoverable.RevealSpeed()</summary>
             
             <remarks>Requires DiscoveryLevels.StateVectors</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.mass">
             <summary>Tracking station wrapper for IDiscoverable.RevealMass()</summary>
             
             <remarks>Requires DiscoveryLevels.Appearance</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.type">
             <summary>Tracking station wrapper for IDiscoverable.RevealType()</summary>
             
             <remarks>Requires DiscoveryLevels.Appearance</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.size">
             <summary>Tracking station wrapper for this.objectSize</summary>
             
             <remarks>Always visible</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.trackingStatus">
             <summary>Tracking station wrapper for Level?</summary>
             
             <remarks>Always visible</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.signalStrengthPercent">
             <summary>Tracking station wrapper for GetSignalStrength()</summary>
             
             <remarks>Rounded to the nearest 0.1%.
            
             Always visible</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.name">
             <summary>Tracking station wrapper for IDiscoverable.RevealName()</summary>
             
             <remarks>Requires DiscoveryLevels.Name</remarks>
            
        </member>
        <member name="F:DiscoveryInfo.signalStrengthLevel">
             <summary>Tracking station wrapper for GetSignalStrengthCaption()</summary>
             
             <remarks>Always visible</remarks>
            
        </member>
        <member name="M:DiscoveryInfo.#ctor(IDiscoverable,DiscoveryLevels,System.Double)">
             <summary>Initializes a Class C asteroid</summary>
            
             <param name="host">The vessel or celestial body to which this DiscoveryInfo applies</param>
             <param name="level">The amount of knowledge for the asteroid</param>
             <param name="untrackedLifetime">The amount of time the asteroid can remain untracked 
             	before disappearing</param>
            
        </member>
        <member name="M:DiscoveryInfo.#ctor(IDiscoverable,System.Double)">
             <summary>Initializes a Class C asteroid, and assumes all properties are already known.</summary>
            
             <param name="host">The vessel or celestial body to which this DiscoveryInfo applies</param>
             <param name="untrackedLifetime">The amount of time the asteroid can remain untracked 
             	before disappearing</param>
            
        </member>
        <member name="M:DiscoveryInfo.#ctor(IDiscoverable)">
             <summary>Initializes a Class C asteroid, and assumes all properties are already known.</summary>
            
             <param name="host">The vessel or celestial body to which this DiscoveryInfo applies</param>
            
        </member>
        <member name="M:DiscoveryInfo.GetSignalStrengthCaption(System.Double)">
             <summary>Returns a text description of the signal strength</summary>
             
             <returns>If <paramref name="signal"/> is in [0.0, 0.2), returns "Very Weak"</returns>
             <returns>If <paramref name="signal"/> is in [0.2, 0.4), returns "Weak"</returns>
             <returns>If <paramref name="signal"/> is in [0.4, 0.6), returns "Average"</returns>
             <returns>If <paramref name="signal"/> is in [0.6, 0.8), returns "Good"</returns>
             <returns>If <paramref name="signal"/> is in [0.8, 1.0], returns "Strong"</returns>
            
        </member>
        <member name="M:DiscoveryInfo.GetSizeClassDescription(UntrackedObjectClass)">
             <summary>Returns long description of asteroid type</summary>
            
             <param name="sizeClass">The asteroid type to label</param>
            
             <returns>The asteroid class explanation printed on the tracking station's info panel.
            
             <example>"Class C Objects are about average-sized..."</example>
            
             If not a valid value of UntrackedObjectClass, returns "This seems to be a non-standard size class. Who knows what it'll look like?"
             </returns>
        </member>
        <member name="M:DiscoveryInfo.GetSizeClassSizes(UntrackedObjectClass)">
             <summary>Returns asteroid size displayed in map view</summary>
            
             <param name="sizeClass">The asteroid type to label</param>
            
             <returns>The asteroid class printed beneath an untracked asteroid.
            
             <example>"C (Medium)"</example>
            
             If not a valid value of UntrackedObjectClass, returns "???"
             </returns>
        </member>
        <member name="M:DiscoveryInfo.GetSignalLife(System.Double)">
             <summary>Returns the fraction of the asteroid's unobservedLifetime that remains</summary>
            
             <param name="UT">The time at which the signal life is measured</param>
             
             <remarks>GetSignalLife(t_discover) == 1.0
             GetSignalLife(fadeUT) == 0.0</remarks>
            
        </member>
        <member name="M:DiscoveryInfo.GetSignalStrength(System.Double)">
             <summary>Returns amount of time remaining until the asteroid is lost, in units of referenceLifetime</summary>
            
             <param name="UT">The time at which the signal strength is measured</param>
             
             <remarks>GetSignalStrength(t_discover) == unobservedLifetime / referenceLifetime
             GetSignalStrength(fadeUT) == 0.0</remarks>
            
        </member>
        <member name="M:DiscoveryInfo.HaveKnowledgeAbout(DiscoveryLevels)">
             <summary>Function testing if an asteroid has a particular discovery level</summary>
            
             <param name="lvl">The flag(s) whose presence must be tested.</param>
             
             <returns>True if at least one of the flags in <paramref name="lvl"/> is in 
            	this object, false otherwise</returns>
            
        </member>
        <member name="M:DiscoveryInfo.SetLastObservedTime(System.Double)">
             <summary>Logs an asteroid observation</summary>
            
             <param name="UT">The new time of last observation</param>
            
        </member>
        <member name="M:DiscoveryInfo.SetLevel(DiscoveryLevels)">
             <summary>Sets the level of knowledge the player has for the asteroid</summary>
            
             <param name="level">The flags representing the asteroid's exploration state</param>
            
        </member>
        <member name="M:DiscoveryInfo.SetReferenceLifetime(System.Double)">
             <summary>Updates the reference lifetime</summary>
            
             <param name="time">Changes the scaling of signal strength.</param>
            
        </member>
        <member name="M:DiscoveryInfo.SetUnobservedLifetime(System.Double)">
             <summary>Updates the time for which the asteroid can go untracked, preserving class invariants</summary>
            
             <param name="time">The maximum time to track the asteroid</param>
            
        </member>
        <member name="M:DiscoveryInfo.SetUntrackedObjectSize(UntrackedObjectClass)">
             <summary>Updates the asteroid size</summary>
            
             <param name="size">The asteroid class (A-E)</param>
            
        </member>
        <member name="P:DiscoveryInfo.fadeUT">
            <summary>The time at which the asteroid is scheduled to be deleted</summary>
        </member>
        <member name="P:DiscoveryInfo.lastObservedTime">
             <summary>The time at which the asteroid was last tracked</summary>
            
             <remarks>Stored in persistence file</remarks>
        </member>
        <member name="P:DiscoveryInfo.Level">
             <summary>The asteroid's tracking state</summary>
            
             <remarks>Stored in persistence file as state</remarks>
        </member>
        <member name="P:DiscoveryInfo.objectSize">
             <summary>The size class (A-E) of the asteroid</summary>
            
             <remarks>Stored in persistence file as size</remarks>
        </member>
        <member name="P:DiscoveryInfo.referenceLifetime">
             <summary>The time for which an asteroid can go untracked if it starts at full signal strength</summary>
            
             <remarks>Alternate definition: the time needed for the signal strength to fall by 1 unit.
            
             Always equals 86400  ScenarioDiscoverableObjects.maxUntrackedLifetime.
             For the default spawn settings, this is 1728000 seconds, or 20 Earth days.
             
             Stored in persistence file as refTime</remarks>
        </member>
        <member name="P:DiscoveryInfo.unobservedLifetime">
            <summary>The time for which the asteroid can go untracked before it is deleted</summary>
            
            <remarks>Stored in persistence file as lifetime</remarks>
        </member>
        <member name="T:DiscoveryLevels">
            <summary>Describes an IDiscoverable object's state regarding tracking and exploration</summary>
        </member>
        <member name="F:DiscoveryLevels.Presence">
            <summary>Object has been detected in tracking station</summary>
        </member>
        <member name="F:DiscoveryLevels.Name">
            <summary>Object has been tracked</summary>
        </member>
        <member name="F:DiscoveryLevels.StateVectors">
            <summary>Object is currently tracked</summary>
        </member>
        <member name="F:DiscoveryLevels.Appearance">
            <summary>Unlocks mass and type fields; intended for discoverable CelestialBodies?</summary>
        </member>
        <member name="F:DiscoveryLevels.Owned">
            <summary>Alias for "all flags"</summary>
            
            <remarks>Set for docked asteroids and all normal ship parts.</remarks>
        </member>
        <member name="T:DockingPort">
            <summary>
            An unused class; use ModuleDockingNode instead.
            </summary>
        </member>
        <member name="T:EditorLogic">
            <summary>
            This class has information about what is going on in the editor. In particular see SortedShipList.
            </summary>
        </member>
        <member name="F:EditorLogic.ship">
            <summary>
            EditorLogic.fetch.ship.parts is a list of the parts in the ship currently under construction,
            ordered by the order in which they were added to the ship.
            </summary>
        </member>
        <member name="P:EditorLogic.SortedShipList">
            <summary>
            A list of all parts in the vessel that is being edited.
            </summary>
        </member>
        <member name="T:EventData`1">
            <summary>
            A type used to generate GameEvents
            
            Use this type with one accompanying type;
            GameEvents.FromToAction,
            GameEvents.HostedFromToAction,
            GameEvents.HostTargetAction
            are commonly used
            
            See EventVoid for events that require no parameters
            or EventReport for a different style
            </summary>
            <typeparam name="T">The type to be passed through on EventData.Fire()</typeparam>
        </member>
        <member name="F:EventData`1.debugEvent">
            <summary>
            Generate debug logs if true
            </summary>
        </member>
        <member name="M:EventData`1.#ctor(System.String)">
            <summary>
            The constructor used to create a new EventData
            
            EventData&lt;Vessel&gt; myNewEvent = new EventData&lt;Vessel&gt;("myNewEvent");
            </summary>
            <param name="eventName">Give the event a string name,
            generally the same as the declared name</param>
        </member>
        <member name="M:EventData`1.Add(EventData{`0}.OnEvent)">
            <summary>
            Add a method to be run when the EventData is fired.
            
            This is generally done in an object's Start or Awake method, or a class' constructor.
            
            Can be setup like:
            
            GameEvents.someEventDataEvent.Add(yourMethod);
            
            or
            
            GameEvents.someEventDataEvent.Add(new EventVoid.OnEvent(yourMethod));
            </summary>
            <param name="evt">The method you want to add; must contain a single parameter
            of the type matching that in the host EventData</param>
        </member>
        <member name="M:EventData`1.Fire(`0)">
            <summary>
            Triggers the EventData
            
            All of the methods added using Add are run after this.
            </summary>
            <param name="data">Single parameter matching the type of the host EventData
            Use this to give information relevant to the event</param>
        </member>
        <member name="M:EventData`1.Remove(EventData{`0}.OnEvent)">
            <summary>
            Remove a method from the list of methods to be run when the EventData is fired.
            
            This is generally done in an object's OnDestroy method.
            </summary>
            <param name="evt">The method you want to remove; must contain a single parameter
            of a type matching that in the host EventData</param>
        </member>
        <member name="T:EventData`1.OnEvent">
            <summary>
            Any methods added to the event must match the delegate's parameters;
            one parameter of the given type in this case.
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:EventData`2">
            <summary>
            A type used to generate GameEvents
            
            Use this type with two accompanying parameters
            </summary>
            <typeparam name="T">The first type to be passed through on EventData.Fire()</typeparam>
            <typeparam name="U">The second type to be passed through on EventData.Fire()</typeparam>
        </member>
        <member name="F:EventData`2.debugEvent">
            <summary>
            Generate debug logs if true
            </summary>
        </member>
        <member name="M:EventData`2.#ctor(System.String)">
            <summary>
            The constructor used to create a new EventData
            
            EventData&lt;Vessel, CelestialBody&gt; myNewEvent = new EventData&lt;Vessel, CelestialBody&gt;("myNewEvent");
            </summary>
            <param name="eventName">Give the event a string name,
            generally the same as the declared name</param>
        </member>
        <member name="M:EventData`2.Add(EventData{`0,`1}.OnEvent)">
            <summary>
            Add a method to be run when the EventData is fired.
            
            This is generally done in an object's Start or Awake method, or a class' constructor.
            
            Can be setup like:
            
            GameEvents.someEventDataEvent.Add(yourMethod);
            
            or
            
            GameEvents.someEventDataEvent.Add(new EventVoid.OnEvent(yourMethod));
            </summary>
            <param name="evt">The method you want to add; must contain two parameters
            of types matching those in the host EventData</param>
        </member>
        <member name="M:EventData`2.Fire(`0,`1)">
            <summary>
            Triggers the EventData
            
            All of the methods added using Add are run after this.
            </summary>
            <param name="data0">A parameter matching the first type of the host EventData
            Use this to give information relevant to the event</param>
            <param name="data1">The second type of the host EventData</param>
        </member>
        <member name="M:EventData`2.Remove(EventData{`0,`1}.OnEvent)">
            <summary>
            Remove a method from the list of methods to be run when the EventData is fired.
            
            This is generally done in an object's OnDestroy method.
            </summary>
            <param name="evt">The method you want to remove; must contain two parameters
            of types matching those in the host EventData</param>
        </member>
        <member name="T:EventData`2.OnEvent">
            <summary>
            Any methods added to the event must match the delegate's parameters;
            two parameters of the given types in this case.
            </summary>
            <param name="data0"></param>
            <param name="data1"></param>
        </member>
        <member name="T:EventData`3">
            <summary>
            A type used to generate GameEvents
            
            Use this type with three accompanying parameters
            </summary>
            <typeparam name="T">The first type to be passed through on EventData.Fire()</typeparam>
            <typeparam name="U">The second type to be passed through on EventData.Fire()</typeparam>
            <typeparam name="V">The third type to be passed through on EventData.Fire()</typeparam>
        </member>
        <member name="F:EventData`3.debugEvent">
            <summary>
            Generate debug logs if true
            </summary>
        </member>
        <member name="M:EventData`3.#ctor(System.String)">
            <summary>
            The constructor used to create a new EventData
            
            EventData&lt;Vessel, CelestialBody, String&gt; myNewEvent = new EventData&lt;Vessel, CelestialBody, String&gt;("myNewEvent");
            </summary>
            <param name="eventName">Give the event a string name,
            generally the same as the declared name</param>
        </member>
        <member name="M:EventData`3.Add(EventData{`0,`1,`2}.OnEvent)">
            <summary>
            Add a method to be run when the EventData is fired.
            
            This is generally done in an object's Start or Awake method, or a class' constructor.
            
            Can be setup like:
            
            GameEvents.someEventDataEvent.Add(yourMethod);
            
            or
            
            GameEvents.someEventDataEvent.Add(new EventVoid.OnEvent(yourMethod));
            </summary>
            <param name="evt">The method you want to add; must contain three parameters
            matching the types of in the host EventData</param>
        </member>
        <member name="M:EventData`3.Fire(`0,`1,`2)">
            <summary>
            Triggers the EventData
            
            All of the methods added using Add are run after this.
            </summary>
            <param name="data0">A parameter matching the first type of the host EventData
            Use this to give information relevant to the event</param>
            <param name="data1">The second type of the host EventData</param>
            <param name="data2">The third type of the host EventData</param>
        </member>
        <member name="M:EventData`3.Remove(EventData{`0,`1,`2}.OnEvent)">
            <summary>
            Remove a method from the list of methods to be run when the EventData is fired.
            
            This is generally done in an object's OnDestroy method.
            </summary>
            <param name="evt">The method you want to remove; must contain three parameters
            matching the types of in the host EventData</param>
        </member>
        <member name="T:EventData`3.OnEvent">
            <summary>
            Any methods added to the event must match the delegate's parameters;
            three parameters of the given types in this case.
            </summary>
            <param name="data0"></param>
            <param name="data1"></param>
            <param name="data2"></param>
        </member>
        <member name="T:EventReport">
            <summary>
             A type frequently used as a parameter in GameEvents
            </summary>
        </member>
        <member name="F:EventReport.eventType">
            <summary>
            An enum used to specify the type of EventReport;
            see FlightEvents for the available types
            </summary>
        </member>
        <member name="F:EventReport.msg">
            <summary>
            A string message that can accompany the EventReport
            </summary>
        </member>
        <member name="F:EventReport.origin">
            <summary>
            The Part responsible for generating the EventReport
            </summary>
        </member>
        <member name="F:EventReport.other">
            <summary>
            Usually the originating part name
            </summary>
        </member>
        <member name="F:EventReport.sender">
            <summary>
            The target of the event;
            another part's name, the surface, blank, etc...
            </summary>
        </member>
        <member name="F:EventReport.stage">
            <summary>
            The active stage number when the EventReport is generated;
            can be set to any integer; 0 by default
            </summary>
        </member>
        <member name="M:EventReport.#ctor(FlightEvents,Part,System.String,System.String,System.Int32,System.String)">
            <summary>
            The EventReport constructor, generally used when firing an EventData event
            that calls for an EventReport parameter
            
            someEvent.Fire(new EventReport(...));
            </summary>
            <param name="type"></param>
            <param name="eventCreator"></param>
            <param name="name"></param>
            <param name="otherName"></param>
            <param name="stageNumber"></param>
            <param name="customMsg"></param>
        </member>
        <member name="T:EventVoid">
            <summary>
            A type used to generate GameEvents
            
            Use this type when there is no need to accompany the event with any parameters,
            ie relevant Part, Vessel, CelestialBody, etc...
            
            See EventData for events that require such extra information
            </summary>
        </member>
        <member name="F:EventVoid.debugEvent">
            <summary>
            Generate debug logs if true
            </summary>
        </member>
        <member name="M:EventVoid.#ctor(System.String)">
            <summary>
            The constructor used to create a new EventVoid
            
            EventVoid myNewEvent = new EventVoid("myNewEvent");
            </summary>
            <param name="eventName">Give the event a string name,
            generally the same as the declared name</param>
        </member>
        <member name="M:EventVoid.Add(EventVoid.OnEvent)">
            <summary>
            Add a method to be run when the EventVoid is fired.
            
            This is generally done in an object's Start or Awake method, or a class' constructor.
            
            Can be setup like:
            
            GameEvents.someEventVoidEvent.Add(yourMethod);
            
            or
            
            GameEvents.someEventVoidEvent.Add(new EventVoid.OnEvent(yourMethod));
            </summary>
            <param name="evt">The method you want to add, should contain no parameters</param>
        </member>
        <member name="M:EventVoid.Fire">
            <summary>
            Triggers the EventVoid
            
            All of the methods added using Add are run after this.
            </summary>
        </member>
        <member name="M:EventVoid.Remove(EventVoid.OnEvent)">
            <summary>
            Remove a method from the list of methods to be run when the EventVoid is fired.
            
            This is generally done in an object's OnDestroy method.
            </summary>
            <param name="evt">The method you want to remove, should contain no parameters</param>
        </member>
        <member name="T:EventVoid.OnEvent">
            <summary>
            Any methods added to the event must match the delegate's parameters; none in this case
            </summary>
        </member>
        <member name="M:KSP.IO.File.AppendAllText``1(System.String,System.String,Vessel)">
            <summary>
            Append a string to a file, or creates it if it doesn't exist.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="filename"></param>
            <param name="flight"></param>
        </member>
        <member name="M:KSP.IO.File.AppendText``1(System.String,Vessel)">
            <summary>
            Open a stream that appends to a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.Create``1(System.String,Vessel)">
            <summary>
            Open a stream that creates a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.CreateText``1(System.String,Vessel)">
            <summary>
            Open a stream that creates a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.Delete``1(System.String,Vessel)">
            <summary>
            Delete a file in your IO sandbox.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
        </member>
        <member name="M:KSP.IO.File.Exists``1(System.String,Vessel)">
            <summary>
            Find out if a file in your IO sandbox exists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.Open``1(System.String,KSP.IO.FileMode,Vessel)">
            <summary>
            Open a stream that operates on a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="mode"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.OpenText``1(System.String,Vessel)">
            <summary>
            Open a stream that operates on a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.OpenWrite``1(System.String,Vessel)">
            <summary>
            Open a stream that writes to a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.ReadAllBytes``1(System.String,Vessel)">
            <summary>
            Read all the bytes from a file in your IO sandbox.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
        </member>
        <member name="M:KSP.IO.File.ReadAllLines``1(System.String,Vessel)">
            <summary>
            Read all lines from a file in your IO sandbox.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.ReadAllText``1(System.String,Vessel)">
            <summary>
            Read all the text from a file in your IO sandbox.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.File.WriteAllBytes``1(System.Byte[],System.String,Vessel)">
            <summary>
            Write a bunch of bytes to a file on disk
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="filename"></param>
            <param name="flight"></param>
        </member>
        <member name="M:KSP.IO.File.WriteAllLines``1(System.String[],System.String,Vessel)">
            <summary>
            Write an array of strings to a file, with each string becoming a line.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="filename"></param>
            <param name="flight"></param>
        </member>
        <member name="M:KSP.IO.File.WriteAllText``1(System.String,System.String,Vessel)">
            <summary>
            Write a string to a file.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="filename"></param>
            <param name="flight"></param>
        </member>
        <member name="T:KSP.IO.FileInfo">
            <summary>
            A surrogate for System.IO.FileInfo.
            </summary>
        </member>
        <member name="M:KSP.IO.FileInfo.AppendText">
            <summary>
            Creates a System.IO.StreamWriter that appends text to the file represented by this instance of the System.IO.FileInfo.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.CopyTo(System.String)">
            <summary>
            Copies an existing file to a new file, disallowing the overwriting of an existing file.
            </summary>
            <param name="destFileName"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.CopyTo(System.String,System.Boolean)">
            <summary>
            Copies an existing file to a new file, allowing the overwriting of an existing file.
            </summary>
            <param name="destFileName"></param>
            <param name="overwrite"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.Create">
            <summary>
            Creates a file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.CreateForType``1(System.String,Vessel)">
            <summary>
            Create a text reader stream.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.CreateText">
            <summary>
            Creates a KSP.IO.TextWriter that writes a new text file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.Decrypt">
            <summary>
            Decrypts a file that was encrypted by the current account using the System.IO.FileInfo.Encrypt() method.
            </summary>
        </member>
        <member name="M:KSP.IO.FileInfo.Delete">
            <summary>
            Permanently deletes a file.
            </summary>
        </member>
        <member name="M:KSP.IO.FileInfo.Encrypt">
            <summary>
            Encrypts a file so that only the account used to encrypt the file can decrypt it.
            </summary>
        </member>
        <member name="M:KSP.IO.FileInfo.MoveTo(System.String)">
            <summary>
            Moves a specified file to a new location, providing the option to specify a new file name.
            </summary>
            <param name="destFileName"></param>
        </member>
        <member name="M:KSP.IO.FileInfo.Open(KSP.IO.FileMode)">
            <summary>
            Opens a file in the specified mode.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.Open(KSP.IO.FileMode,KSP.IO.FileAccess)">
            <summary>
            Opens a file in the specified mode with read, write, or read/write access.
            </summary>
            <param name="mode"></param>
            <param name="access"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.Open(KSP.IO.FileMode,KSP.IO.FileAccess,KSP.IO.FileShare)">
            <summary>
            Opens a file in the specified mode with read, write, or read/write access and the specified sharing option.
            </summary>
            <param name="mode"></param>
            <param name="access"></param>
            <param name="share"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.OpenRead">
            <summary>
            Creates a read-only System.IO.FileStream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.OpenText">
            <summary>
            Creates a System.IO.StreamReader with UTF8 encoding that reads from an existing text file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.OpenWrite">
            <summary>
            Creates a write-only System.IO.FileStream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.Replace(System.String,System.String)">
            <summary>
            Replaces the contents of a specified file with the file described by the current System.IO.FileInfo object, deleting the original file, and creating a backup of the replaced file.
            </summary>
            <param name="destinationFileName"></param>
            <param name="destinationBackupFileName"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.Replace(System.String,System.String,System.Boolean)">
            <summary>
            Replaces the contents of a specified file with the file described by the current System.IO.FileInfo object, deleting the original file, and creating a backup of the replaced file. Also specifies whether to ignore merge errors.
            </summary>
            <param name="destinationFileName"></param>
            <param name="destinationBackupFileName"></param>
            <param name="ignoreMetadataErrors"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.FileInfo.ToString">
            <summary>
            Returns the path as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="P:KSP.IO.FileInfo.DirectoryName">
            <summary>
            Gets a string representing the directory's full path.
            </summary>
        </member>
        <member name="P:KSP.IO.FileInfo.Exists">
            <summary>
            Gets a value indicating whether a file exists.
            </summary>
        </member>
        <member name="P:KSP.IO.FileInfo.IsReadOnly">
            <summary>
            Gets or sets a value that determines if the current file is read only.
            </summary>
        </member>
        <member name="P:KSP.IO.FileInfo.Length">
            <summary>
            Gets the size, in bytes, of the current file.
            </summary>
        </member>
        <member name="P:KSP.IO.FileInfo.Name">
            <summary>
            Gets the name of the file.
            </summary>
        </member>
        <member name="T:FlightCamera">
            <summary>
            This class is related to control of the main camera used in the flight scene. Its transform is the
            parent of the actual Camera objects.
            </summary>
        </member>
        <member name="F:FlightCamera.fetch">
            <summary>
            Returns the singleton FlightCamera object.
            </summary>
        </member>
        <member name="M:FlightCamera.ActivateUpdate">
            <summary>
            Enables mouse control of the camera.
            </summary>
        </member>
        <member name="M:FlightCamera.DeactivateUpdate">
            <summary>
            Disables mouse control of the camera.
            </summary>
        </member>
        <member name="P:FlightCamera.CamHdg">
            <summary>
            You can set this to change the look direction of the in-flight camera (value is in radians).
            </summary>
        </member>
        <member name="P:FlightCamera.CamPitch">
            <summary>
            You can set this to change the look direction of the in-flight camera (value is in radians).
            </summary>
        </member>
        <member name="T:FlightCtrlState">
            <summary>
            A FlightCtrlState is a snapshot of the state of all control inputs to a vessel at a given instant in time.
            See FlightInputHandler.state and Vessel.OnFlyByWire.
            </summary>
        </member>
        <member name="F:FlightCtrlState.fastThrottle">
            <summary>
            Unused?
            </summary>
        </member>
        <member name="F:FlightCtrlState.gearDown">
            <summary>
            Unused? Landing gear are lowered by sending an Event.
            </summary>
        </member>
        <member name="F:FlightCtrlState.gearUp">
            <summary>
            Unused? Landing gear are raised by sending an Event.
            </summary>
        </member>
        <member name="F:FlightCtrlState.headlight">
            <summary>
            Presumably, whether the EVA headlight is turned on.
            </summary>
        </member>
        <member name="F:FlightCtrlState.killRot">
            <summary>
            Whether SAS is turned on.
            </summary>
        </member>
        <member name="F:FlightCtrlState.mainThrottle">
            <summary>
            The throttle setting; this must be between 0 and 1.
            </summary>
        </member>
        <member name="F:FlightCtrlState.pitch">
            <summary>
            The pitch control input; this must be between -1 and 1.
            </summary>
        </member>
        <member name="F:FlightCtrlState.pitchTrim">
            <summary>
            Presumably, the pitch trim setting, i.e., the pitch input that will
            be given if no other input is given.
            </summary>
        </member>
        <member name="F:FlightCtrlState.roll">
            <summary>
            The roll control input; this must be between -1 and 1.
            </summary>
        </member>
        <member name="F:FlightCtrlState.rollTrim">
            <summary>
            Presumably, the roll trim setting, i.e., the roll input that will
            be given if no other input is given.
            </summary>
        </member>
        <member name="F:FlightCtrlState.X">
            <summary>
            The RCS x-axis control input.
            </summary>
        </member>
        <member name="F:FlightCtrlState.Y">
            <summary>
            The RCS y-axis control input.
            </summary>
        </member>
        <member name="F:FlightCtrlState.yaw">
            <summary>
            The yaw control input; this must be between -1 and 1.
            </summary>
        </member>
        <member name="F:FlightCtrlState.yawTrim">
            <summary>
            Presumably, the yaw trim input; i.e., the yaw input that will be
            given if no other input is given.
            </summary>
        </member>
        <member name="F:FlightCtrlState.Z">
            <summary>
            The RCS z-axis control input.
            </summary>
        </member>
        <member name="M:FlightCtrlState.CopyFrom(FlightCtrlState)">
            <summary>
            Presumably, copies the state of the FlightCtrlState st into this FlightCtrlState object.
            </summary>
            <param name="st"></param>
        </member>
        <member name="P:FlightCtrlState.isNeutral">
            <summary>
            Presumably, whether this flight control represents "neutral" controls, i.e., no input and zero throttle.
            </summary>
        </member>
        <member name="T:FlightGlobals">
            <summary>
            FlightGlobals contains lists of all CelestialBodies and Vessels in the game. 
            It also provides static utility functions for computing the atmospheric and gravitational properties of CelestialBodies.
            </summary>
        </member>
        <member name="F:FlightGlobals.fetch">
            <summary>
            Use this FlightGlobals instance to access non-static members of FlightGlobals.
            For example, the current target is FlightGlobals.fetch.VesselTarget.
            </summary>
        </member>
        <member name="M:FlightGlobals.getAltitudeAtPos(UnityEngine.Vector3)">
            <summary>
            The altitude above the sea level of the current main body of the given world space position. 
            </summary>
            <param name="position">World space position</param>
            <returns>Altitude above sea level</returns>
        </member>
        <member name="M:FlightGlobals.getAltitudeAtPos(Vector3d)">
            <summary>
            The altitude above the sea level of the current main body of the given world space position. 
            </summary>
            <param name="position">World space position</param>
            <returns>Altitude above sea level</returns>
        </member>
        <member name="M:FlightGlobals.getAltitudeAtPos(Vector3d,CelestialBody)">
            <summary>
            The altitude above the sea level of the given body of the given world space position. 
            </summary>
            <param name="position">World space position</param>
            <param name="body">The body in question</param>
            <returns>Altitude above sea level</returns>
        </member>
        <member name="M:FlightGlobals.getAtmDensity(System.Double)">
            <summary>
            Converts an atmospheric pressure into an atmospheric density. Atmospheric density is what
            appears in the KSP drag equation. This function seems to just multiply the input by 1.2230948554874
            </summary>
            <param name="pressure">Use the output of getStaticPressure</param>
            <returns>An atmospheric density, suitable for use in calculating drag.</returns>
        </member>
        <member name="M:FlightGlobals.getExternalTemperature(Vector3d)">
            <summary>
            Finds the temperature at a given world space position.
            </summary>
            <param name="pos">World space position</param>
            <returns>Temperature</returns>
        </member>
        <member name="M:FlightGlobals.getExternalTemperature(System.Single,CelestialBody)">
            <summary>
            Finds the temperature at a given altitude above a given body.
            </summary>
            <param name="altitude">An altitude (in meters?)</param>
            <param name="body">The body of interest</param>
            <returns>Temperture</returns>
        </member>
        <member name="M:FlightGlobals.getGeeForceAtPosition(Vector3d)">
            <summary>
            Returns the gravitational *acceleration* vector at a given position.
            Contrary to its name, it does *not* return force.
            </summary>
            <param name="pos">World space position</param>
            <returns>Gravitational acceleration vector</returns>
        </member>
        <member name="M:FlightGlobals.getMainBody">
            <summary>
            Returns the current dominant body?
            </summary>
            <returns></returns>
        </member>
        <member name="M:FlightGlobals.getMainBody(Vector3d)">
            <summary>
            Returns the body whose sphere of influence contains a given position?
            </summary>
            <param name="refPos">World space position?</param>
            <returns></returns>
        </member>
        <member name="M:FlightGlobals.getStaticPressure">
            <summary>
            Returns the current atmospheric pressure?
            </summary>
            <returns>Atmospheric pressure, in units of Kerbin's atmospheric pressure at sea level</returns>
        </member>
        <member name="M:FlightGlobals.getStaticPressure(Vector3d)">
            <summary>
            Returns the atmospheric pressure at a given position. Feed the output of this
            function into getAtmDensity to get the atmopsheric density.
            </summary>
            <param name="position">World space position</param>
            <returns>Atmospheric pressure, in units of Kerbin's atmospheric pressure at sea level</returns>
        </member>
        <member name="M:FlightGlobals.getStaticPressure(System.Double,CelestialBody)">
            <summary>
            Returns the atmospheric pressure at a given altitude above a given body
            </summary>
            <param name="altitude">Altitude in meters?</param>
            <param name="body">The body in question</param>
            <returns>Atmospheric pressure, in units of Kerbin's atmospheric pressure at sea level</returns>
        </member>
        <member name="M:FlightGlobals.getStaticPressure(Vector3d,CelestialBody)">
            <summary>
            Returns the atmospheric pressure of a given body's atmopshere at a given position
            </summary>
            <param name="position">World space position</param>
            <param name="body">The body in question</param>
            <returns>Atmospheric pressure, in units of Kerbin's atmospheric pressure at sea level</returns>
        </member>
        <member name="M:FlightGlobals.SetVesselTarget(ITargetable)">
            <summary>
            Sets the currently selected target vessel, celestial body, or docking node
            </summary>
            <param name="tgt">The Vessel, CelestialBody, or ModuleDockingNode to target</param>
        </member>
        <member name="P:FlightGlobals.ActiveVessel">
            <summary>
            The vessel the player is currently controlling.
            </summary>
        </member>
        <member name="P:FlightGlobals.Bodies">
            <summary>
            A list of all CelestialBodies in the universe. Contents in 0.18.2: 
            <para>Bodies[0] = Sun</para>
            <para>Bodies[1] = Kerbin</para>
            <para>Bodies[2] = Mun</para>
            <para>Bodies[3] = Minmus</para>
            <para>Bodies[4] = Moho</para>
            <para>Bodies[5] = Eve</para>
            <para>Bodies[6] = Dun</para>
            <para>Bodies[7] = Ike</para>
            <para>Bodies[8] = Jool</para>
            <para>Bodies[9] = Laythe</para>
            <para>Bodies[10] = Vall</para>
            <para>Bodies[11] = Bop</para>
            <para>Bodies[12] = Tylo</para>
            <para>Bodies[13] = Gilly</para>
            <para>Bodies[14] = Pol</para>
            <para>Bodies[15] = Dres</para>
            <para>Bodies[16] = Eeloo</para>
            </summary>
        </member>
        <member name="P:FlightGlobals.DragMultiplier">
            <summary>
            The KSP formula for the drag force on a part is
            (1/2) * DragMultiplier * part.mass * part.mass_drag * airspeed^2
            </summary>
        </member>
        <member name="P:FlightGlobals.RefFrameIsRotating">
            <summary>
            Whether KSP is doing its computations in an inertial reference frame, or the reference frame that 
            rotates with the current dominant celestial body.
            </summary>
        </member>
        <member name="P:FlightGlobals.Vessels">
            <summary>
            A list of all the Vessels that currently exist
            </summary>
        </member>
        <member name="P:FlightGlobals.VesselTarget">
            <summary>
            The currently selected target vessel, celestial body, or docking node. If no target is selected, this is null.
            </summary>
        </member>
        <member name="T:FlightInputHandler">
            <summary>
            FlightInputHandler stores some global information about the control of the current active vessel.
            </summary>
        </member>
        <member name="F:FlightInputHandler.fetch">
            <summary>
            Use this FlightInputHandler instance to access non-static members of the class.
            </summary>
        </member>
        <member name="F:FlightInputHandler.precisionMode">
            <summary>
            Presumably, whether precision mode is engaged.
            </summary>
        </member>
        <member name="F:FlightInputHandler.rcslock">
            <summary>
            Whether RCS is enabled.
            </summary>
        </member>
        <member name="F:FlightInputHandler.stageLock">
            <summary>
            Presumably, whether staging has been locked via Alt-L.
            </summary>
        </member>
        <member name="F:FlightInputHandler.state">
            <summary>
            The FlightCtrlState that represents player input. You can change the on-screen throttle
            by setting FlightCtrlState.state.mainThrottle.
            </summary>
        </member>
        <member name="M:FlightInputHandler.SetNeutralControls">
            <summary>
            Call this to set neutral controls; in particular this wil turn off the throttle.
            </summary>
        </member>
        <member name="P:FlightInputHandler.RCSLock">
            <summary>
            Whether RCS is enabled.
            </summary>
        </member>
        <member name="T:FloatCurve">
            <summary>
            Represents a function of one variable. The function is interpolated from a given set of points,
            and optionally the tangents at those points can be specified.
            </summary>
        </member>
        <member name="M:FloatCurve.Evaluate(System.Single)">
            <summary>
            Evaluate the function at a given value of the input parameter.
            </summary>
            <param name="time">The input parameter (not necessarily a time).</param>
            <returns>The value of the function.</returns>
        </member>
        <member name="T:FuelLine">
            <summary>
            Stock fuel lines are not yet PartModules, but are implemented through this class.
            </summary>
        </member>
        <member name="F:FuelLine.target">
            <summary>
            The part that can draw fuel through this fuel line. This fuel line in turn draws fuel from its parent.
            </summary>
        </member>
        <member name="T:FuelTank">
            <summary>
            The old, deprecated class that implemented fuel tanks before the resource system.
            Don't use this class: to allow a part to store a resource add a RESOURCE block to the part.cfg.
            </summary>
        </member>
        <member name="T:FuelTankGUI">
            <summary>
            An unused class.
            </summary>
        </member>
        <member name="T:GameEvents">
            <summary>
            GameEvents are EventData or EventVoid methods called when certain conditions are met.
            
            Many include some relevant data on the objects affected when they are triggered.
            
            Use:
            
            GameEvents.desiredEvent.Add(yourMethod);
            
            and
            
            GameEvents.desiredEvent.Removed(yourMethod);
            
            to add and remove methods from a list of methods to be called when the event is triggered.
            
            Methods are generally added in your object's Start or Awake method and generally removed
            in your object's OnDestroy method.
            
            Be sure not add methods multiple times withoud destroying them between additions.
            </summary>
        </member>
        <member name="F:GameEvents.onActiveJointNeedUpdate">
            <summary>
            Triggered when a vessel docks or attaches with the grappling device;
            fires twice, once for each vessel
            </summary>
        </member>
        <member name="F:GameEvents.onCollision">
            <summary>
            Triggered when two parts collide
            </summary>
        </member>
        <member name="F:GameEvents.onCrash">
            <summary>
            Triggered when a part or vessel crashes into the terrain
            </summary>
        </member>
        <member name="F:GameEvents.onCrashSplashdown">
            <summary>
            Triggered when a part crashes into the ocean
            </summary>
        </member>
        <member name="F:GameEvents.onCrewBoardVessel">
            <summary>
            Triggered when an EVA Kerbal boards a vessel
            </summary>
        </member>
        <member name="F:GameEvents.onCrewKilled">
            <summary>
            Triggered whenever a Kerbal dies; either on EVA or in a crashing vessel
            </summary>
        </member>
        <member name="F:GameEvents.onCrewOnEva">
            <summary>
            Triggered when a Kerbal goes on EVA
            </summary>
        </member>
        <member name="F:GameEvents.onDominantBodyChange">
            <summary>
            Triggered when changing SOI; both objects return the new dominant CelestialBody
            
            See also onVesselSOIChanged
            </summary>
        </member>
        <member name="F:GameEvents.onEditorShipModified">
            <summary>
            Triggered when any part is added or removed from a vessel in the editor;
            also triggered when any tweakable settings are changed;
            also when undo is called
            </summary>
        </member>
        <member name="F:GameEvents.onFlagPlant">
            <summary>
            When a flag is planted by an EVA Kerbal
            </summary>
        </member>
        <member name="F:GameEvents.onFlagSelect">
            <summary>
            Triggered when a flag is selected from the space center's flag pole
            </summary>
        </member>
        <member name="F:GameEvents.onFlightReady">
            <summary>
            Triggered when a vessel is fully loaded
            </summary>
        </member>
        <member name="F:GameEvents.onFloatingOriginShift">
            <summary>
            Deprecated?
            </summary>
        </member>
        <member name="F:GameEvents.OnFundsChanged">
            <summary>
            When Funds level changes, returns total Funds amount
            </summary>
        </member>
        <member name="F:GameEvents.onGamePause">
            <summary>
            When the game is paused
            </summary>
        </member>
        <member name="F:GameEvents.onGameSceneLoadRequested">
            <summary>
            Triggered upon scene change requests; returns the target GameScene
            </summary>
        </member>
        <member name="F:GameEvents.OnGameSettingsApplied">
            <summary>
            When Game Settings are applied in the main settings menu, or the in-game settings menu
            </summary>
        </member>
        <member name="F:GameEvents.onGameStateCreated">
            <summary>
            When a game is first created or loaded; returns the Game object
            </summary>
        </member>
        <member name="F:GameEvents.onGameStateLoad">
            <summary>
            Triggered on loading a game, returns the game's full ConfigNode from the persistent file
            </summary>
        </member>
        <member name="F:GameEvents.onGameStateSave">
            <summary>
            Triggered on saving a game, returns the game's full ConfigNode from the persistent file
            </summary>
        </member>
        <member name="F:GameEvents.onGameStateSaved">
            <summary>
            Triggered when a game is saved, returns the Game object;
            </summary>
        </member>
        <member name="F:GameEvents.onGameUnpause">
            <summary>
            When the game is unpaused
            </summary>
        </member>
        <member name="F:GameEvents.onGUIApplicationLauncherDestroyed">
            <summary>
            When the application launcher (toolbar) is closed
            </summary>
        </member>
        <member name="F:GameEvents.onGUIApplicationLauncherReady">
            <summary>
            Called when the ApplicationLauncher toolbar is ready to have buttons added to it.
            </summary>
        </member>
        <member name="F:GameEvents.onGUIAstronautComplexDespawn">
            <summary>
            When the astronaut complex window closes
            </summary>
        </member>
        <member name="F:GameEvents.onGUIAstronautComplexSpawn">
            <summary>
            When the astronaut complex window opens; from the space center or editor
            </summary>
        </member>
        <member name="F:GameEvents.onGUILaunchScreenDespawn">
            <summary>
            When the vessel selection screen is closed or a vessel is selected and launched
            </summary>
        </member>
        <member name="F:GameEvents.onGUILaunchScreenSpawn">
            <summary>
            When the launch screen (that allows you to view and select available vessels) is opened;
            after selecting the launchpad/runway from the space center.
            
            See VesselSpawnInfo for more on what is returned by this callback.
            </summary>
        </member>
        <member name="F:GameEvents.onGUILaunchScreenVesselSelected">
            <summary>
            When a vessel is selected from the vessel selection screen at the space center
            </summary>
        </member>
        <member name="F:GameEvents.onGUIMessageSystemReady">
            <summary>
            When the application launcher's message button is ready
            </summary>
        </member>
        <member name="F:GameEvents.onGUIMissionControlDespawn">
            <summary>
            When the mission control center window closes
            </summary>
        </member>
        <member name="F:GameEvents.onGUIMissionControlSpawn">
            <summary>
            When the mission control center window opens
            </summary>
        </member>
        <member name="F:GameEvents.onGUIPrefabLauncherReady">
            <summary>
            When the application launcher (toolbar) loads;
            triggers before onGUIApplicationLauncherReady and onGUIMessageSystemReady
            </summary>
        </member>
        <member name="F:GameEvents.onGUIRecoveryDialogDespawn">
            <summary>
            When the recovery dialog window closes
            </summary>
        </member>
        <member name="F:GameEvents.onGUIRecoveryDialogSpawn">
            <summary>
            When the recovery dialog window opens
            </summary>
        </member>
        <member name="F:GameEvents.onGUIRnDComplexDespawn">
            <summary>
            When the R&amp;D center window closes
            </summary>
        </member>
        <member name="F:GameEvents.onGUIRnDComplexSpawn">
            <summary>
            When the R&amp;D center window opens
            </summary>
        </member>
        <member name="F:GameEvents.onHideUI">
            <summary>
            Called when the player hides the UI by pressing F2. Register for this callback (and for onShowUI)
            so that you can hide your UI too.
            </summary>
        </member>
        <member name="F:GameEvents.onInputLocksModified">
            <summary>
            Triggered when input locks are activated or deactivated;
            when putting the mouse over one window/button locks the controls
            of another window/button
            </summary>
        </member>
        <member name="F:GameEvents.onJointBreak">
            <summary>
            Deprecated? Use onPartJointBreak
            </summary>
        </member>
        <member name="F:GameEvents.onKerbalAdded">
            <summary>
            Triggered when a new Kerbal is added in the astronaut complex scene;
            also triggered when a rescue Kerbal contract is generated
            </summary>
        </member>
        <member name="F:GameEvents.onKerbalRemoved">
            <summary>
            Triggered when a Kerbal is removed from the roster in the astronaut complex;
            also triggered when a rescue Kerbal contract is failed, expires, or declined
            </summary>
        </member>
        <member name="F:GameEvents.onKerbalStatusChange">
            <summary>
            Triggered when the ProtoCrewMember.RosterStatus changes;
            usually upon vessel recovery, new crew addition, or death;
            returns the ProtoCrewMember and its old and new status
            </summary>
        </member>
        <member name="F:GameEvents.onKerbalTypeChange">
            <summary>
            Triggered when the ProtoCrewMember.KerbalType changes;
            KerbalTypes are possibly not fully implemented;
            occurs upon hiring crew or rescuing Kerbal
            </summary>
        </member>
        <member name="F:GameEvents.onKnowledgeChanged">
            <summary>
            Triggered upon starting or stopping asteroid tracking, or when approaching an asteroid
            </summary>
        </member>
        <member name="F:GameEvents.onKrakensbaneDisengage">
            <summary>
            Triggered when a vessel's velocity falls below ~750m/s
            </summary>
        </member>
        <member name="F:GameEvents.onKrakensbaneEngage">
            <summary>
            Triggered when a vessel's velocity reaches ~750m/s
            </summary>
        </member>
        <member name="F:GameEvents.onLaunch">
            <summary>
            Triggered when launching by activating the first stage
            </summary>
        </member>
        <member name="F:GameEvents.onLevelWasLoaded">
            <summary>
            Triggered when a new scene is loaded; returns that GameScene;
            occurs after onGameSceneLoadRequested
            </summary>
        </member>
        <member name="F:GameEvents.onMissionFlagSelect">
            <summary>
            Triggered when selecting a new flag from in the editor;
            returns the flag texture's GameDatabse URL
            </summary>
        </member>
        <member name="F:GameEvents.onNewVesselCreated">
            <summary>
            Triggered when spawning a new asteroid or a new Kerbal for
            a rescue Kerbal contract
            </summary>
        </member>
        <member name="F:GameEvents.onOverheat">
            <summary>
            Triggered when a part overheats; returns an EventReport with the part name
            </summary>
        </member>
        <member name="F:GameEvents.onPartActionUICreate">
            <summary>
            Triggered when right-clicking a part; returns that part;
            triggered every time a part event is selected
            </summary>
        </member>
        <member name="F:GameEvents.onPartActionUIDismiss">
            <summary>
            Triggered when closing the right-click menu of a part
            </summary>
        </member>
        <member name="F:GameEvents.onPartAttach">
            <summary>
            Triggered when adding a part in the editor, when docking, and when another vessel comes into range and is loaded;
            returns the part and its new parent part
            </summary>
        </member>
        <member name="F:GameEvents.onPartCouple">
            <summary>
            Triggered when a docking port or asteroid grappling device attaches;
            returns the host part and the target part
            </summary>
        </member>
        <member name="F:GameEvents.onPartDestroyed">
            <summary>
            Triggered when a part object's OnDestroy method is called;
            occurs any time a part or vessel is unloaded,
            ie scene changes or vessel moving out of loading distance
            </summary>
        </member>
        <member name="F:GameEvents.onPartDie">
            <summary>
            Triggered when a part is destroyed, usually by exploding/crashing
            </summary>
        </member>
        <member name="F:GameEvents.onPartExplode">
            <summary>
            Triggered when a part explodes, usually due to crashing into the ground or into another part;
            also triggered by a part overheating and exploding
            </summary>
        </member>
        <member name="F:GameEvents.onPartJointBreak">
            <summary>
            Triggered when a part decouples, undocks, a grappling device undocks, a strut breaks,
            a part is destroyed, or when a part is removed in the editor
            </summary>
        </member>
        <member name="F:GameEvents.onPartPack">
            <summary>
            Triggered when a part goes on rails (enters timewarp) or exits loading distance
            </summary>
        </member>
        <member name="F:GameEvents.OnPartPurchased">
            <summary>
            Triggered when purchasing a part in the R&amp;D center;
            currently (KSP 0.24.2) called for all parts in a tech node when researching that node
            </summary>
        </member>
        <member name="F:GameEvents.onPartRemove">
            <summary>
            Triggered when removing a part in the editor
            </summary>
        </member>
        <member name="F:GameEvents.onPartUndock">
            <summary>
            Triggered upon undock event/action; not triggered by a docking node's decouple event;
            also triggered by asteroid grappling device's release event
            </summary>
        </member>
        <member name="F:GameEvents.onPartUnpack">
            <summary>
            Triggered when a part goes off rails (exits timewarp) or comes into loading distance
            </summary>
        </member>
        <member name="F:GameEvents.onPlanetariumTargetChanged">
            <summary>
            Triggered when the map view or tracking station camera focuses on a new object;
            this can be a Celestial Body or vessel;
            also triggered when switching to or loading a new vessel
            </summary>
        </member>
        <member name="F:GameEvents.OnProgressAchieved">
            <summary>
            Triggered when a ProgressNode and all of its subNodes are completed.
            
            See also OnProgressReached and OnProgressComplete
            </summary>
        </member>
        <member name="F:GameEvents.OnProgressComplete">
            <summary>
            Triggered when all sub ProgressNodes within a given ProgressNode are completed;
            records the UT of node completion and returns the ProgressNode
            
            See the ProgressTracking module in the persistent.sfs file for more on how ProgressNodes
            are setup and saved.
            
            If the ProgressNode is completed upon first achievement this will also trigger OnProgressReached.
            
            See also OnProgressReached and OnProgressAchieved
            </summary>
        </member>
        <member name="F:GameEvents.OnProgressReached">
            <summary>
            Triggered when a ProgressNode is first reached but not completed;
            records the UT of node achievement and returns the ProgressNode.
            
            For instance, when a vessels first enters the SOI of a new Celestial Body
            the event will trigger and a "reached" entry will be added to the persistent.sfs file.
            
            If a ProgressNode is completed at the same time it is reached (ie has no ProgressNode subNodes)
            OnProgressCompelete will be triggered at the same time
            
            See the ProgressTracking module in the persistent.sfs file for more on how ProgressNodes
            are setup and saved.
            
            See also OnProgressComplete and OnProgressAchieved
            </summary>
        </member>
        <member name="F:GameEvents.OnReputationChanged">
            <summary>
            When reputation level changes; returns total rep amount
            </summary>
        </member>
        <member name="F:GameEvents.onRotatingFrameTransition">
            <summary>
            Triggered when reference frame changes (ie from inertial to rotating);
            this is generally accompanied by a shift in the camera position
            and a debug log message ("Reference Frame: Rotating/Inertial")
            </summary>
        </member>
        <member name="F:GameEvents.onSameVesselDock">
            <summary>
            Triggered when two docking ports on the same vessel dock together
            </summary>
        </member>
        <member name="F:GameEvents.onSameVesselUndock">
            <summary>
            Triggered when two docking ports on the same vessel undock
            </summary>
        </member>
        <member name="F:GameEvents.OnScienceChanged">
            <summary>
            When science level changes; returns total science amount
            </summary>
        </member>
        <member name="F:GameEvents.OnScienceRecieved">
            <summary>
            Triggered science data is transmitted or recovered; returns the amount of science and the ScienceSubject
            </summary>
        </member>
        <member name="F:GameEvents.onShowUI">
            <summary>
            Called when the player un-hides the UI by pressing F2. Register for this callback (and onHideUI)
            so that you can un-hide your UI too.
            </summary>
        </member>
        <member name="F:GameEvents.onSplashDamage">
            <summary>
            Triggered when engine exhaust damages another part
            </summary>
        </member>
        <member name="F:GameEvents.onStageActivate">
            <summary>
            Triggered upon staging, returns the stage number
            </summary>
        </member>
        <member name="F:GameEvents.onStageSeparation">
            <summary>
            Triggered by decoupler staging;
            also triggered by separation through a decoupler's right-click menu event
            </summary>
        </member>
        <member name="F:GameEvents.OnTechnologyResearched">
            <summary>
            Triggered when researching a tech node in the R&amp;D center;
            triggers whether or not you have enough science to unlock the node
            </summary>
        </member>
        <member name="F:GameEvents.onTimeWarpRateChanged">
            <summary>
            Triggered whenever timewarp rate changes; applies to physics and non-physics timewarp;
            triggered by the key press also (called even if you are at max/min timewarp already)
            </summary>
        </member>
        <member name="F:GameEvents.onUndock">
            <summary>
            Deprecated? Use onPartUndock
            </summary>
        </member>
        <member name="F:GameEvents.onVesselChange">
            <summary>
            Triggered when switching to a different vessel, loading a vessel, or launching
            </summary>
        </member>
        <member name="F:GameEvents.onVesselCreate">
            <summary>
            Triggered when a vessel is launched, or created by undocking, decoupling, planting a flag, or EVA;
            also triggered by new asteroid creation and rescue Kerbal contracts
            </summary>
        </member>
        <member name="F:GameEvents.onVesselDestroy">
            <summary>
            Triggered when a vessel instance is destroyed;
            any time a vessel is unloaded, ie scene changes, exiting loading distance
            </summary>
        </member>
        <member name="F:GameEvents.onVesselGoOffRails">
            <summary>
            Triggered when a vessel is loaded on the launchpad, when a vessel enters within loading distance,
            or when a vessel goes off of time warp
            </summary>
        </member>
        <member name="F:GameEvents.onVesselGoOnRails">
            <summary>
            Triggered when a vessel exits loading distance or enters time warp
            </summary>
        </member>
        <member name="F:GameEvents.onVesselLoaded">
            <summary>
            Triggered whenever a vessel's load method is called
            </summary>
        </member>
        <member name="F:GameEvents.onVesselOrbitClosed">
            <summary>
            Triggered when a closed orbit is reached
            </summary>
        </member>
        <member name="F:GameEvents.onVesselOrbitEscaped">
            <summary>
            Triggered when orbit eccentricity becomes > 1
            </summary>
        </member>
        <member name="F:GameEvents.onVesselRecovered">
            <summary>
            Triggered after a vessel has been recovered and the science data
            and part values have been accounted for;
            occurs in the space center or tracking station.
            
            Triggered after onVesselRecoveryProcessing
            </summary>
        </member>
        <member name="F:GameEvents.onVesselRecoveryProcessing">
            <summary>
            Triggered in the space center or tracking station when a vessel is recovered;
            occurs before onVesselRecovered
            </summary>
        </member>
        <member name="F:GameEvents.OnVesselRecoveryRequested">
            <summary>
            Triggered a vessel is recovered (the big green button at the top) from the flight scene
            </summary>
        </member>
        <member name="F:GameEvents.onVesselRename">
            <summary>
            Returns old 'from' vessel name and new 'to' vessel name
            </summary>
        </member>
        <member name="F:GameEvents.OnVesselRollout">
            <summary>
            Triggered when vessel is loaded onto the launchpad from the editor/launch selection window;
            called after the transition to flight scene
            </summary>
        </member>
        <member name="F:GameEvents.onVesselSituationChange">
            <summary>
            Returns old and new vessel situations
            </summary>
        </member>
        <member name="F:GameEvents.onVesselSOIChanged">
            <summary>
            Returns old and new Celestial Body
            </summary>
        </member>
        <member name="F:GameEvents.onVesselTerminated">
            <summary>
            Triggered when a vessel is deleted from the tracking station
            </summary>
        </member>
        <member name="F:GameEvents.onVesselWasModified">
            <summary>
            Triggered when any aspect of a vessel changes;
            docking, undocking, decoupling, parts breaking, crash, etc...
            </summary>
        </member>
        <member name="F:GameEvents.onVesselWillDestroy">
            <summary>
            Triggered when a vessel crashes, or passes into the atmosphere;
            when an EVA Kerbal boards, or when an asteroid is despawned
            </summary>
        </member>
        <member name="T:GameEvents.Contract">
            <summary>
            Game events related to contract status changes;
            the contract in question is returned as EventData for most events
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onAccepted">
            <summary>
            Triggered when a contract is accepted through the mission control center
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onCancelled">
            <summary>
            Triggered upon cancellation of an active contract through the mission control center
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onCompleted">
            <summary>
            Triggered upon successful contract completion
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onContractsListChanged">
            <summary>
            Triggered when a new contract is offered, or a contract expires or completes
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onContractsLoaded">
            <summary>
            Triggered by the ContractSystem Scenario Module loading existing contracts
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onDeclined">
            <summary>
            Triggered by declining an offered contract from the mission control center
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onFailed">
            <summary>
            Triggered when a contract fails for any reason
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onFinished">
            <summary>
            Triggered when a contract finishes for any reason, success or failure
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onOffered">
            <summary>
            Triggered when the contract is first offered in the mission control center
            </summary>
        </member>
        <member name="F:GameEvents.Contract.onParameterChange">
            <summary>
            Triggered whenever an individual contract parameter changes state;
            from Incomplete to complete for example
            </summary>
        </member>
        <member name="T:GameEvents.VesselSituation">
            <summary>
            Game events related to vessel situation changes;
            mostly related to progress tracking.
            
            The Celestial Body in question and the vessel being
            used are returned as EventData in most cases
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onEscape">
            <summary>
            Triggered upon escaping a celestial body's orbit;
            triggered by onVesselSOIChanged, not by simply attaining an escape trajectory
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onFlyBy">
            <summary>
            Triggered upon entering a new celestial bodies SOI, the inverse of onEscape;
            may not apply to the Sun, ie requires eccentricity > 1
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onLand">
            <summary>
            Triggered upon landing or splashing down
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onOrbit">
            <summary>
            Triggered upon entering orbit;
            must be stable, with periapsis above the max atmospheric height and eccentricity &lt; 1
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onReachSpace">
            <summary>
            Triggered the first time a sub-orbital situation is achieved
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onReturnFromOrbit">
            <summary>
            Triggered when landing on Kerbin after a flyby or orbiting a Celestial Body
            </summary>
        </member>
        <member name="F:GameEvents.VesselSituation.onReturnFromSurface">
            <summary>
            Triggered when landing on Kerbin after landing on a Celestial Body
            </summary>
        </member>
        <member name="T:GameEvents.ExplosionReaction">
            <summary>
            Used by onPartExplode
            </summary>
        </member>
        <member name="F:GameEvents.ExplosionReaction.distance">
            <summary>
            The distance between the exploding part and the active vessel
            </summary>
        </member>
        <member name="F:GameEvents.ExplosionReaction.magnitude">
            <summary>
            Some explosion magnitude variable; related to fuel content of the exploding part
            </summary>
        </member>
        <member name="T:GameEvents.FromToAction`2">
            <summary>
            Two objects; of the same type in all stock uses.
            
            See onPartCouple for an example
            </summary>
            <typeparam name="A">The "originating" object</typeparam>
            <typeparam name="B">The "target" object</typeparam>
        </member>
        <member name="T:GameEvents.HostedFromToAction`2">
            <summary>
            Two potentially different object types;
            the From/To object (B) returns two values, generally the old and new.
            
            See onVesselSOIChanged for an example
            </summary>
            <typeparam name="A">Host object</typeparam>
            <typeparam name="B">From/To Object</typeparam>
        </member>
        <member name="T:GameEvents.HostTargetAction`2">
            <summary>
            Two objects of the same or different type;
            used generally in a manner similar to FromToAction.
            
            See OnTechnologyResearched for an example
            </summary>
            <typeparam name="A">Host object</typeparam>
            <typeparam name="B">Target object</typeparam>
        </member>
        <member name="T:GameEvents.VesselSpawnInfo">
            <summary>
            Used by onGUILaunchScreenSpawn
            
            Exposes information on saved .craft files
            </summary>
        </member>
        <member name="T:GamePersistence">
            <summary>
            Contains some functions you can call to save the game state to a persistence file, or load the game state from a persistence file.
            </summary>
        </member>
        <member name="M:GamePersistence.SaveGame(System.String,System.String,SaveMode)">
            <summary>
            Creates a persistence file containing the current game state. Probably persistent.sfs and quicksave.sfs are
            generated by calls to this function.
            </summary>
            <param name="saveFileName">The name of the persistence file to create (".sfs" will be appended to the file name).</param>
            <param name="saveFolder">The folder in which to create the save file. Try using HighLogic.SaveFolder.</param>
            <param name="saveMode">Whether to overwrite, append, or abort if the given file already exists.</param>
            <returns>Returns the filename on success. Returns an empty string when the file already exists and SaveMode.ABORT is used.</returns>
        </member>
        <member name="T:GameScenes">
            <summary>
            An enum corresponding to the different Unity scenes in KSP
            </summary>
        </member>
        <member name="T:HighLogic">
            <summary>
            This class stores some very high-level information about the current game state.
            </summary>
        </member>
        <member name="F:HighLogic.fetch">
            <summary>
            Use this instance to access non-static members of this class.
            </summary>
        </member>
        <member name="F:HighLogic.LoadedSceneIsEditor">
            <summary>
            Whether the game is currently in the VAB or SPH scenes.
            </summary>
        </member>
        <member name="F:HighLogic.LoadedSceneIsFlight">
            <summary>
            Whether the game is currently in the flight scene.
            </summary>
        </member>
        <member name="P:HighLogic.Skin">
            <summary>
            The GUISkin used by the game. Set GUI.skin = HighLogic.Skin at the start of your GUI function to use it yourself.
            </summary>
        </member>
        <member name="T:IDiscoverable">
             <summary>Methods allowing information for celestial bodies or ships to be hidden at game start</summary>
            
             <remarks>
             These methods appear to be used in the tracking station.
            
             Implemented by CelestialBody
             Implemented by Vessel
             </remarks>
        </member>
        <member name="M:IDiscoverable.RevealAltitude">
             <summary>Returns the object's altitude</summary>
             
             <returns>The height above the reference sphere of the Celestial Body in 
            	whose sphere of influence the object lies, in meters.</returns>
            
        </member>
        <member name="M:IDiscoverable.RevealMass">
             <summary>Returns the object's mass</summary>
            
             <remarks>Units are implementation-dependent.</remarks>
        </member>
        <member name="M:IDiscoverable.RevealName">
             <summary>Returns the object's tracking station name</summary>
            
             <returns>The string to display in the tracking station</returns>
             
        </member>
        <member name="M:IDiscoverable.RevealSituationString">
             <summary>Describes the state of the object</summary>
            
             <returns>A string containing the sphere of influence and trajectory of the object
             
             <example>"Orbiting the Sun"</example>
             </returns>
        </member>
        <member name="M:IDiscoverable.RevealSpeed">
             <summary>Returns the speed of the object</summary>
            
             <returns>The inertial speed relative to the Celestial Body in whose sphere of influence 
            	the object lies, in meters per second.</returns>
            
        </member>
        <member name="M:IDiscoverable.RevealType">
            <summary>Gives the type of object used</summary>
            
            <remarks>Meaning is implementation-dependent.</remarks>
        </member>
        <member name="P:IDiscoverable.DiscoveryInfo">
            <summary>Describes to what extent this object has been explored</summary>
        </member>
        <member name="T:InputLockManager">
            <summary>
            This class lets you lock the player out of certain controls. It's
            probably what KSP uses internally to lock controls during time warp,
            or when out of electric charge. 
            </summary>
            <remarks>
            You can view the current set of locks in-game with the Alt-F12 debug menu.
            </remarks>
        </member>
        <member name="F:InputLockManager.lockStack">
            <summary>
            The set of locks currently in place?
            </summary>
        </member>
        <member name="M:InputLockManager.RemoveControlLock(System.String)">
            <summary>
            Unlock a set of controls that were earlier locked with SetControlLock.
            </summary>
            <param name="lockID">The string ID passed to SetControlLock.</param>
        </member>
        <member name="M:InputLockManager.SetControlLock(ControlTypes,System.String)">
            <summary>
            Locks a set of controls.
            </summary>
            <param name="locks">Which controls to lock. You can OR several ControlTypes together to lock several types of controls at once.</param>
            <param name="lockID">A unique string ID that you will pass to RemoveControlLock to unlock these controls.</param>
            <returns>?</returns>
        </member>
        <member name="P:InputLockManager.LockMask">
            <summary>
            If <code>ControlTypes.X &amp; LockMask != 0</code> then ControlTypes.X is locked?
            </summary>
        </member>
        <member name="T:KSP.IO.IOException">
            <summary>
            A surrogate for System.IO.IOException.
            </summary>
        </member>
        <member name="T:KSP.IO.IOUtils">
            <summary>
            Has some useful little tools and utilities.
            </summary>
        </member>
        <member name="M:KSP.IO.IOUtils.DeserializeFromBinary(System.Byte[])">
            <summary>
            Deserialize a binary serialized object
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.IOUtils.GetFilePathFor(System.Type,System.String,Vessel)">
            <summary>
            Return the full path for a given filename, provided a class from the plugin. 
            <para>PluginData/[.flights/FLIGHT_UUID/]assemblyname/file</para>
            </summary>
            <param name="T"></param>
            <param name="file"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.IOUtils.SerializeToBinary(System.Object)">
            <summary>
            Serialize an object (same as using a BinaryFormatter).
            </summary>
            <param name="something"></param>
            <returns></returns>
        </member>
        <member name="T:IScienceDataContainer">
            <summary>
            Interface used by ModuleScienceExperiment and ModuleScienceContainer. Used for storing, transfering and transmitting Science Data.
            </summary>
        </member>
        <member name="M:IScienceDataContainer.DumpData(ScienceData)">
            <summary>
            Removes science data from the part, called after transmission or EVA data collection.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:IScienceDataContainer.GetData">
            <summary>
            Returns an array of all Science Data stored in the module.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IScienceDataContainer.GetScienceCount">
            <summary>
            Returns a count of Science Data reports stored in the module.
            </summary>
            <returns></returns>
        </member>
        <member name="M:IScienceDataContainer.IsRerunnable">
            <summary>
            Can the experiment be run more than once?
            </summary>
            <returns></returns>
        </member>
        <member name="M:IScienceDataContainer.ReviewData">
            <summary>
            Opens the experimental results dialog page, displays stored Science Data.
            </summary>
        </member>
        <member name="M:IScienceDataContainer.ReviewDataItem(ScienceData)">
            <summary>
            Opens the experimental results dialog page, displays stored Science Data.
            </summary>
            <param name="data"></param>
        </member>
        <member name="T:KerbalEVA">
            <summary>
            Kerbals on EVA are represented as vessels with a single part. That part contains a KerbalEVA PartModule.
            </summary>
        </member>
        <member name="T:PartModule">
            <summary>
            Extending PartModule lets you add new functionality to parts. The main class of many plugins
            will be a subclass of PartModule. See this forum thread for the official instructions on
            using PartModule:
            
            <para>http://forum.kerbalspaceprogram.com/showthread.php/10296-0-15-code-update-PartModule-KSPField-KSPEvent-ConfigNode-and-PartResource</para>
            </summary>
        </member>
        <member name="M:PartModule.GetInfo">
            <summary>
            The return value of this function appears in the part's description in the editor.
            </summary>
            <returns>Editor info for the part</returns>
        </member>
        <member name="M:PartModule.OnActive">
            <summary>
            This function is called once when the part gets activated.
            </summary>
        </member>
        <member name="M:PartModule.OnAwake">
            <summary>
            This function gets called only once, during the KSP loading screen. See the Unity documentation on Awake for more information.
            </summary>
        </member>
        <member name="M:PartModule.OnFixedUpdate">
            <summary>
            This function gets called once every Unity FixedUpdate cycle (once per physics frame) once the part has been activated. 
            If you want to be called even if the part has not been activated, define a function called <c>void FixedUpdate()</c> instead
            of overriding OnFixedUpdate
            </summary>
            <remarks>
            See the Unity documentation on FixedUpdate for more information. You can get the time between FixedUpdates from 
            TimeWarp.fixedDeltaTime. Do any physics stuff in OnFixedUpdate, not OnUpdate.
            </remarks>
        </member>
        <member name="M:PartModule.OnInactive">
            <summary>
            When does this get called?
            </summary>
        </member>
        <member name="M:PartModule.OnLoad(ConfigNode)">
            <summary>
            This function is called to initialize the part. The ConfigNode contains the parameters of the module
            as specified in the part.cfg file, or as you last saved them in OnSave. 
            </summary>
            <param name="node">A ConfigNode containing the module's parameters from part.cfg or persistent.sfs</param>
        </member>
        <member name="M:PartModule.OnSave(ConfigNode)">
            <summary>
            This function is called when the game is saved to let the part save persistent data. Add any data you want
            to persist to the ConfigNode. The ConfigNode will then be saved as part of persistent.sfs.
            When the game is resumed, you can then read this data back out in OnLoad.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:PartModule.OnStart(PartModule.StartState)">
            <summary>
            Called when the flight starts, or when the part is created in the editor. OnStart will be called
            before OnUpdate or OnFixedUpdate are ever called.
            </summary>
            <param name="state">Some information about what situation the vessel is starting in.</param>
        </member>
        <member name="M:PartModule.OnUpdate">
            <summary>
            Called once per Unity Update cycle once the part has been activated. 
            If you want to be called even if the part has not been activated, define a function called <c>void Update()</c> instead
            of overriding OnFixedUpdate.
            </summary>
            <remarks>
            See the
            Unity documentation on Update for more information. Poll for user input in OnUpdate, not OnFixedUpdate.
            </remarks>
        </member>
        <member name="P:PartModule.Actions">
            <summary>
            A list of KSPActions which can be added to action groups.
            </summary>
        </member>
        <member name="P:PartModule.ClassID">
            <summary>
            A hash of <c>ClassName</c>?
            </summary>
        </member>
        <member name="P:PartModule.ClassName">
            <summary>
            In any subclass of PartModule, <c>ClassName</c> will be the name of the subclass.
            It gets set by the PartModule loading process.
            </summary>
        </member>
        <member name="P:PartModule.Events">
            <summary>
            A list of KSPEvents, which can be triggered by code or by the user through the part's right-click menu.
            </summary>
        </member>
        <member name="P:PartModule.Fields">
            <summary>
            A list of the KSPFields which the module loads from the part.cfg file.
            </summary>
        </member>
        <member name="P:PartModule.part">
            <summary>
            The Part to which this PartModule is attached. Use this to reference the part from your module code.
            </summary>
        </member>
        <member name="P:PartModule.vessel">
            <summary>
            The Vessel of the Part to which this PartModule is attached.
            </summary>
        </member>
        <member name="T:PartModule.StartState">
            <summary>
            A StartState is passed on OnStart in order to provide the PartModule with some information
            about where it is starting up.
            </summary>
        </member>
        <member name="P:KerbalEVA.OnALadder">
            <summary>
            Whether the kerbal is currently hanging on to a ladder.
            </summary>
        </member>
        <member name="T:KerbalFSM">
            <summary>
            A finite state machine. States are represented by KFSMState objects, and 
            "events" (transitions between states) are represented by KFSMEvent objects.
            </summary>
        </member>
        <member name="F:KerbalFSM.currentStateName">
            <summary>
            The name of the state the machine is currently in.
            </summary>
        </member>
        <member name="F:KerbalFSM.lastEventName">
            <summary>
            The name of the last event that occurred.
            </summary>
        </member>
        <member name="M:KerbalFSM.AddEvent(KFSMEvent,KFSMState[])">
            <summary>
            Add a new event (possible transition) to the finite state machine.
            </summary>
            <param name="ev">The event to add.</param>
            <param name="toStates">The states to add the event to. The event can only be triggered when
            the machine is in one of these states.</param>
        </member>
        <member name="M:KerbalFSM.AddEventExcluding(KFSMEvent,KFSMState[])">
            <summary>
            Add a new event (possible transition) to the finite state machine.
            </summary>
            <param name="ev">The event to add.</param>
            <param name="excStates">A list of states *not* to add the event to. The event can only be triggered
            when the machine is *not* in one of these states.</param>
        </member>
        <member name="M:KerbalFSM.AddState(KFSMState)">
            <summary>
            Add a new possible state to the machine.
            </summary>
            <param name="st">The state to add.</param>
        </member>
        <member name="M:KerbalFSM.RunEvent(KFSMEvent)">
            <summary>
            Cause the machine to execute the transition specified by evt.
            </summary>
            <param name="evt">The event to execute.</param>
        </member>
        <member name="M:KerbalFSM.StartFSM(KFSMState)">
            <summary>
            Start the state machine in a given initial state.
            </summary>
            <param name="initialState">The state to start in.</param>
        </member>
        <member name="M:KerbalFSM.StartFSM(System.String)">
            <summary>
            Start the state machine in a given initial state.
            </summary>
            <param name="initialStateName">The name of the state to start in</param>
        </member>
        <member name="P:KerbalFSM.CurrentState">
            <summary>
            The state the machine is currently in.
            </summary>
        </member>
        <member name="P:KerbalFSM.FramesInCurrentState">
            <summary>
            How many frames the machine has been in this state.
            </summary>
        </member>
        <member name="P:KerbalFSM.LastEvent">
            <summary>
            The last event that occurred.
            </summary>
        </member>
        <member name="P:KerbalFSM.LastState">
            <summary>
            The state the machine was in before this state.
            </summary>
        </member>
        <member name="P:KerbalFSM.Started">
            <summary>
            Whether the state machine has been started.
            </summary>
        </member>
        <member name="P:KerbalFSM.TimeAtCurrentState">
            <summary>
            How long the machine has been in the current state, in seconds.
            </summary>
        </member>
        <member name="T:KerbalInstructor">
            <summary>
            A KerbalInstructor object controls the animated image of a kerbal instructor
            in a TutorialScenario. KerbalInstructors come with a stock emote animations
            that you can trigger by calling the appropriate functions.
            </summary>
        </member>
        <member name="M:KerbalInstructor.PlayEmote(CharacterAnimationState)">
            <summary>
            Presumably, makes the instructor execute a given animation.
            </summary>
            <param name="st">The animation to execute.</param>
        </member>
        <member name="M:KerbalInstructor.PlayEmoteRepeating(CharacterAnimationState,System.Single)">
            <summary>
            Presumably, makes the instructor execute a given animation repeatedly.
            </summary>
            <param name="st">The animation to exectue.</param>
            <param name="repeatInterval">How often to repeat the animation, in seconds?</param>
        </member>
        <member name="M:KerbalInstructor.StopRepeatingEmote">
            <summary>
            Presumably, makes the instructor stop repeating whatever animation
            you last told it to repeat.
            </summary>
        </member>
        <member name="T:KFSMEvent">
            <summary>
            A KFSMEvent represents a possible transition between two KFSMStates in a KerbalFSM
            finite state machine.
            </summary>
        </member>
        <member name="F:KFSMEvent.GoToStateOnEvent">
            <summary>
            Which state to transition to when this event is triggered.
            </summary>
        </member>
        <member name="F:KFSMEvent.name">
            <summary>
            The name of the event.
            </summary>
        </member>
        <member name="F:KFSMEvent.OnCheckCondition">
            <summary>
            You can assign to this field a delegate that takes a KFSMState (the current state)
            and returns a bool. The function will be called each frame and if it returns true,
            the event is triggered.
            </summary>
        </member>
        <member name="F:KFSMEvent.OnEvent">
            <summary>
            You can assign a delegate to this field, and the delegate will be run when the event is triggered.
            </summary>
        </member>
        <member name="F:KFSMEvent.updateMode">
            <summary>
            Specifies when OnCheckCondition should be checked?
            </summary>
        </member>
        <member name="M:KFSMEvent.#ctor(System.String)">
            <summary>
            Creates a new KFSMEvent
            </summary>
            <param name="name">The name of the event.</param>
        </member>
        <member name="M:KFSMEvent.IsValid(KFSMState)">
            <summary>
            Whether this event can be triggered when the state machine is in the given state.
            Events must be added to states through KerbalFSM.AddEvent before they can be triggered,
            and they can only be triggered when the machine is in one of the states to which they
            have been added.
            </summary>
            <param name="state">The state to check.</param>
            <returns>Whether the event can be triggered from the given state.</returns>
        </member>
        <member name="T:KFSMState">
            <summary>
            Represents a state in a KerbalFSM finite state machine.
            </summary>
        </member>
        <member name="F:KFSMState.name">
            <summary>
            The name of this state.
            </summary>
        </member>
        <member name="F:KFSMState.OnEnter">
            <summary>
            You can assign to this field a delegate that takes a KFSMState (which will be this state).
            The delegate will be called when the state machine enters this state.
            </summary>
        </member>
        <member name="F:KFSMState.OnFixedUpdate">
            <summary>
            You can assign a delegate to this field, and the delegate will be called during each FixedUpdate
            while the state machine is in this state.
            </summary>
        </member>
        <member name="F:KFSMState.OnLateUpdate">
            <summary>
            You can assign a delegate to this field, and the delegate will be called during each LateUpdate
            while the state machine is in this state.
            </summary>
        </member>
        <member name="F:KFSMState.OnLeave">
            <summary>
            You can assign to this field a delegate that takes a KFSMState. The delegate will be called
            when the state machine leaves this state, and the argument passed to the delegate will be
            the new state that the machine is transitioning to.
            </summary>
        </member>
        <member name="F:KFSMState.OnUpdate">
            <summary>
            You can assign a delegate to this field, and the delegate will be call during each Update while
            the state machine is in this state.
            </summary>
        </member>
        <member name="M:KFSMState.#ctor(System.String)">
            <summary>
            Create a new KFSMState with a given name.
            </summary>
            <param name="name">The name of the new state.</param>
        </member>
        <member name="M:KFSMState.AddEvent(KFSMEvent)">
            <summary>
            Add an event (possible transition) to this state.
            </summary>
            <param name="ev">The event to add.</param>
        </member>
        <member name="M:KFSMState.IsValid(KFSMEvent)">
            <summary>
            Whether the given event can be triggered from this state. An event must be added to a state before
            it can be triggered from that state.
            </summary>
            <param name="ev">The event to check.</param>
            <returns>Whether the event can be triggered from this state.</returns>
        </member>
        <member name="P:KFSMState.StateEvents">
            <summary>
            The set of events that are valid for this state (i.e., the possible transitions from this state).
            </summary>
        </member>
        <member name="T:Krakensbane">
            <summary>
            The physics simulation has problems if vessels move too fast relative to 
            the underlying reference frame used by the simulation, or get too far from
            the origin of the coordinate system. Krakensbane shifts the reference frame
            origin and velocity so that the active vessel is always near the origin of,
            and moving slowly with respect to, the underlying coordinate system used by the
            physics simulation.
            </summary>
        </member>
        <member name="M:Krakensbane.GetFrameVelocity">
            <summary>
            Returns the velocity of the Krakensbane velocity frame.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Krakensbane.GetFrameVelocityV3f">
            <summary>
            Returns the velocity of the Krakensbane velocity frame as a single-precision vector.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Krakensbane.GetLastCorrection">
            <summary>
            Returns the last velocity correction performed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Krakensbane.ResetVelocityFrame">
            <summary>
            sets the frame velocity back to 0m/s. Use this if setting the worldspace velocity of vessels directly.
            </summary>
        </member>
        <member name="M:Krakensbane.setOffset(Vector3d)">
            <summary>
            Moves all vessels not on rails by the given position offset. This will usually only affect the active vessel,
            unless there are other vessels nearby. The offset can be very large and the vessels
            will not break, unlike for Vessel.SetPosition.
            </summary>
            <param name="offset"></param>
        </member>
        <member name="T:KSPAction">
            <summary>
            Apply this attribute to a function to allow it to be called via action groups.
            </summary>
        </member>
        <member name="F:KSPAction.actionGroup">
            <summary>
            Which action groups this action is currently a part of? Probably you can test
            whether this action is part of a given action group (say, the Abort group) with
            
            <para><code>if((actionGroup &amp; KSPActionGroup.Abort) != 0)</code></para>
            </summary>
        </member>
        <member name="F:KSPAction.guiName">
            <summary>
            The name of this action as it appears in the action group editor.
            </summary>
        </member>
        <member name="T:KSPAddon">
            <summary>
            Apply this attribute to a class that derives from MonoBehaviour to have KSP automatically start up
            your addon at a specified time.
            </summary>
            <remarks>
            At the time specified by the "startup" argument KSP will create
            a new GameObject and attach your MonoBehaviour to it. You can then implement the Unity event functions
            like Start(), Update(), etc. 
            </remarks>
        </member>
        <member name="F:KSPAddon.once">
            <summary>
            Whether KSP should start up your addon just once per game session, or every time
            the startup time is reached. If you want your addon to persist forever, even through
            scene changes, after being started once, set once to true. call DontDestroyOnLoad(this) in your 
            Start() function.
            </summary>
        </member>
        <member name="F:KSPAddon.startup">
            <summary>
            When this addon should be started.
            </summary>
        </member>
        <member name="M:KSPAddon.#ctor(KSPAddon.Startup,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="startup">When this addon should be started</param>
            <param name="once">Whether KSP should start up your addon just once per game session, or every time
            the startup time is reached. If you want your addon to persist forever, even through
            scene changes, after being started once, set once to true. call DontDestroyOnLoad(this) in your 
            Start() function. </param>
        </member>
        <member name="T:KSPAddon.Startup">
            <summary>
            Possible values for when your addon can be started up.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.EditorAny">
            <summary>
            Presumably, start on entering either the VAB or the SPH.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.Instantly">
            <summary>
            Presumably, start soon as possible after loading your assembly?
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.EveryScene">
            <summary>
            Start up on any scene transition?
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.MainMenu">
            <summary>
            Start on entering the main KSP menu.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.Settings">
            <summary>
            Start on entering the KSP settings menu.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.Credits">
            <summary>
            Start on entering the KSP credits scene.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.SpaceCentre">
            <summary>
            Start on entering the space centre scene.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.EditorVAB">
            <summary>
            Start on entering the VAB scene.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.Flight">
            <summary>
            Start on entering the flight scene.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.TrackingStation">
            <summary>
            Start on entering the tracking station scene.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.EditorSPH">
            <summary>
            Start on entering the SPH scene.
            </summary>
        </member>
        <member name="F:KSPAddon.Startup.PSystemSpawn">
            <summary>
            Start just before KSP creates the solar system? This seems to be the right hook to
            use for addons that modify the solar system. See the PSystemManager class and related
            classes.
            </summary>
        </member>
        <member name="T:KSPAssembly">
             <summary>
             This attribute and the KSPAssemblyDependency attribute can be used to ensure that plugin assemblies are loaded in the right order.
             </summary>
             <remarks>
             Suppose Mod A depends on mod B, which is currently at version 2.6. 
             Mod B should add the following line to the end of Properties/AssemblyInfo.cs:
             
             <code>
             [assembly: KSPAssembly("ModBName", 2, 6)]
             </code>
            
             where "ModBName" is the name of Mod B (Mod B's .dll?). Replace 2 and 6 with the major and minor version of
             Mod B.
             
             Then Mod A should add the following line to the end of Properties/AssemblyInfo.cs:
             
             <code>
             [assembly: KSPAssemblyDependency("ModBName", 2, 6)]
             </code>
             
             This will tell KSP that Mod A depends on version 2.6 of Mod B, and ensure the the assemblies get loaded in
             the proper order.
             
             </remarks>
        </member>
        <member name="T:KSPAssemblyDependency">
             <summary>
             This attribute and the KSPAssembly attribute can be used to ensure that plugin assemblies are loaded in the right order.
             </summary>
             <remarks>
             Suppose Mod A depends on mod B, which is currently at version 2.6. 
             Mod B should add the following line to the end of Properties/AssemblyInfo.cs:
             
             <code>
             [assembly: KSPAssembly("ModBName", 2, 6)]
             </code>
            
             where "ModBName" is the name of Mod B (Mod B's .dll?). Replace 2 and 6 with the major and minor version of
             Mod B.
             
             Then Mod A should add the following line to the end of Properties/AssemblyInfo.cs:
             
             <code>
             [assembly: KSPAssemblyDependency("ModBName", 2, 6)]
             </code>
             
             This will tell KSP that Mod A depends on version 2.6 of Mod B, and ensure the the assemblies get loaded in
             the proper order.
             
             </remarks>
        </member>
        <member name="T:KSPEvent">
             <summary>
             Apply this attribute to a function in a PartModule to make it callable by the player via
             the right click menu of the part, or from other plugin code via Part.SendEvent.
             </summary>
            
             It seems like this attribute is NOT refreshed on parts already in flight when you rebuild 
             your module DLL! You need to launch a new ship with your part.
            
        </member>
        <member name="F:KSPEvent.active">
            <summary>
            Whether this event can be triggered through Part.SendEvent.
            </summary>
        </member>
        <member name="F:KSPEvent.externalToEVAOnly">
            <summary>
            Whether the event is only available when out on EVA.
            </summary>
        </member>
        <member name="F:KSPEvent.guiActive">
            <summary>
            Whether the event is shown as available in the right click menu (active must also be true).
            </summary>
        </member>
        <member name="F:KSPEvent.guiActiveUnfocused">
            <summary>
            Whether the event is shown as available in the right click menu even when
            the part is on a ship not currently being controlled by the player (but
            close enough to right click).
            </summary>
        </member>
        <member name="F:KSPEvent.guiName">
            <summary>
            The name shown for the event in the right click menu.
            </summary>
        </member>
        <member name="F:KSPEvent.name">
            <summary>
            The name of the event, which can be used to trigger the event using from plugin code using Part.SendEvent.
            </summary>
        </member>
        <member name="F:KSPEvent.unfocusedRange">
            <summary>
            When the part is on a ship not being controlled by the player,
            how close the player needs to be (in meters) in order for the event to appear in the right click menu.
            </summary>
        </member>
        <member name="T:KSPField">
            <summary>
            Apply this attribute to a field in a PartModule or ScenarioModule to make the field 
            get automatically initialized from the cfg file, and optionally persistent. See
            
            http://forum.kerbalspaceprogram.com/showthread.php/10296-0-15-code-update-PartModule-KSPField-KSPEvent-ConfigNode-and-PartResource
            </summary>
        </member>
        <member name="F:KSPField.guiActive">
            <summary>
            Whether to show the value of this field in the right click menu of the part.
            </summary>
        </member>
        <member name="F:KSPField.guiFormat">
            <summary>
            The format string that will be passed to ToString when displaying the value of your field
            in the right click menu of the part?
            E.g. "F3" for a floating point number with 3 digits past the decimal point.
            </summary>
        </member>
        <member name="F:KSPField.guiName">
            <summary>
            The name that will be shown for this field in the right click menu of the part.
            </summary>
        </member>
        <member name="F:KSPField.guiUnits">
            <summary>
            The units that will be shown for this field in the right click menu of the part.
            </summary>
        </member>
        <member name="F:KSPField.isPersistant">
            <summary>
            Whether to store the value of this field in persistent.sfs when the game state is saved, and
            reload it from persistent.sfs when the game state is loaded.
            </summary>
        </member>
        <member name="T:KSPScenario">
            <summary>
            Like KSPAddon, but for ScenarioModules. Apply this attribute to your subclass
            of ScenarioModule and KSP will add it to the game at the right time.
            </summary>
        </member>
        <member name="M:KSPScenario.#ctor(ScenarioCreationOptions,GameScenes[])">
            <summary>
            Constructor.
            </summary>
            <param name="createOptions">Directions about which games the scenario should be added to. Different options
            can be combined with the | operator.</param>
            <param name="tgtScenes">A list of the game scenes to which the scenario should be added</param>
        </member>
        <member name="T:ManeuverNode">
            <summary>
            Represents a maneuver node.
            </summary>
        </member>
        <member name="F:ManeuverNode.DeltaV">
            <summary>
            The delta-V of the burn represented by this maneuver node, in m/s. NOTE: maneuver nodes use a special coordinate system for delta-V.
            The x-component of DeltaV represents the delta-V in the radial-plus direction. The y-component of DeltaV 
            represents the delta-V in the normal-minus direction. The z-component of DeltaV represents the delta-V in the
            prograde direction.
            </summary>
        </member>
        <member name="F:ManeuverNode.nextPatch">
            <summary>
            The orbit patch that starts at this maneuver node.
            </summary>
        </member>
        <member name="F:ManeuverNode.patch">
            <summary>
            The orbit patch that ends at this maneuver node?
            </summary>
        </member>
        <member name="F:ManeuverNode.UT">
            <summary>
            The universal time of the burn represented by this maneuver node.
            </summary>
        </member>
        <member name="M:ManeuverNode.GetBurnVector(Orbit)">
            <summary>
            Perhaps this translates the DeltaV vector into a world-space vector?
            </summary>
            <param name="currentOrbit"></param>
            <returns></returns>
        </member>
        <member name="M:ManeuverNode.OnGizmoUpdated(Vector3d,System.Double)">
            <summary>
            You can call this function to change the delta-V and time of a maneuver node.
            </summary>
            <param name="dV">The new delta-V. See the DeltaV for notes about the coordinate system used.</param>
            <param name="ut">The new universal time.</param>
        </member>
        <member name="T:MapView">
            <summary>
            This class stores some global information related to the map view.
            </summary>
        </member>
        <member name="F:MapView.MapIsEnabled">
            <summary>
            Whether the game is currently in map view or not.
            </summary>
        </member>
        <member name="M:MapView.EnterMapView">
            <summary>
            Calling this function will cause the game to switch to map view from the flight view.
            </summary>
        </member>
        <member name="M:MapView.ExitMapView">
            <summary>
            Calling this function will cause the game to switch to flight view from the map view.
            </summary>
        </member>
        <member name="T:KSP.IO.MemoryStream">
            <summary>
            Useful for manipulating bytes in memory.
            </summary>
        </member>
        <member name="T:ModuleAsteroid">
             <summary>Key module in PART[PotatoRoid]</summary>
            
             <remarks> 
             Although this module is included in the PotatoRoid config file, it is not saved 
             in the VESSEL trees of unvisited asteroids. The module is initialized when an asteroid 
             first enters physics range
             </remarks>
        </member>
        <member name="F:ModuleAsteroid.density">
            <summary>Density of asteroid, in tons/m^3. Used to calculate part mass.</summary>
        </member>
        <member name="F:ModuleAsteroid.maxRadiusMultiplier">
            <summary>Largest allowed radius relative to nominal radius for that asteroid class</summary>
        </member>
        <member name="F:ModuleAsteroid.sampleExperimentXmitScalar">
            <summary>The fraction of science recovered by transmitting back to Kerbin.</summary>
        </member>
        <member name="F:ModuleAsteroid.sampleExperimentId">
            <summary>The science experiment triggered by sampling this asteroid.</summary>
        </member>
        <member name="F:ModuleAsteroid.minRadiusMultiplier">
            <summary>Smallest allowed radius relative to nominal radius for that asteroid class</summary>
        </member>
        <member name="F:ModuleAsteroid.AsteroidName">
            <summary>Stores the original name of the asteroid, before any ships docked with it</summary>
        </member>
        <member name="F:ModuleAsteroid.seed">
            <summary>Used to generate asteroid mesh</summary>
        </member>
        <member name="F:ModuleAsteroid.prefabBaseURL">
             <summary>Stores some kind of resource.</summary>
            
             <example>"Procedural/PA_C"</example>
        </member>
        <member name="M:ModuleAsteroid.GetVesselName">
             <summary>Returns asteroid name</summary>
            
             <returns>The original asteroid name, not that of any docked ships</returns>
            
             <remarks>Implements IVesselAutoRename</remarks>
        </member>
        <member name="M:ModuleAsteroid.GetVesselType">
             <summary>Returns the ship class</summary>
            
             <returns>Returns VesselType.SpaceObject</returns>
            
             <remarks>Implements IVesselAutoRename</remarks>
        </member>
        <member name="M:ModuleAsteroid.MakeTarget">
            <summary>Called when the player selects the asteroid's center of mass as their target</summary>
        </member>
        <member name="M:ModuleAsteroid.OnStart(PartModule.StartState)">
            <summary>Initializes the asteroid</summary>
        </member>
        <member name="M:ModuleAsteroid.RenameAsteroidEvent">
            <summary> Called when the player manually renames the asteroid</summary>
        </member>
        <member name="M:ModuleAsteroid.TakeSampleEVAEvent">
            <summary>Called when the player takes a surface sample</summary>
        </member>
        <member name="T:ModuleEngines">
            <summary>
            A PartModule that can be configured to behave like many different kinds of engines. All stock
            propulsion systems except for RCS are implemented through ModuleEngines.
            </summary>
        </member>
        <member name="F:ModuleEngines.atmosphereCurve">
            <summary>
            Represents the specific impulse (Isp) of the engine as a function of altitude. To get
            the Isp at a certain height h (in meters), use <code>atmosphereCurve.Evaluate(h)</code>.
            </summary>
        </member>
        <member name="F:ModuleEngines.currentThrottle">
            <summary>
            The current *internal* throttle of the engine, which may be different from the current
            throttle set by the player if <c>useEngineResponseTime</c> is true.
            </summary>
        </member>
        <member name="F:ModuleEngines.engineAccelerationSpeed">
            <summary>
            How quickly the engine spools up when the user-set throttle is higher than 
            <c>currentThrottle</c>. 
            </summary>
            <remarks>
            Each frame, if the user throttle is higher than
            the engine's <c>currentThrottle</c>, <c>currentThrottle</c>
            is updated according to the formula
            
            <code>currentThrottle += (user throttle - currentThrottle) * engineAccelerationSpeed * dt</code>
            
            <c>engineAccelerationSpeed</c> has units of inverse seconds.
            </remarks>
        </member>
        <member name="F:ModuleEngines.engineDecelerationSpeed">
            <summary>
            How quickly the engine spools down when the user-set throttle is higher than 
            <c>currentThrottle</c>. 
            </summary>
            <remarks>
            Each frame, if the user throttle is lower than
            the engine's <c>currentThrottle</c>, <c>currentThrottle</c>
            is updated according to the formula
            
            <code>currentThrottle += (user throttle - currentThrottle) * engineDecelerationSpeed * dt</code>
            
            <c>engineDecelerationSpeed</c> has units of inverse seconds.
            </remarks>
        </member>
        <member name="F:ModuleEngines.EngineIgnited">
            <summary>
            Whether the engine has ever been turned on?
            </summary>
        </member>
        <member name="F:ModuleEngines.exhaustDamage">
            <summary>
            Whether the engine's exhaust will damage parts that it hits. A ray is cast back
            along the engine's thrust vector and if that ray hits a part then that part gets heated
            up, and may explode if it exceeds its maximum temperature.
            </summary>
        </member>
        <member name="F:ModuleEngines.maxThrust">
            <summary>
            The thrust this engine produces at maximum throttle.
            </summary>
        </member>
        <member name="F:ModuleEngines.minThrust">
            <summary>
            The thrust this engine produces at minimum throttle.
            </summary>
        </member>
        <member name="F:ModuleEngines.propellants">
            <summary>
            <para>The resources used by this engine, and their relative ratios.</para>
            </summary>
        </member>
        <member name="F:ModuleEngines.realIsp">
            <summary>
            The current specific impulse of this engine, in seconds.
            </summary>
        </member>
        <member name="F:ModuleEngines.throttleLocked">
            <summary>
            Whether this engine always produces maximum thrust once activated (like solid rocket boosters).
            </summary>
        </member>
        <member name="F:ModuleEngines.thrustTransforms">
            <summary>
            These transforms store the locations and directions at which the thrust this engine generates is applied to the part.
            Which component of the transform rotation gives the thrust vector?
            </summary>
        </member>
        <member name="F:ModuleEngines.useEngineResponseTime">
            <summary>
            Whether the engine has a nonzero spool-up and spool-down time.
            </summary>
            <remarks>
            If <c>useEngineResponseTime</c> is true, then the engine does not
            spool up or down instantly when the throttle changes, but uses the
            <c>engineAccelerationSpeed</c> and <c>engineDecelerationSpeed</c>
            variables.
            </remarks>
        </member>
        <member name="F:ModuleEngines.useVelocityCurve">
            <summary>
            Whether this engine's thrust varies with airspeed?
            </summary>
        </member>
        <member name="F:ModuleEngines.velocityCurve">
            <summary>
            How this engine's thrust varies with airspeed?
            </summary>
        </member>
        <member name="P:ModuleEngines.getFlameoutState">
            <summary>
            If this is true, the engine is not producing thrust because it can't get enough resources.
            </summary>
        </member>
        <member name="T:ModuleEngines.Propellant">
            <summary>
            A class that represents the resource requirements of an engine.
            </summary>
        </member>
        <member name="F:ModuleEngines.Propellant.id">
            <summary>
            The integer ID of the resource consumed.
            </summary>
        </member>
        <member name="F:ModuleEngines.Propellant.name">
            <summary>
            The string name of the resource consumed, e.g. "LiquidFuel"
            </summary>
        </member>
        <member name="F:ModuleEngines.Propellant.ratio">
            <summary>
            How much of this resource is consumed by the engine, in proportion to other resources. For example if the
            engine consumes three resources (A, B, C) with A.ratio = 3, B.ratio = 2, C.ratio = 1, then 3 units of every
            will be consumed for every 2 units of B and 1 unit of C.
            </summary>
        </member>
        <member name="T:ModuleScienceExperiment">
            <summary>
            Part module for initiating and describing science experiments.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.collectActionName">
            <summary>
            Name for the right-click option to collect science data from the part while on EVA.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.collectWarningText">
            <summary>
            Text for warning pop-up while collecting science data from a non-repeatable experiment while on EVA.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.dataIsCollectable">
            <summary>
            Is EVA science data collection available?
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.experiment">
            <summary>
            The relevant experiment based on experimentID and info from ScienceDefs file.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.experimentActionName">
            <summary>
            Right-click and action group name for initiating experiment.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.experimentID">
            <summary>
            Must match applicable ID field in the ScienceDefs.cfg file.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.fxModuleIndices">
            <summary>
            Set to 1 to trigger animation in ModuleAnimateGeneric on activation.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.hideUIwhenUnavailable">
            <summary>
            Hide right-click experiment button when experiment cannot be performed.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.Inoperable">
            <summary>
            Can the experiment be performed? Only relevant for non-rerunnable experiments.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.interactionRange">
            <summary>
            EVA interaction range for data collection or experiment reset.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.rerunnable">
            <summary>
            Can the experiment be run more than once before requiring Science Lab reset?
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.resetActionName">
            <summary>
            Right-click, action group, and EVA button name to reset the experiment, science data will be lost.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.resettableOnEVA">
            <summary>
            Can the experiment be reset on EVA? Science data will be lost.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.resourceResetCost">
            <summary>
            Cost for cleaning the experiment at the science lab. Units * dataScale * baseValue?
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.resourceToReset">
            <summary>
            Resource to be used for cleaning the experiment at the science lab.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.reviewActionName">
            <summary>
            Right-click and action group name for reviewing collected science data.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.transmitWarningText">
            <summary>
            Warning displayed before transmitting data from a non-rerunnable experiment.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.useActionGroups">
            <summary>
            Allow action groups to be set for the experiment, rather than right-click buttons only.
            </summary>
        </member>
        <member name="F:ModuleScienceExperiment.xmitDataScalar">
            <summary>
            Percentage of data allowed to be transmitted, 1 equals the amount gained from returning the sample to Kerbin.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.CollectDataExternalEvent">
            <summary>
            Transfers data from the part to an EVA Kerbal.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.DeployAction(KSPActionParam)">
            <summary>
            Initiates the experiment from an action group.
            </summary>
            <param name="actParams"></param>
        </member>
        <member name="M:ModuleScienceExperiment.DeployExperiment">
            <summary>
            Initiates the experiment from a right-click button.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.DumpData(ScienceData)">
            <summary>
            Removes science data from the part, called after transmission. Implements IScienceDataContainer.
            </summary>
            <param name="data">The Science Data to be removed</param>
        </member>
        <member name="M:ModuleScienceExperiment.GetData">
            <summary>
            Returns all Science Data stored in the module. Implements IScienceDataContainer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ModuleScienceExperiment.GetScienceCount">
            <summary>
            A count of how many Science Data reports are stored in the module. Implements IScienceDataContainer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ModuleScienceExperiment.IsRerunnable">
            <summary>
            Is the experiment rerunnable? Refers to rerunnable field. Implements IScienceDataContainer.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ModuleScienceExperiment.OnLoad(ConfigNode)">
            <summary>
            Stores any Science Data in the persistent file.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:ModuleScienceExperiment.OnSave(ConfigNode)">
            <summary>
            Loads any Science Data stored in the persistent file.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:ModuleScienceExperiment.ResetAction(KSPActionParam)">
            <summary>
            Resets the experiment from an action group. Science Data is lost. Experiment can be re-run.
            </summary>
            <param name="actParams"></param>
        </member>
        <member name="M:ModuleScienceExperiment.ResetExperiment">
            <summary>
            Resets the experiment from a right-click button. Science Data is lost. Experiment can be re-run.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.ResetExperimentExternal">
            <summary>
            Resets the experiment from an EVA right-click button. Science Data is lost. Experiment can be re-run.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.ReviewData">
            <summary>
            Opens experimental results dialog. Implements IScienceDataContainer.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.ReviewDataEvent">
            <summary>
            Review stored Science Data from a right-click button.
            </summary>
        </member>
        <member name="M:ModuleScienceExperiment.ReviewDataItem(ScienceData)">
            <summary>
            Review individual Science Data reports? Implements IScienceDataContainer.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:ModuleScienceExperiment.SetInoperable">
            <summary>
            Sets the Inoperable bool, determines whether experiment can be performed again.
            </summary>
        </member>
        <member name="T:Orbit">
            <summary>
            <para>An Orbit class represents a Keplerian orbit. Each Vessel and each CelestialBody has an Orbit. CelestialBodies and
            on-rails Vessels follow their Orbits exactly. Off-rails vessels (the active vessel and any nearby vessels) 
            do not follow their orbits exactly; instead their motion is computed frame-by-frame from the forces acting on them.</para>
            <para>A patched consics trajectory consists of a series of Orbits, called patches.</para>
            <para>This class uses multiple axes and reference frames to describe
            positions and velocities.
            <para>We call the choices of axes
            <list type="bullet">
            <item>
            <description>World: world coordinates. Left-handed.</description>
            </item>
            <item>
            <description>AliceWorld: world coordinates with the y and z axes flipped. Right-handed.</description>
            </item>
            </list>
            </para>
            <para>We call the reference frames used
            <list type="bullet">
            <item>
            <description>BodyCentre[foo]: position and velocity relative to the centre of the CelestialBody |foo|.</description>
            </item>
            <item>
            <description>BodyRotating[foo]: position relative to the centre of the CelestialBody |foo|,
            velocity relative to its rotating surface.</description>
            </item>
            <item>
            <description>ConditionallyRotating[foo]: If |foo.inverseRotation|, BodyRotating[foo],
            otherwise BodyCentre[foo].</description>
            </item>
            <item>
            <description>Sun: BodyCentre[Planetarium.fetch.Sun].</description>
            </item>
            <item>
            <description>Primary: BodyCentre[this.referenceBody].</description>
            </item>
             <item>
            <description>ActiveVesselPrimary: If the active vessel is not null,
            BodyCentre[FlightGlobals.ActiveVessel.orbit.referenceBody], otherwise Sun.</description>
            </item>
            <item>
            <description>ActiveVesselPrimaryConditionallyRotating: If the active vessel is not null,
            ConditionallyRotating[FlightGlobals.ActiveVessel.orbit.referenceBody], otherwise Sun.</description>>
            </item>
            </list>
            </para>
            We use the concise notation {Axes, Frame}
            for describing the reference frame and axes used.</para>
            </summary>
        </member>
        <member name="F:Orbit.activePatch">
            <summary>
            Whether this patch actually represents a real orbit patch in the projected flight path. Often
            Orbit.nextPatch for the last real will not be null, but will be some sort of bogus Orbit object.
            You can recognize these because activePatch will be false.
            </summary>
        </member>
        <member name="F:Orbit.argumentOfPeriapsis">
            <summary>
            The angle between the ascending node and the periapsis, in degrees.
            </summary>
        </member>
        <member name="F:Orbit.eccentricAnomaly">
            <summary>
            A quantity used in the math describing Keplerian orbits; Google it.
            </summary>
        </member>
        <member name="F:Orbit.eccentricity">
            <summary>
            The eccentricity of the orbit.
            </summary>
        </member>
        <member name="F:Orbit.eccVec">
            <summary>
            A vector that points toward periapsis, with mangitude equal to the eccentricity.
            NOTE: All Vector3d's returned by Orbit class functions have their y and z axes flipped. You have
            to flip these back to get the vectors in world coordinates.
            </summary>
        </member>
        <member name="F:Orbit.EndUT">
            <summary>
            The universal time at which this patch ends.
            </summary>
        </member>
        <member name="F:Orbit.epoch">
            <summary>
            A special UT at which the parameters of the Orbit are defined. See meanAnomalyAtEpoch.
            </summary>
        </member>
        <member name="F:Orbit.h">
            <summary>
            The specific orbital angular momentum 
            </summary>
        </member>
        <member name="F:Orbit.inclination">
            <summary>
            The inclination of this orbit with respect to the equator of the central body in degrees
            </summary>
        </member>
        <member name="F:Orbit.LAN">
            <summary>
            The longitude of the ascending node of the orbit, in degrees. The LAN
            is the angle between the ascending node and Planetarium.right, as viewed along
            Planetarium.up.
            </summary>
        </member>
        <member name="F:Orbit.meanAnomaly">
            <summary>
            Mean anomaly is the fraction of the orbit that has been completed, measured starting
            from the periapsis, multiplied by 2. Look it up.
            </summary>
        </member>
        <member name="F:Orbit.meanAnomalyAtEpoch">
            <summary>
            The mean anomaly of the orbit at the special UT given by Orbit.epoch.
            </summary>
        </member>
        <member name="F:Orbit.ObT">
            <summary>
            Time since periapsis, in seconds.
            </summary>
        </member>
        <member name="F:Orbit.ObTAtEpoch">
            <summary>
            The value of ObT at the universal time given by epoch.
            </summary>
        </member>
        <member name="F:Orbit.orbitPercent">
            <summary>
            Equal to <code>>ObT / period</code>
            </summary>
        </member>
        <member name="F:Orbit.patchEndTransition">
            <summary>
            How the next patch follows onto this one, or FINAL if there is no patch after this one.
            </summary>
        </member>
        <member name="F:Orbit.period">
            <summary>
            The period of the orbit, in seconds.
            </summary>
        </member>
        <member name="F:Orbit.pos">
            <summary>
            The position of the orbiting object, {AliceWorld, Primary}.
            </summary>
        </member>
        <member name="F:Orbit.referenceBody">
            <summary>
            The body orbited.
            </summary>
        </member>
        <member name="F:Orbit.semiMajorAxis">
            <summary>
            The semi-major axis of the orbit, in meters. Equal to (PeR + ApR)/2
            </summary>
        </member>
        <member name="F:Orbit.timeToAp">
            <summary>
            The time until the object will reach apoapsis, in seconds.
            </summary>
        </member>
        <member name="F:Orbit.timeToPe">
            <summary>
            The time unti lthe object will reach periapsis, in seconds.
            </summary>
        </member>
        <member name="F:Orbit.vel">
            <summary>
            The velocity of the orbiting object, {AliceWorld, Primary}.
            </summary>
        </member>
        <member name="M:Orbit.GetFrameVel">
            <summary>
            The velocity of the orbiting object, {AliceWorld, Sun}.
            </summary>
        </member>
        <member name="M:Orbit.GetOrbitNormal">
            <summary>
            A unit vector normal to the plane of the orbit. NOTE: All Vector3d's returned by Orbit class functions have their y and z axes flipped. You have
            to flip these back to get the vectors in world coordinates.
            </summary>
            <returns>A unit normal vector.</returns>
        </member>
        <member name="M:Orbit.getRelativePositionAtT(System.Double)">
            <summary>
            Gets the predicted displacement of the orbiting object from the center of the main
            body at a given time since perigee passage. NOTE: All Vector3d's returned by Orbit class functions have their y and z axes flipped. You have
            to flip these back to get the vectors in world coordinates.
            </summary>
            <param name="T">Time since perigee passage (seconds)</param>
            <returns>Position relative to the main body (YZ flipped)</returns>
        </member>
        <member name="M:Orbit.getRelativePositionAtUT(System.Double)">
            <summary>
            Gets the predicted displacement of the orbiting object from the center of the main
            body at a given universal time. NOTE: All Vector3d's returned by Orbit class functions have their y and z axes flipped. You have
            to flip these back to get the vectors in world coordinates.
            </summary>
            <param name="UT">A univeral time.</param>
            <returns>Position relative to the main body (YZ flipped)</returns>
        </member>
        <member name="M:Orbit.GetRelativeVel">
            <summary>
            The velocity of the orbiting object, {World, Primary}.
            </summary>
        </member>
        <member name="M:Orbit.GetRotFrameVel(CelestialBody)">
            <summary>
            The velocity of a hypothetical object, located where the orbiting object
            is, and at rest in the ConditionallyRotating[refBody] frame,
            {AliceWorld, BodyCentre[refBody]}.
            In other words, velocity of the ConditionallyRotating[refBody] frame in the
            BodyCentre[refBody] frame at the position of the orbiting object (AliceWorld axes).
            Note: this only depends on the orbital position, not on the orbital velocity.
            </summary>
        </member>
        <member name="M:Orbit.GetVel">
            <summary>
            The velocity of the orbiting object, {World, ActiveVesselPrimary}.
            </summary>
        </member>
        <member name="M:Orbit.GetWorldSpaceVel">
            <summary>
            The velocity of the orbiting object, {World, ActiveVesselPrimaryConditionallyRotating}.
            </summary>
        </member>
        <member name="M:Orbit.RadiusAtTrueAnomaly(System.Double)">
            <summary>
            The distance the orbiting object will be from the center of the main body when it reaches the given true anomaly.
            </summary>
            <param name="tA">True anomaly (in degrees)</param>
            <returns>Distance from the main body's center, in meters</returns>
        </member>
        <member name="M:Orbit.TrueAnomalyAtRadius(System.Double)">
            <summary>
            The true anomaly at which the orbiting object will achieve the given distance from the center of the main body.
            </summary>
            <param name="R">Distance from the center of the main body, in meters.</param>
            <returns>True anomaly, in radians.</returns>
        </member>
        <member name="M:Orbit.UpdateFromStateVectors(Vector3d,Vector3d,CelestialBody,System.Double)">
            <summary>
            Updates this orbit to reflect the orbit that will be taken around the given body by an object with the
            given position and velocity at the given universal time.
            </summary>
            <param name="pos">The initial position of the object RELATIVE TO refBody at UT (YZ flipped)</param>
            <param name="vel">The initial velocity of the object (YZ flipped)</param>
            <param name="refBody">The main body</param>
            <param name="UT">The universal time at which to start the orbit.</param>
        </member>
        <member name="P:Orbit.ApA">
            <summary>
            The apoapsis of the orbit in meters, measured from sea level.
            </summary>
        </member>
        <member name="P:Orbit.ApR">
            <summary>
            The apoapsis of the orbit in meters, measured from the center of the main body.
            </summary>
        </member>
        <member name="P:Orbit.PeA">
            <summary>
            The periapsis of the orbit in meters, measured from sea level.
            </summary>
        </member>
        <member name="P:Orbit.PeR">
            <summary>
            The periapsis of the orbit in meters, measured from the center of the main body.
            </summary>
        </member>
        <member name="P:Orbit.semiLatusRectum">
            <summary>
            A property of ellipses, parabolas and hyperbolas; Google it.
            </summary>
        </member>
        <member name="P:Orbit.semiMinorAxis">
            <summary>
            A property of ellipses; Google it.
            </summary>
        </member>
        <member name="T:AttachModes">
            <summary>
            Describes the two possibilities for how a part can be attached to its parent.
            </summary>
        </member>
        <member name="F:AttachModes.STACK">
            <summary>
            The part is attached to its parent via a stack node; for example this is
            how vertically stacked fuel tanks are attached
            </summary>
        </member>
        <member name="F:AttachModes.SRF_ATTACH">
            <summary>
            This part is attached to the surface of its parent; for example this is how
            radial decouplers are attached.
            </summary>
        </member>
        <member name="T:PartResource">
            <summary>
            A PartResource object represents the store of a single type of resource within a Part.
            </summary>
        </member>
        <member name="F:PartResource.amount">
            <summary>
            How much of the resource is in this part, in whatever units the resource uses.
            </summary>
        </member>
        <member name="F:PartResource.info">
            <summary>
            The definition of this type of resource, which contains all information about this resource type.
            </summary>
        </member>
        <member name="F:PartResource.maxAmount">
            <summary>
            The maximum amount of this resource that this part can hold.
            </summary>
        </member>
        <member name="F:PartResource.part">
            <summary>
            The part whose stored resource this object represents
            </summary>
        </member>
        <member name="F:PartResource.resourceName">
            <summary>
            The name of this resource, as a string, e.g. "ElectricCharge"
            </summary>
        </member>
        <member name="T:PartResourceDefinition">
            <summary>
            A PartResourceDefinition contains the basic information defining a type of resource.
            </summary>
        </member>
        <member name="P:PartResourceDefinition.density">
            <summary>
            The mass of this resource, per unit. This is not necessarily per unit volume, as resources
            don't have defined volumes. Instead resource "density" is the mass of one units of the resourc.e
            </summary>
        </member>
        <member name="P:PartResourceDefinition.id">
            <summary>
            The integer ID of this resource type.
            </summary>
        </member>
        <member name="P:PartResourceDefinition.name">
            <summary>
            The string ID of this resource type
            </summary>
        </member>
        <member name="P:PartResourceDefinition.resourceFlowMode">
            <summary>
            How this resource does or does not flow between parts on a ship in response
            to resource requests by engines and the like.
            </summary>
        </member>
        <member name="P:PartResourceDefinition.resourceTransferMode">
            <summary>
            How this resource does or does not flow when using the resource transfer function?
            </summary>
        </member>
        <member name="T:PartResourceLibrary">
            <summary>
            The PartResourceLibrary lets you retrieve information about a resource type, given its name or integer id.
            </summary>
        </member>
        <member name="M:PartResourceLibrary.GetDefinition(System.Int32)">
            <summary>
            Gets information about a resource, specified by its integer ID.
            </summary>
            <param name="id">The integer ID of the resource</param>
            <returns>A PartResourceDefinition, which contains all the information about the resource</returns>
        </member>
        <member name="M:PartResourceLibrary.GetDefinition(System.String)">
            <summary>
            Gets information about a resource, specified by its name as a string.
            </summary>
            <param name="name">The name of the resource, e.g. "ElectricCharge"</param>
            <returns>A PartResourceDefinition, which contains all the information about the resource</returns>
        </member>
        <member name="P:PartResourceLibrary.Instance">
            <summary>
            Use this instance to access the methods of this class
            </summary>
        </member>
        <member name="T:PAsteroid">
             <summary>Stores information on an asteroid's shape</summary>
            
             <see cref="M:ProceduralAsteroid.Generate(System.Int32,System.Single,UnityEngine.Transform)"/> for a 
            	factory method creating PAsteroids
        </member>
        <member name="F:PAsteroid.highestPoint">
            <summary>The largest distance of any vertex to the mesh center</summary>
        </member>
        <member name="F:PAsteroid.volume">
            <summary>The (approximate?) volume of the asteroid mesh</summary>
        </member>
        <member name="M:PAsteroid.Setup(UnityEngine.Mesh,UnityEngine.Material,System.String,System.String,UnityEngine.Mesh,UnityEngine.PhysicMaterial,System.String,System.String,UnityEngine.Mesh,UnityEngine.PhysicMaterial,System.String,System.String)">
            <summary>Combines premade elements into visual, collider, and convex meshes.</summary>
        </member>
        <member name="T:PatchedConicSolver">
            <summary>
            Each vessel has a PatchedConicSolver, which stores the predicted patched conics trajectory and
            any maneuver nodes that currently exist.
            </summary>
        </member>
        <member name="F:PatchedConicSolver.maneuverNodes">
            <summary>
            A list of the maneuver nodes that are currently planned for this vessel.
            </summary>
        </member>
        <member name="M:PatchedConicSolver.AddManeuverNode(System.Double)">
            <summary>
            Add a maneuver node to the flight plan.
            </summary>
            <param name="UT">The universal time of the maneuver node.</param>
            <returns>A reference to the maneuver node</returns>
        </member>
        <member name="M:PatchedConicSolver.RemoveManeuverNode(ManeuverNode)">
            <summary>
            Remove a maneuver node from the flight plane.
            </summary>
            <param name="node">The maneuver node to be removed.</param>
        </member>
        <member name="T:Planetarium">
            <summary>
            Probably the most useful function here is Planetarium.GetUniversalTime().
            </summary>
        </member>
        <member name="F:Planetarium.CurrentMainBody">
            <summary>
            Presumably, the main body of the active vessel?
            </summary>
        </member>
        <member name="F:Planetarium.fetch">
            <summary>
            Use this instance to access non-static fields.
            </summary>
        </member>
        <member name="F:Planetarium.Sun">
            <summary>
            The CelestialBody representing the Sun.
            </summary>
        </member>
        <member name="M:Planetarium.FrameIsRotating">
            <summary>
            Presumably, whether the game is currently using a rotating
            frame for physics (as opposed to an unrotating inertial frame). 
            Below a certain altitude (CelestialBody.inverseRot
            </summary>
            <returns></returns>
        </member>
        <member name="M:Planetarium.GetUniversalTime">
            <summary>
            The simulation time, in seconds, since this save was started.
            </summary>
            <returns>Universal time, in seconds</returns>
        </member>
        <member name="P:Planetarium.forward">
            <summary>
            Along with "up" and "right," one of the three vectors defining the fixed celestial
            reference frame. 
            </summary>
        </member>
        <member name="P:Planetarium.right">
            <summary>
            Along with "up" and "forward," one of the three vectors defining the fixed celestial
            reference frame. The LAN (longitude of the ascending node) of every orbit is defined
            in reference to Planetarium.right. Specifically, the LAN is the angle between
            Planetarium.right and the orbit's ascending node, as viewed along Planetarium.up.
            </summary>
        </member>
        <member name="P:Planetarium.up">
            <summary>
            Along with "right" and "forward," one of the three vectors defining the fixed celestial
            reference frame. As of 0.23.5, all planet rotation axes are aligned with Planetarium.up.
            </summary>
        </member>
        <member name="T:PlanetariumCamera">
            <summary>
            A class related to the map view camera.
            </summary>
        </member>
        <member name="F:PlanetariumCamera.fetch">
            <summary>
            Use this instance to access non-static members of this class.
            </summary>
        </member>
        <member name="P:PlanetariumCamera.Camera">
            <summary>
            This is the Camera that looks at the planetarium scene. See the Unity documentation on Camera
            to see what you can do with this object.
            </summary>
        </member>
        <member name="T:KSP.IO.PluginConfigNode">
            <summary>
            A node full of configuration values.
            </summary>
        </member>
        <member name="M:KSP.IO.PluginConfigNode.GetParent">
            <summary>
            Gets the parent of this node.
            </summary>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.PluginConfigNode.GetValue``1(System.String)">
            <summary>
            Get the value of a configuration key.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.PluginConfigNode.GetValue``1(System.String,``0)">
            <summary>
            Get the value of a configuration key.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="_default"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.PluginConfigNode.SetValue(System.String,System.Object)">
            <summary>
            Set the value of a configuration key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:KSP.IO.PluginConfigNode.Item(System.String)">
            <summary>
            Get or set the value of a configuration key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:KSP.IO.PluginConfiguration">
            <summary>
            From N3X15: PluginConfiguration was something I threw together a while ago to try and improve settings serialization. The INI files we were using just couldn't cope with newlines and had all sorts of horrible workarounds. Instead of INI files, it writes structured XML files that look like this:
            
            <para><code>
            &lt;config&gt;
               &lt;int name="int"\&gt;4&lt;/int&gt;
               &lt;long name="long"&gt;45&lt;/long&gt;
               &lt;short name="short"&gt;4&lt;/short&gt;
               &lt;byte name="byte"&gt;255&lt;/byte&gt;
               &lt;bool name="bool"&gt;1&lt;/bool&gt;
               &lt;vector3 name="vector3"&gt;
                   &lt;x&gt;0&lt;/x&gt;
                   &lt;y&gt;1&lt;/y&gt;
                   &lt;z&gt;2&lt;/z&gt;
               &lt;/vector3&gt;
               &lt;vector3d name="vector3d"&gt;
                   &lt;x&gt;0&lt;/x&gt;
                   &lt;y&gt;1&lt;/y&gt;
                   &lt;z&gt;2.05&lt;/z&gt;
               &lt;/vector3d&gt;
               &lt;string name="string"&gt;string&lt;/string&gt;
             &lt;/config&gt;
             </code></para>
             
            <para>Despite looking a bit messy, it's actually a lot easier to use and doesn't have as many drawbacks as INI files. Newlines are preserved, and most importantly, types are also preserved. Oh, and it's UTF-8 encoded, so internationalization won't be as much as a problem, theoretically. Here's how to use it:</para>
            <para><code>
            PluginConfiguration cfg = PluginConfiguration.CreateForType&lt;MyCoolModule&gt;();
            cfg["a string"] = "I love KSP!";
            cfg["another setting"] = new Vector3d(0,1,2);
            cfg.save();
            // Later...
            cfg.load();
            settingAString = cfg.GetValue&lt;string&gt;("a string");
            settingAVector = cfg.GetValue&lt;Vector3d&gt;("another setting");
            </code></para>
            </summary>
        </member>
        <member name="M:KSP.IO.PluginConfiguration.CreateForType``1(Vessel)">
            <summary>
            Initialize the configuration object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.PluginConfiguration.GetValue``1(System.String)">
            <summary>
            Get a typed value from the root node.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.PluginConfiguration.GetValue``1(System.String,``0)">
            <summary>
            Get a typed value from the root node, and set to a default if it doesn't exist.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="_default"></param>
            <returns></returns>
        </member>
        <member name="M:KSP.IO.PluginConfiguration.load">
            <summary>
            Load from disk
            </summary>
        </member>
        <member name="M:KSP.IO.PluginConfiguration.save">
            <summary>
            Commit changes to disk
            </summary>
        </member>
        <member name="M:KSP.IO.PluginConfiguration.SetValue(System.String,System.Object)">
            <summary>
            Set a configuration key's value
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:KSP.IO.PluginConfiguration.Item(System.String)">
            <summary>
            Return configuration key from the root node
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:ProceduralAsteroid">
            <summary>Generates an asteroid shape</summary>
        </member>
        <member name="F:ProceduralAsteroid.radius">
            <summary>The desired reference surface of the asteroid mesh</summary>
        </member>
        <member name="M:ProceduralAsteroid.Generate(System.Int32,System.Single,UnityEngine.Transform)">
             <summary>Initializes a randomly generated asteroid shape</summary>
            
             <remarks>
             <param name='seed'>Used to randomize the mesh</param>
             <param name='radius'>The desired reference surface of the asteroid mesh</param>
             <param name='parent'>The reference frame in which the asteroid is to be oriented</param>
            
             Note: <paramref name="parent"/> may not be null, even though UnityEngine.Transforms 
            	are usually allowed to have null parents.
            
             <returns>An object containing all relevant meshes and key statistics</returns>
             </remarks>
        </member>
        <member name="F:ProceduralAsteroid.ModValue.minValue">
            <summary>Smallest mesh height that can be randomly chosen, in units of the asteroid radius</summary>
        </member>
        <member name="F:ProceduralAsteroid.ModValue.maxValue">
            <summary>Largest mesh height that can be randomly chosen, in units of the asteroid radius</summary>
        </member>
        <member name="F:ProceduralAsteroid.ModValue.radiusFactor">
            <summary>Size multiplier in addition to ProceduralAsteroid.radius</summary>
        </member>
        <member name="T:PSystemManager">
            <summary>
            A class for managing planetary systems. Ask the Kopernicus guys/look at their code for details.
            </summary>
        </member>
        <member name="T:ResourceFlowMode">
            <summary>
            An enumeration of the different behaviors resources can have with respect to fuel flow.
            </summary>
        </member>
        <member name="F:ResourceFlowMode.NO_FLOW">
            <summary>
            This resource cannot flow between parts (like SolidFuel).
            </summary>
        </member>
        <member name="F:ResourceFlowMode.ALL_VESSEL">
            <summary>
            The flow scheme used by the stock ElectricCharge and IntakeAir resources.
            </summary>
        </member>
        <member name="F:ResourceFlowMode.EVEN_FLOW">
            <summary>
            Unused?
            </summary>
        </member>
        <member name="F:ResourceFlowMode.STAGE_PRIORITY_FLOW">
            <summary>
            The flow scheme used by the stock MonoPropellant and XenonGas resources.
            Resource can be draw from any container by any consumer, but it tries to
            prioritize drawing from continers in earlier stages.
            </summary>
        </member>
        <member name="F:ResourceFlowMode.STACK_PRIORITY_SEARCH">
            <summary>
            This resource behaves like LiquidFuel or Oxidizer, and can only flow
            through crossfeed-enabled parts and fuel lines.
            </summary>
        </member>
        <member name="T:ScaledSpace">
            <summary>
            A class that handles the transformations between the scaled-down coordinate system used by the map view and the 
            regular coordinate system used by the main flight view and the physics.
            </summary>
        </member>
        <member name="M:ScaledSpace.LocalToScaledSpace(Vector3d)">
            <summary>
            Convert a position in world coordinates into a position in planetarium coordinates.
            </summary>
            <param name="localSpacePoint">A position in world coordinates</param>
            <returns>The corresponding position in planetarium coordinates</returns>
        </member>
        <member name="M:ScaledSpace.ScaledToLocalSpace(Vector3d)">
            <summary>
            Convert a position in planetarium coordinates into a position in world coordinates.
            </summary>
            <param name="scaledSpacePoint">A position in planetarium coordinates.</param>
            <returns>The corresponding position in world coordinates.</returns>
        </member>
        <member name="P:ScaledSpace.ScaleFactor">
            <summary>
            "Scaled space" is the coordinate system used by the planetarium view. It's the same coordinate system as
            the world coordinates used by the physics, except scaled down by this scale factor.
            </summary>
        </member>
        <member name="T:ScenarioCreationOptions">
            <summary>
            A list of options for use with the KSPScenario attribute.
            </summary>
        </member>
        <member name="T:ScenarioDiscoverableObjects">
             <summary>Stores information on asteroid spawning</summary>
            
             <remarks>
             Executed while in Flight, Tracking Station, and Space Center scenes
            
             The module schedules periodic "spawn checks" while the game clock is running, at an interval 
             set by spawnInterval. At each spawn check, any asteroids that have gone untracked for too long 
             are removed from the game.
             
             To add an element of randomness, only a fraction of checks (controlled by spawnOddsAgainst) 
             have a chance to produce asteroids. No asteroids are produced if the number of untracked 
             asteroids already in the game exceeds spawnGroupMaxLimit. Because spawn checks happen 
             very frequently, the number of detected asteroids in a game where the player never 
             tracks an asteroid will almost always be close to spawnGroupMaxLimit.
             
             The timing of spawn checks appears to be independent of the warp rate, but at high time warp 
             multiple asteroids may be spawned per check. (Needs confirmation)
             </remarks>
        </member>
        <member name="F:ScenarioDiscoverableObjects.spawnGroupMinLimit">
            <summary>Number of untracked asteroids at which spawn rate begins to slow</summary>
        </member>
        <member name="F:ScenarioDiscoverableObjects.spawnGroupMaxLimit">
            <summary>Number of untracked asteroids at which spawn rate stops completely</summary>
        </member>
        <member name="F:ScenarioDiscoverableObjects.sizeCurve">
             <summary>Sets size distribution for asteroids</summary>
             <remarks>
             The output range of [0, 1) is divided equally among the classes. So [0, 0.2) is class A, 
             [0.2, 0.4) is class B, ..., [0.8, 1) is class E.
            
             Default curve translates to 
            	12% class A, 13% class B, 49% class C, 13% class D, and 12% class E
             </remarks>
            
        </member>
        <member name="F:ScenarioDiscoverableObjects.spawnOddsAgainst">
            <summary>Controls the fraction of spawn checks in which new asteroids are generated</summary>
            <remarks>
            The probability of spawning an asteroid is 1 / (1 + spawnOddsAgainst)
            </remarks>
        </member>
        <member name="F:ScenarioDiscoverableObjects.spawnInterval">
             <summary>Number of seconds between asteroid checks</summary>
            
             <remarks>
             These are seconds of time spent playing KSP, regardless of the time warp rate. The faster 
            	your time warp, the longer the in-game interval between asteroid detections.
            
             Since asteroids are removed during spawn checks, spawnInterval also controls the 
             	asteroid removal rate.
             </remarks>
        </member>
        <member name="F:ScenarioDiscoverableObjects.maxUntrackedLifetime">
            <summary>Longest time an asteroid can go untracked before disappearing, in Earth days</summary>
            <seealso cref="P:DiscoveryInfo.unobservedLifetime"/>
        </member>
        <member name="F:ScenarioDiscoverableObjects.minUntrackedLifetime">
            <summary>Shortest time an asteroid can go untracked before disappearing, in Earth days</summary>
            <seealso cref="P:DiscoveryInfo.unobservedLifetime"/>
        </member>
        <member name="M:ScenarioDiscoverableObjects.debugSpawnProbability">
             <summary>Returns a description of the current spawn interval and spawn odds</summary>
            
             <seealso cref="F:ScenarioDiscoverableObjects.spawnOddsAgainst"/>
             <seealso cref="F:ScenarioDiscoverableObjects.spawnInterval"/>
        </member>
        <member name="M:ScenarioDiscoverableObjects.SpawnAsteroid">
            <summary>Creates a random asteroid and Kerbin-intercepting orbit</summary>
        </member>
        <member name="M:ScenarioDiscoverableObjects.SpawnLastAsteroid">
             <summary>Creates a random asteroid and Kerbin-intercepting orbit.</summary>
            
             <remarks>
             <seealso cref="M:ScenarioDiscoverableObjects.SpawnAsteroid">Asteroid is identical to the last 
            	call of SpawnAsteroid()</seealso>
            
             Intended for debugging?
             </remarks>
        </member>
        <member name="T:ScienceData">
            <summary>
            Class containing information on science reports, stored in the persistent file in modules using IScienceDataContainer.
            </summary>
        </member>
        <member name="F:ScienceData.dataAmount">
            <summary>
            Amount of data, in mits, to be transmitted or recovered. Affects transmission time and energy usage.
            </summary>
        </member>
        <member name="F:ScienceData.labBoost">
            <summary>
            Level of science lab boost, less than 1 is un-boosted, 1.5 is the standard lab boosted value, higher levels don't appear to be used.
            </summary>
        </member>
        <member name="F:ScienceData.subjectID">
            <summary>
            ID of science data in Experimentname@CelestialbodynameExperimentalsituationBiome format, matches Science Subject id.
            </summary>
        </member>
        <member name="F:ScienceData.title">
            <summary>
            Science data title, displayed on experimental results dialog page and recovery summary.
            </summary>
        </member>
        <member name="F:ScienceData.transmitValue">
            <summary>
            Percentage of science value that can be transmitted. 1 is equal to the amount gained by returning to Kerbin.
            </summary>
        </member>
        <member name="M:ScienceData.#ctor(System.Single,System.Single,System.Single,System.String,System.String)">
            <summary>
            Generate Science Data based on Science Subject values.
            </summary>
            <param name="amount">Amount of data, it mits.</param>
            <param name="xmitValue">Transmission value</param>
            <param name="labBoost">Current state of science lab boost</param>
            <param name="id">Matches Science Subject ID</param>
            <param name="dataName">Title of science data</param>
        </member>
        <member name="T:ScienceExperiment">
            <summary>
            Class containing information from the experiment stored in the ScienceDefs file.
            </summary>
        </member>
        <member name="F:ScienceExperiment.baseValue">
            <summary>
            Base science value from ScienceDefs file.
            </summary>
        </member>
        <member name="F:ScienceExperiment.biomeMask">
            <summary>
            Bitmask to determine when biomes are relevant.
            </summary>
        </member>
        <member name="F:ScienceExperiment.dataScale">
            <summary>
            Multiplier to increase data amount in mits.
            </summary>
        </member>
        <member name="F:ScienceExperiment.experimentTitle">
            <summary>
            Title to be displayed for experimental results dialog and science archives.
            </summary>
        </member>
        <member name="F:ScienceExperiment.id">
            <summary>
            Matches ID from ModuleScienceExperiment field.
            </summary>
        </member>
        <member name="F:ScienceExperiment.requireAtmosphere">
            <summary>
            Can the experiment only be performed on planets with an atmosphere?
            </summary>
        </member>
        <member name="F:ScienceExperiment.scienceCap">
            <summary>
            Maximum science value available for each experimental result.
            </summary>
        </member>
        <member name="F:ScienceExperiment.situationMask">
            <summary>
            Bitmask to determine which Experiment Situations the experiment can be performed in.
            </summary>
        </member>
        <member name="M:ScienceExperiment.BiomeIsRelevantWhile(ExperimentSituations)">
            <summary>
            Checks if the biome is relevent to the experiment given the biomeMask specified in the ScienceDefs file.
            </summary>
            <param name="situation">Current Experiment Situation</param>
            <returns></returns>
        </member>
        <member name="M:ScienceExperiment.IsAvailableWhile(ExperimentSituations,CelestialBody)">
            <summary>
            Determines if the experiment is available given the situationMask and requireAtmosphere values specified in the ScienceDefs file.
            </summary>
            <param name="situation">Current Experiment Situation</param>
            <param name="body">Current Celestial Body</param>
            <returns></returns>
        </member>
        <member name="T:ScienceSubject">
            <summary>
            Class containing information on a specific science result, data stored in the persistent file under the R&amp;D node.
            </summary>
        </member>
        <member name="F:ScienceSubject.dataScale">
            <summary>
            Multiply science value by this dataScale value to determine data amount in mits.
            </summary>
        </member>
        <member name="F:ScienceSubject.id">
            <summary>
            Subject ID in Experimentname@CelestialbodyExperimentalsituationBiome format
            </summary>
        </member>
        <member name="F:ScienceSubject.science">
            <summary>
            Amount of science already earned from this subject, not updated until after transmission/recovery.
            </summary>
        </member>
        <member name="F:ScienceSubject.scienceCap">
            <summary>
            Total science allowable for this subject, based on subjectValue.
            </summary>
        </member>
        <member name="F:ScienceSubject.scientificValue">
            <summary>
            Diminishing value multiplier for decreasing the science value returned from repeated experiments.
            </summary>
        </member>
        <member name="F:ScienceSubject.subjectValue">
            <summary>
            Multiplier for specific Celestial Body/Experiment Situation combination.
            </summary>
        </member>
        <member name="F:ScienceSubject.title">
            <summary>
            Title of science subject, displayed in science archives.
            </summary>
        </member>
        <member name="M:ScienceSubject.#ctor(ConfigNode)">
            <summary>
            Return a Science Subject from Research and Development node in the persistent file.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:ScienceSubject.#ctor(ScienceExperiment,ExperimentSituations,CelestialBody,System.String)">
            <summary>
            Generate new Science Subject.
            </summary>
            <param name="exp">Science Experiment from ScienceDefs file and ModuleScienceExperiment</param>
            <param name="sit">Current experimantal situation, based on VesselSituation</param>
            <param name="body">Current Celestial Body</param>
            <param name="biome">Current biome if applicable, empty string if not</param>
        </member>
        <member name="T:ScreenMessage">
            <summary>
            A class representing temporary messages posted to the screen. Don't use this class, use the static methods in ScreenMessages instead.
            </summary>
        </member>
        <member name="T:ScreenMessages">
            <summary>
            A class that lets you post temporary messages to the screen. If you use this class your messages will
            automatically have the same style as regular in-game messages.
            </summary>
        </member>
        <member name="F:ScreenMessages.activeMessages">
            <summary>
            The set of currently active screen messages. This is a non-static member, but you can get a
            reference to the ScreenMessages instance via
            <code>ScreenMessages sm = (ScreenMessages)GameObject.FindObjectOfType(typeof(ScreenMessages));</code>
            </summary>
        </member>
        <member name="M:ScreenMessages.PostScreenMessage(ScreenMessage)">
            <summary>
            Post a temporary message to the screen. Examples of screen messages are the "Warp = {number}x" message
            and the "Quicksaving..." message.
            </summary>
            <param name="msg">The message to post</param>
        </member>
        <member name="M:ScreenMessages.PostScreenMessage(System.String)">
            <summary>
            Post a temporary message to the screen. Examples of screen messages are the "Warp = {number}x" message
            and the "Quicksaving..." message.
            </summary>
            <param name="message">The message to post.</param>
            <returns>A reference to the posted message</returns>
        </member>
        <member name="M:ScreenMessages.PostScreenMessage(System.String,System.Single)">
            <summary>
            Post a temporary message to the screen. Examples of screen messages are the "Warp = {number}x" message
            and the "Quicksaving..." message.
            </summary>
            <param name="message">The message to post</param>
            <param name="duration">How long the message should remain on the screen, in seconds.</param>
            <returns>A reference to the posted message</returns>
        </member>
        <member name="M:ScreenMessages.PostScreenMessage(System.String,System.Single,ScreenMessageStyle)">
            <summary>
            Post a temporary message to the screen. Examples of screen messages are the "Warp = {number}x" message
            and the "Quicksaving..." message.
            </summary>
            <param name="message">The message to post</param>
            <param name="duration">How long the message should remain on the screen, in seconds.</param>
            <param name="style">Which style of screen message to post--for instance, should it by like the warp message, the quicksaving message, etc.</param>
            <returns>A reference to the posted message</returns>
        </member>
        <member name="M:ScreenMessages.RemoveMessage(ScreenMessage)">
            <summary>
            Remove a currently active message from the screen.
            </summary>
            <param name="msg">The message to remove</param>
        </member>
        <member name="T:ScreenMessageStyle">
            <summary>
            An enumeration of the different styles of message you can display.
            </summary>
        </member>
        <member name="F:ScreenMessageStyle.UPPER_CENTER">
            <summary>
            This results in a message in the same font and position as the "Warp = {number}x" message.
            </summary>
        </member>
        <member name="F:ScreenMessageStyle.UPPER_LEFT">
            <summary>
            What sort of message style does this produce?
            </summary>
        </member>
        <member name="F:ScreenMessageStyle.UPPER_RIGHT">
            <summary>
            This results in a message in the same font and position as the "Quicksaving..." message.
            </summary>
        </member>
        <member name="F:ScreenMessageStyle.LOWER_CENTER">
            <summary>
            What sort of message style does this produce?
            </summary>
        </member>
        <member name="T:KSP.IO.SeekOrigin">
            <summary>
            This enum is a replacement for its System.IO equivalent. It's used to determine from where one wishes to seek in a file stream.
            </summary>
        </member>
        <member name="F:KSP.IO.SeekOrigin.Begin">
            <summary>
            Seek from the beginning of the stream.
            </summary>
        </member>
        <member name="F:KSP.IO.SeekOrigin.Current">
            <summary>
            Seek from the current position in the stream.
            </summary>
        </member>
        <member name="F:KSP.IO.SeekOrigin.End">
            <summary>
            Seek from the end of the stream.
            </summary>
        </member>
        <member name="F:ShipConstruct.parts">
            <summary>
            A list of all the parts in the ShipConstruct.
            The parts are listed in the same order in which they were added to the ship in the editor.
            </summary>
        </member>
        <member name="T:KSP.IO.TextReader">
            <summary>
            Identical to System.IO.TextReader, but with added IDisposable methods (for use in using() statements), and a factory method instead of constructors.
            </summary>
        </member>
        <member name="M:KSP.IO.TextReader.CreateForType``1(System.String,Vessel)">
            <summary>
            Create a text reader stream.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="T:KSP.IO.TextWriter">
            <summary>
            Identical to System.IO.TextWriter, but with added IDisposable methods (for use in using() statements), and a factory method instead of constructors.
            </summary>
        </member>
        <member name="M:KSP.IO.TextWriter.CreateForType``1(System.String,Vessel)">
            <summary>
            Create a text writing stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <param name="flight"></param>
            <returns></returns>
        </member>
        <member name="T:TimeWarp">
            <summary>
            The class that handles time warp.
            </summary>
        </member>
        <member name="F:TimeWarp.altitudeLimits">
            <summary>
            Unused? CelestialBodies have their own sets of altitude limits.
            </summary>
        </member>
        <member name="F:TimeWarp.fetch">
            <summary>
            Use this TimeWarp instance to access non-static members. 
            </summary>
        </member>
        <member name="F:TimeWarp.physicsWarpRates">
            <summary>
            The available physics warp rates. In 0.18.2 these are {1, 2, 3, 4} by default. You can modify the
            available rates by modifying this array.
            </summary>
        </member>
        <member name="F:TimeWarp.warpRates">
            <summary>
            The available regular warp rates. In 0.18.2 these are {1, 5, 10, 50, 100, 1000, 10000, 100000} by default.
            You can modify the available rates by modifying this array.
            </summary>
        </member>
        <member name="M:TimeWarp.GetAltitudeLimit(System.Int32,CelestialBody)">
            <summary>
            Presumably, gets the minimum altitude in meters above the sea level of the given body at which the
            given warp rate index is allowed.
            </summary>
            <param name="i">A warp rate index</param>
            <param name="body">The body in question</param>
            <returns>The minimum altitude in meters at which that warp rate index is allowed</returns>
        </member>
        <member name="M:TimeWarp.SetRate(System.Int32,System.Boolean)">
            <summary>
            Changes the warp rate to either warpRates[rateIndex] or physicsWarpRates[rate_index], depending
            on whether WarpMode is HIGH or LOW.
            </summary>
            <param name="rate_index">The index of the desired new warp rate</param>
            <param name="instant">If false, KSP will gradually smoothly adjust the warp rate up or down until it reaches the target.
            If true, the warp rate will change instantly.</param>
        </member>
        <member name="P:TimeWarp.CurrentRate">
            <summary>
            The current warp rate, e.g. 50 if the current warp rate is 50x. This number
            may not be equal to one of the entries in warpRates, because KSP will smoothly
            interpolate between two warp rates over a period of time when you increase
            or decrease the warp.
            </summary>
        </member>
        <member name="P:TimeWarp.CurrentRateIndex">
            <summary>
            The index of the current current warp rate in either warpRates or physicsWarpRates, depending
            on whether WarpMode is HIGH or LOW. Note that CurrentRate may not equal the warp rate indexed
            by CurrentRateIndex if KSP has not finished interpolating the last warp change.
            </summary>
        </member>
        <member name="P:TimeWarp.fixedDeltaTime">
            <summary>
            The time between FixedUpdate cycles (i.e., the time between physics steps). See the Unity FixedUpdate
            documentation for more details.
            </summary>
        </member>
        <member name="P:TimeWarp.WarpMode">
            <summary>
            Whether we are in regular warp mode or physics warp mode
            </summary>
        </member>
        <member name="F:TimeWarp.Modes.HIGH">
            <summary>
            Reguar time warp mode
            </summary>
        </member>
        <member name="F:TimeWarp.Modes.LOW">
            <summary>
            Physics warp mode
            </summary>
        </member>
        <member name="T:TutorialScenario">
            <summary>
            A TutorialScenario is a ScenarioModule with some added features that
            are useful for building tutorials or similar kinds of scenarios. A TutorialScenario
            comes with a builtin in finite state machine for running the scenario and
            displays "tutorial pages" in a GUI window alongside a picture of a friendly Kerbal instructor.
            You can take advantage of all these features by making your ScenarioModule a subclass of
            TutorialScenario.
            
            See HarvesteR's example code in his forum article: 
            
            http://forum.kerbalspaceprogram.com/content.php/121-Writing-Tutorials-A-Demo-%28and-some-source-code%29
            </summary>
        </member>
        <member name="F:TutorialScenario.instructor">
            <summary>
            Controls the animated image of the kerbal instructor. This object lets you make the instructor run
            various animations .
            </summary>
        </member>
        <member name="F:TutorialScenario.instructorPrefabName">
            <summary>
            Set this string in OnAssetSetup to specify which instructor kerbal will appear
            in the tutorial window. The value "Instructor_Gene" gives Gene Kerman as the
            instructor. The default if you do not specify anything is Werner von Kerman.
            </summary>
        </member>
        <member name="F:TutorialScenario.Tutorial">
            <summary>
            The finite state machine that controls the progression of the tutorial.
            </summary>
        </member>
        <member name="M:TutorialScenario.OnAssetSetup">
            <summary>
            Override this function to run some initialization code?
            </summary>
        </member>
        <member name="M:TutorialScenario.OnTutorialSetup">
            <summary>
            Override this function to run some code as the tutorial
            is being set up.
            </summary>
        </member>
        <member name="M:TutorialScenario.SetDialogRect(UnityEngine.Rect)">
            <summary>
            Sets the location of the GUI window of the tutorial.
            </summary>
            <param name="r"></param>
        </member>
        <member name="T:TutorialScenario.TutorialFSM">
            <summary>
            The TutorialFSM provides a convient interface for implementing the meat of
            your scenario logic through a finite state machine. The states of the state
            machine are "pages." 
            </summary>
        </member>
        <member name="F:TutorialScenario.TutorialFSM.lastPage">
            <summary>
            The page that the tutorial was on before this one.
            </summary>
        </member>
        <member name="F:TutorialScenario.TutorialFSM.pages">
            <summary>
            The list of all pages in the tutorial.
            </summary>
        </member>
        <member name="M:TutorialScenario.TutorialFSM.AddPage(TutorialScenario.TutorialPage)">
            <summary>
            Add a page (a new possible state) to the tutorial.
            </summary>
            <param name="st">The page to add.</param>
        </member>
        <member name="M:TutorialScenario.TutorialFSM.AddState(TutorialScenario.TutorialPage)">
            <summary>
            Add a page (a new possible state) to the tutorial, but outside
            the default page sequence that will be used by GoToLastPage and 
            GoToNextPage.
            </summary>
            <param name="st">The page to add.</param>
        </member>
        <member name="M:TutorialScenario.TutorialFSM.GoToLastPage">
            <summary>
            Transition the tutorial to the page before the current one in the default page sequence.
            </summary>
        </member>
        <member name="M:TutorialScenario.TutorialFSM.GoToNextPage">
            <summary>
            Transition the tutorial to the page after current one in the default page sequence.
            </summary>
        </member>
        <member name="M:TutorialScenario.TutorialFSM.StartTutorial(System.String)">
            <summary>
            Start the finite state machine on the page with the given name.
            </summary>
            <param name="initialPageName">The name of the page to start on.</param>
        </member>
        <member name="M:TutorialScenario.TutorialFSM.StartTutorial(TutorialScenario.TutorialPage)">
            <summary>
            Start the finite state machine on the given page.
            </summary>
            <param name="initialPage">The page to start one.</param>
        </member>
        <member name="T:TutorialScenario.TutorialPage">
            <summary>
            TutorialPages are the states in the TutorialFSM finite state machine.
            They extend the KFSMState class, which represents a class in a more general 
            finite state machine, to add tutorial-related features like a Callback in which
            you draw the GUI of the tutorial page. 
            
            <seealso cref="T:KFSMState"/>
            </summary>
        </member>
        <member name="F:TutorialScenario.TutorialPage.onAdvanceConditionMet">
            <summary>
            Presumably, this KFSMEvent will be triggered when the function you passed to SetAdvanceCondition
            returns true. This should give you the opportunity to go to a page besides the default next
            page when the advance condition is met.
            </summary>
        </member>
        <member name="F:TutorialScenario.TutorialPage.OnDrawContent">
            <summary>
            Assign this Callback to a function that uses GUILayout to draw the GUI of this tutorial page.
            Whatever you do here gets draw inside the tutorial window, next to the picture of the 
            Kerbal instructor.
            </summary>
        </member>
        <member name="F:TutorialScenario.TutorialPage.onStepBack">
            <summary>
            Is this event triggered when GoToLastPage is called? Perhaps it gives you a chance to 
            go to a page besides the default previous page?
            </summary>
        </member>
        <member name="F:TutorialScenario.TutorialPage.windowTitle">
            <summary>
            The title displayed for this page.
            </summary>
        </member>
        <member name="M:TutorialScenario.TutorialPage.#ctor(System.String)">
            <summary>
            Create a new tutorial page with a given name. Note that the name of the page
            is distinct from its title.
            </summary>
            <param name="name">The name of the new page.</param>
        </member>
        <member name="M:TutorialScenario.TutorialPage.SetAdvanceCondition(KFSMEventCondition)">
            <summary>
            You can call this function and pass to it a function that takes a KFSMState
            and returns a boolean. That function will be called every update cycle while
            this tutorial page is active. If the function ever returns true, the tutorial
            will automatically advance to the next page.
            </summary>
            <param name="condition"></param>
        </member>
        <member name="T:UntrackedObjectClass">
            <summary>Describes an asteroid's size</summary>
        </member>
        <member name="F:UntrackedObjectClass.A">
            <summary>Standard radius = ???</summary>
        </member>
        <member name="F:UntrackedObjectClass.B">
            <summary>Standard radius = 5.5 m?</summary>
        </member>
        <member name="F:UntrackedObjectClass.C">
            <summary>Standard radius = 8.5 m?</summary>
        </member>
        <member name="F:UntrackedObjectClass.D">
            <summary>Standard radius = 15 m?</summary>
        </member>
        <member name="F:UntrackedObjectClass.E">
            <summary>Standard radius = 25 m?</summary>
        </member>
        <member name="T:Vector3d">
            <summary>
            A Vector3d in 3D space.
            Vector3d is just like Unity's Vector3 class, except it uses doubles instead of floats,
            so refer to the Unity documentation on Vector3.
            Vector3d also adds a few functions.
            </summary>
        </member>
        <member name="M:Vector3d.Exclude(Vector3d,Vector3d)">
            <summary>
            Returns <code>fromThat - Vector3d.Project(fromThat, excludeThis)</code>. That is, it removes
            the component of fromThat that is parallel to excludeThis and returns the remainder, which will
            be perpendicular to excludeThis.
            </summary>
            <param name="excludeThis">The direction to exclude from the result.</param>
            <param name="fromThat">The starting vector</param>
            <returns>A vector perpendicular to excludeThis and pointing in the same general direction as fromThat.</returns>
        </member>
        <member name="P:Vector3d.back">
            <summary>
            Minus forward
            </summary>
        </member>
        <member name="P:Vector3d.down">
            <summary>
            Minus up
            </summary>
        </member>
        <member name="P:Vector3d.left">
            <summary>
            Minus right.
            </summary>
        </member>
        <member name="P:Vector3d.xzy">
            <summary>
            Returs a new Vector3d with the y and z coordinates swapped?
            </summary>
        </member>
        <member name="T:Vessel">
            <summary>
            A Vessel object represents a single vessel. Parts that break off from a vessel become their own Vessels. Vessels that merge
            via docking become one Vessel.
            </summary>
        </member>
        <member name="F:Vessel.acceleration">
            <summary>
            Presumably, this is the current acceleration vector of the vessel, in m/s^2?
            </summary>
        </member>
        <member name="F:Vessel.altitude">
            <summary>
            Presumably, this is the current altitude above sea of the vessel, in meters?
            Is equal to pqsAltitude + heightFromTerrain (where heightFromTerrain is not -1).
            </summary>
        </member>
        <member name="F:Vessel.angularMomentum">
            <summary>
            Presumably, this is the current angular momentum of the vessel?
            </summary>
        </member>
        <member name="F:Vessel.angularVelocity">
            <summary>
            The current angular velocity vector of the vessel.
            </summary>
        </member>
        <member name="F:Vessel.atmDensity">
            <summary>
            Presumably, this is the current density of the atmosphere at the vessel's position?
            </summary>
        </member>
        <member name="F:Vessel.CoM">
            <summary>
            Presumably, this is the position of the center of mass of the vessel?
            </summary>
        </member>
        <member name="F:Vessel.ctrlState">
            <summary>
            The set of flight inputs currently being fed to the vessel. For example the current
            throttle being applied to the vesesl is vessel.ctrlState.mainThrottle.
            </summary>
        </member>
        <member name="F:Vessel.currentStage">
            <summary>
            Presumably, the current stage of the vessel as seen e.g. in the staging display
            </summary>
        </member>
        <member name="F:Vessel.heightFromSurface">
            <summary>
            Appears to always be -1?
            </summary>
        </member>
        <member name="F:Vessel.heightFromTerrain">
            <summary>
            The vertical distance in meters between the vessel and the nearest terrain (including buildings), 
            or -1 when sea depth is greater than 600m (terrainAltitude &lt;= -600).
            </summary>
        </member>
        <member name="F:Vessel.horizontalSrfSpeed">
            <summary>
            Presumably, the horizontal component of srf_velocity, in m/s.
            </summary>
        </member>
        <member name="F:Vessel.id">
            <summary>
            A unique identifier assigned to a vessel. When two vessels dock, the combined vessel has the id of the vessel docked to.
            On undock, the vessel undocked from keeps its id, the vessel that undocks gets a new id. 
            Note that this id is always fresh, a vessel gets a different id when it undocks then it had before docking.
            This is the pid value in the persistent.sfs at the VESSEL level.
            </summary>
        </member>
        <member name="F:Vessel.isEVA">
            <summary>
            Presumably, whether this vessel is an EVAing kerbal.
            </summary>
        </member>
        <member name="F:Vessel.Landed">
            <summary>
            Whether the vessel is currently sitting on the ground.
            </summary>
        </member>
        <member name="F:Vessel.latitude">
            <summary>
            The current latitude of the vessel over the current mainBody, in degrees.
            </summary>
        </member>
        <member name="F:Vessel.launchTime">
            <summary>
            The universal time at which the vessel was launched, in seconds?
            </summary>
        </member>
        <member name="F:Vessel.loaded">
            <summary>
            Whether the vessel is currently loaded. Vessels are only loaded when they come
            within about 2.5km of the active vessel.
            </summary>
        </member>
        <member name="F:Vessel.longitude">
            <summary>
            The current longitude of the vessel over the current mainBody, in degrees
            </summary>
        </member>
        <member name="F:Vessel.missionTime">
            <summary>
            Mission elapsed time, in seconds, maybe?
            </summary>
        </member>
        <member name="F:Vessel.obt_velocity">
            <summary>
            The current velocity of the vessel, in world coordinates, in the nonrotating inertial reference frame.
            </summary>
        </member>
        <member name="F:Vessel.OnFlyByWire">
            <summary>
            You can add your own function to this callback to register a function that can provide flight control input
            to the vessel. Once you've registered this callback, it will be called once per FixedUpdate. Provide flight
            control input by modifying the FlightCtrlState passed to your function. This FlightCtrlState will already
            contain the player's input, which you can modify or override as desired.
            </summary>
            <example>
            <code>
            void MyAutopilotFunction(FlightCtrlState s) {
              s.yaw = 1;
            }
            ...
            vessel.OnFlyByWire += MyAutopilotFunction
            </code>
            This will create an autopilot that always yaws hard to the right. You can probably devise something more useful, though...
            </example>
        </member>
        <member name="F:Vessel.OnJustAboutToBeDestroyed">
            <summary>
            You can add a function to this callback, and the function will be called when the vessel is "just about to be destroyed."
            </summary>
        </member>
        <member name="F:Vessel.packed">
            <summary>
            Whether the vessel is currently packed. Vessels are only packed when the come within about 300m of the active vessel.
            </summary>
        </member>
        <member name="F:Vessel.parts">
            <summary>
            A list of the parts in the vessel. Note that when the vessel is not loaded, this list will be empty.
            </summary>
        </member>
        <member name="F:Vessel.patchedConicSolver">
            <summary>
            Among other things, the patchedConicSolver stores information about the player's current set of maneuver nodes.
            </summary>
        </member>
        <member name="F:Vessel.pqsAltitude">
            <summary>
            Presumably, the height in meters of the planet's terrain QuadSphere directly under the vessel, compared to sea level.
            This does not take the height of buildings into account. It is generally within +/- 1m of terrainAltitude, 
            except when over buildings (terrainAltitude does account for buildings) or sea with a depth of greater
            than 600m (terrainAltitude &lt;= -600, heightFromTerrain == -1).
            </summary>
        </member>
        <member name="F:Vessel.protoVessel">
            <summary>
            The protoVessel can be used to get some saved information about unloaded vessels.
            </summary>
        </member>
        <member name="F:Vessel.referenceTransformId">
            <summary>
            This is the flightID of the part that is the current 'Control from Here' part.
            This is the root part until changed by the player.
            The vessel transform is set to the transform of this part.
            This is the 'ref' value in the persistent.sfs at the VESSEL level.
            </summary>
        </member>
        <member name="F:Vessel.rootPart">
            <summary>
            The root of the tree of parts that comprises the vessel. Usually this is the original command pod placed when constructing the vessel.
            </summary>
        </member>
        <member name="F:Vessel.situation">
            <summary>
            Some coarse information about the current state of the vessel.
            </summary>
        </member>
        <member name="F:Vessel.Splashed">
            <summary>
            Whether the vessel is currently splashed down.
            </summary>
        </member>
        <member name="F:Vessel.srf_velocity">
            <summary>
            The velocity of the vessel in the "surface" reference frame, the reference frame that rotates with the planet.
            </summary>
        </member>
        <member name="F:Vessel.staticPressure">
            <summary>
            Presumably, the atmospheric pressure at the vessel's current location.
            </summary>
        </member>
        <member name="F:Vessel.terrainAltitude">
            <summary>
            The height in meters of the nearest terrain (including buildings) directly under the vessel, compared to sea level.
            Ground which is underwater will have a negative terrainAltitude.
            </summary>
        </member>
        <member name="F:Vessel.upAxis">
            <summary>
            Presumably, a unit vector in the up (radially outward from the planet) direction.
            </summary>
        </member>
        <member name="F:Vessel.verticalSpeed">
            <summary>
            Presumably, the vertical speed of the vessel in m/s.
            </summary>
        </member>
        <member name="F:Vessel.vesselName">
            <summary>
            The name of the vessel as it appears in e.g. the tracking station.
            </summary>
        </member>
        <member name="F:Vessel.vesselType">
            <summary>
            The type of the vessel, as shown by the type of icon on the map view.
            </summary>
        </member>
        <member name="M:Vessel.ChangeWorldVelocity(Vector3d)">
            <summary>
            Add a given velocity offset to the vessels current velocity, instantaneously (may only work for loaded vessels?)
            </summary>
            <param name="velOffset"></param>
        </member>
        <member name="M:Vessel.findLocalCenterOfPressure">
            <summary>
            Broken Function with expensive runtime. Do not use. (If it worked it'd do as the name says but it doesn't as of 0.23.5)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vessel.findLocalMOI(UnityEngine.Vector3)">
            <summary>Returns the vessel's moment of inertia around its center of mass.</summary>
            <warning>Returns nonsense answers; DO NOT USE</warning>
        </member>
        <member name="M:Vessel.findWorldCenterOfMass">
            <summary>
            Computes and returns the position of the center of mass of the vessel, in world coordinates.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vessel.GetCrewCount">
            <summary>
            The number of kerbals inside the vessel. This is ONLY reliable when the vessel is loaded (vessel.loaded == true). 
            When the vessel is unloaded you can compute the crew count as 
            <code>vessel.protoVessel.protoPartSnapshots.Sum(pps => pps.protoModuleCrew.Count))</code>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vessel.GetTransform">
            <summary>
            Gets the transform of the part the vessel is being controlled from (i.e., the part
            set by the "control from here" right click option).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vessel.GoOffRails">
            <summary>
            Pulls the vessel off rails?
            </summary>
        </member>
        <member name="M:Vessel.GoOnRails">
            <summary>
            Puts the vessel on rails?
            </summary>
        </member>
        <member name="M:Vessel.SetWorldVelocity(Vector3d)">
            <summary>
            Sets the velocity of the vessel to a new value, instantaneously. May only work for loaded vessels?
            </summary>
            <param name="vel"></param>
        </member>
        <member name="M:Vessel.RevealAltitude">
             <summary>Returns the vessel's altitude above the reference sphere of 
            		the CelestialBody it orbits</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:Vessel.RevealMass">
             <summary>Returns the vessel's mass, in tons</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:Vessel.RevealName">
             <summary>Returns the vessel's tracking station name</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:Vessel.RevealSituationString">
             <summary>Describes the state of the vessel</summary>
            
             <returns>A string containing the sphere of influence and trajectory of the object</returns>
             
             <example>"Orbiting the Sun"</example>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:Vessel.RevealSpeed">
             <summary>Returns the vessel's speed</summary>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="M:Vessel.RevealType">
             <summary>Returns the type of the vessel</summary>
            
             <returns>A string representation of vesselType</returns>
             
             <remarks>Implements IDiscoverable</remarks>
            
        </member>
        <member name="P:Vessel.DiscoveryInfo">
            <summary>Describes to what extent this object has been explored</summary>
        </member>
        <member name="P:Vessel.isActiveVessel">
            <summary>
            Whether the player is currently controlling this vessel.
            </summary>
        </member>
        <member name="P:Vessel.LandedOrSplashed">
            <summary>
            Landed || Splashed; use this to determined whether the vessel is on the ground somewhere, whether on land or water.
            </summary>
        </member>
        <member name="P:Vessel.mainBody">
            <summary>
            The body whose sphere of influence the vessel is currently in.
            </summary>
        </member>
        <member name="P:Vessel.orbit">
            <summary>
            The current orbit of the vessel. 
            </summary>
        </member>
        <member name="P:Vessel.Parts">
            <summary>
            A list of the parts this vessel is composed of.
            </summary>
        </member>
        <member name="P:Vessel.Item(System.Int32)">
            <summary>
            Get a part by its index, in some order.
            </summary>
            <param name="index">Index of the part to get.</param>
            <returns>The "index"th part in the vessel.</returns>
        </member>
        <member name="P:Vessel.Item(System.UInt32)">
            <summary>
            Get a part by its part.flightID value
            </summary>
            <param name="flightID">The flightID value of some part in the vessel</param>
            <returns>The matching part, or null if there is  no part with that flightID.</returns>
        </member>
        <member name="T:Vessel.Situations">
            <summary>
            The type of Vessel.situation
            </summary>
        </member>
        <member name="F:Vessel.Situations.PRELAUNCH">
            <summary>
            Waiting on the launchpad, ready to be launched
            </summary>
        </member>
        <member name="F:Vessel.Situations.SUB_ORBITAL">
            <summary>
            On a collision course with the ground
            </summary>
        </member>
        <member name="F:Vessel.Situations.ESCAPING">
            <summary>
            On a hyperbolic trajectory
            </summary>
        </member>
    </members>
</doc>

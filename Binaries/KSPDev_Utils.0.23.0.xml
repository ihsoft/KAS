<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KSPDev_Utils.0.23.0</name>
    </assembly>
    <members>
        <member name="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto">
             <summary>A base class for a proto of a collection of values.</summary>
             <remarks>Collection of collections is not supported. Though, descendands may use own
             (de)serialization approach to handle nested collections.
             <para>All descendants of this class must implement a constructor which accepts a single
             argument: the type of the collection. Constructor can throw <see cref="T:System.ArgumentException"/>
             if passed type is unacceptable.</para>
             </remarks>
             <example>As a good example of overriding of this class see
             <see cref="T:KSPDev.ConfigUtils.GenericCollectionTypeProto"/>. Though, it tries to be universal and, hence, works
             via reflection. You don't need to deal with reflections as long as your custom proto used for
             the fields of known types only.
             <code>
             class MyBooleanCollection {
               public void AddItem(bool itemValue) {
                 // ...some custom code...
               }
               public IEnumerable GetMyVeryCustomIterator() {
                 // ...some custom code...
                 return res;
               }
             }
            
             class MyBooleanCollectionProto : AbstractCollectionTypeProto {
               public MyBooleanCollectionProto() : base(typeof(bool)) {}
            
               public override Type GetItemType() {
                 return typeof(bool);
               }
               public override IEnumerable GetEnumerator(object instance) {
                 return (instance as MyBooleanCollection).GetMyVeryCustomIterator(); 
               }
               public override void AddItem(object instance, object item) {
                 (instance as MyBooleanCollection).AddItem((bool) item);
               }
             }
             </code>
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.#ctor(System.Type)">
            <param name="containerType">A type of the collection (i.e. an immediate field's type).</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.GetItemType">
            <summary>Returns type of items in the collection.</summary>
            <returns>An item type.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.GetEnumerator(System.Object)">
            <summary>Returns enumerable object for the collection.</summary>
            <param name="instance">An instance to get the enumerable for.</param>
            <returns>
            An enumerable of objects. Type of the items is determined by the relevant
            <see cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>.
            </returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.AddItem(System.Object,System.Object)">
            <summary>Adds an item into the collection.</summary>
            <param name="instance">A collection instance to add item into.</param>
            <param name="item">
            An item to add. The item must be of the same type as <see cref="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.GetItemType"/> specifies.
            </param>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractCollectionTypeProto.ClearItems(System.Object)">
            <summary>Removes all items from the collection.</summary>
            <param name="instance">A collection instance to clear.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto">
            <summary>A base class for a proto of a single value.</summary>
            <remarks>All descendands of this class must implement a default constructor.</remarks>
            <example>See real overrides in <see cref="T:KSPDev.ConfigUtils.PrimitiveTypesProto"/> and
            <see cref="T:KSPDev.ConfigUtils.KspTypesProto"/>.
            <para>Here is how you could implement your own proto to persist string array as a string.</para>
            <code>
            class StringArrayProto : AbstractOrdinaryValueTypeProto {
              public override bool CanHandle(Type type) {
                return typeof(string[]) == type;
              }
              public override string SerializeToString(object value) {
                return string.Join(",", (value as string[]));
              }
              public override object ParseFromString(string value, Type type) {
                // Due to check in CanHandle we know the type is string[].
                return value.Split(',');
              }
            }
            </code>
            </example>
            <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            <seealso cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.#ctor">
            <summary>Default constructor must be the only constructor of the proto.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.CanHandle(System.Type)">
            <summary>Tells if proto can handle the specified type.</summary>
            <param name="type">A type in question.</param>
            <returns><c>true</c> if proto can (de)serialize values of the type.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.SerializeToString(System.Object)">
            <summary>Serializes value into a string.</summary>
            <remarks>In general avoid using <c>ToString()</c> methods to produce the serialized value.
            Such methods are not designed to be unambiguous.</remarks>
            <param name="value">A value to serialize.</param>
            <returns>A string representation of the value. It doesn't need to be human readable.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.ParseFromString(System.String,System.Type)">
            <summary>Makes a value from the string representation.</summary>
            <param name="value">A string produced by <see cref="M:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto.SerializeToString(System.Object)"/>.</param>
            <param name="type">A type to convert the value into.</param>
            <returns>A new and initialized instance of the requested type.</returns>
            <exception cref="T:System.ArgumentException">If value cannot be parsed.</exception>
        </member>
        <member name="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute">
             <summary>A base for any persitent field annotation.</summary>
             <remarks>Descendands must initialize at least <see cref="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._ordinaryTypeProto"/> field. If
             <see cref="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._collectionTypeProto"/> is set then the field is considered a persistent
             collection of values.
             <para>See more examples in <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>.</para>
             </remarks>
             <example>A "shortcut" attributes could be declared like this: 
             <code>
             class MyTypeAttribute : AbstractPersistentFieldAttribute {
               public MyTypeAttribute(string cfgPath) : base(cfgPath) {
                 _ordinaryTypeProto = typeof(PrimitiveTypesProto);
               }
             }
            
             class MyTypesCollectionAttribute : AbstractPersistentFieldAttribute {
               public MyTypesCollectionAttribute(string cfgPath) : base(cfgPath) {
                 _ordinaryTypeProto = typeof(PrimitiveTypesProto);
                 _collectionTypeProto = typeof(GenericCollectionTypeProto);
               }
             }
             </code>
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>
             <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute.path">
            <summary>Relative path to the value or node. Case-insensitive.</summary>
            <remarks>Absolute path depends on the context.</remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute.group">
            <summary>A tag for a group of fields.</summary>
            <remarks>Group can be used when reading/writing values via <see cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            to process only a subset of the persistent fields of the class. It's case-insensitive.
            </remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._ordinaryTypeProto">
            <summary>A proto that (de)serializes field's value as a simple string.</summary>
            <remarks>This type must be a descendant of <see cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>.
            </remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute._collectionTypeProto">
            <summary>A proto that handles field's value as a collection of persistent values.</summary>
            <remarks>If it's <c>null</c> then field is assumed to be not a collection.</remarks>
            <para>This type must be a descendant of <see cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>.
            </para>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute.#ctor(System.String)">
            <param name="cfgPath">A path to the fields's value in the config. Components must be separated
            by symbol '/'. The path is relative, the absolute path is determined when doing actual
            (de)serialization. The path is case-insensitive.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute">
            <summary>A base for any persistent fields file annotation.</summary>
            <remarks>This attribute doesn't assume much logic so, you basically override it only to create
            "shortcuts".</remarks>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)"/>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)"/>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.group">
            <summary>A group tag which is handled by this annotation.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.nodePath">
            <summary>A path to the node which will be the root for the fields in the group.</summary>
            <remarks>By setting different root for every group and/or type you may combine multiple
            settings in the same config file. When <see cref="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.configFilePath"/> is empty this value is an
            absolute path on the game's database.</remarks>
        </member>
        <member name="F:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.configFilePath">
            <summary>An optional relative path to the config file.</summary>
            <remarks>
            Absolute name is resolved via <see cref="M:KSPDev.FSUtils.KspPaths.MakeAbsPathForGameData(System.String[])"/>. If left
            empty then data is read from the game's database. Note, that database access is read-only.
            </remarks>
        </member>
        <member name="M:KSPDev.ConfigUtils.AbstractPersistentFieldsFileAttribute.#ctor(System.String,System.String,System.String)">
            <summary>Constructor for a persistent field.</summary>
            <param name="configFilePath">
            A relative or an absolute path to the file. It's resolved via
            <see cref="M:KSPDev.FSUtils.KspPaths.MakeAbsPathForGameData(System.String[])"/>. If empty then data is read from
            database.
            </param>
            <param name="nodePath">
            A root for the persistent fields when saving or loading via this annotation. If empty then
            root node of the file is used. Cannot be <c>null</c>
            </param>
            <param name="group">
            A group of the annotation. When saving or loading persistent fields only the fields of this
            group will be considered. Must not be <c>null</c>.
            </param>
        </member>
        <member name="T:KSPDev.ConfigUtils.IPersistentField">
             <summary>Interface for the simple types that need custom (de)serialization logic.</summary>
             <remarks>
             It's similar to <c>IConfigNode</c> interface in the compound types but with the following
             differences:
             <list type="bullet">
             <item>The value is (de)serialized from/to a simple string.</item>
             <item>
             If the field is initialized to an instance of the type, then this instance will be used to
             deserialize the value. If the field is not initialized but there is a value in the config file,
             then a new instance will be created. For this reason the type must implement a default
             constructor.
             </item>
             </list>
             <para>
             Note that the types that implement this interface will <i>never</i> be treated as compound. I.e.
             <see cref="T:KSPDev.ConfigUtils.ConfigAccessor"/> will not try to persist the members of such types even though there
             may be fields attributed with <see cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>.
             </para>
             </remarks>
             <example>
             Here is how a simple vector serialization may look like:
             <code><![CDATA[
             public class MyVector : IPeristentField {
               float x;
               float y;
            
               /// <inheritdoc/>
               public string SerializeToString() {
                 return string.Format("{0},{1}", x ,y);
               }
               /// <inheritdoc/>
               public void ParseFromString(string value) {
                 var elements = value.Split(',');
                 x = float.Parse(elements[0]);
                 y = float.Parse(elements[1]);
               }
             }
             ]]></code>
             <para>
             This example doesn't do any checking when parsing the string, but in general it's a good idea to
             do a sanity check of the string. It's OK to throw an exception from the parsing method when the
             data is invalid.
             </para>
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
             <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.IPersistentField.SerializeToString">
            <summary>Returns the object's state as a plain string.</summary>
            <returns>Object's state.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.IPersistentField.ParseFromString(System.String)">
            <summary>Restores the object's state from a plain string.</summary>
            <param name="value">String value to restore from.</param>
            <remarks>It's OK to throw exceptions if the value cannot be parsed.</remarks>
        </member>
        <member name="T:KSPDev.ConfigUtils.PartConfig">
            <summary>Helper methods to access and manipulate part's configs.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PartConfig.GetModuleConfig(PartModule,ConfigNode)">
            <summary>Gets a config of the part module.</summary>
            <remarks>
            It takes into account the module index, so in case of the part has multiple modules of the
            same type, the right module config will be returned.
            </remarks>
            <param name="module">Module to get config for.</param>
            <param name="partNode">
            Part's config to use. If omitted then part's prefab config is used.
            </param>
            <returns>Either the found config node or an empty node. It's never <c>null</c>.</returns>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute">
            <summary>
            A simple annotation to associate a persistent group with a game's database key.
            </summary>
            <remarks>
            <para>This annotation is basically a shortcut to <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>.
            You may use the latter with an empty config file path if you find it more convinient.</para>
            <para>Each <c>.cfg</c> file in the mod's folders is scanned and indexed by the game on start. The
            data is stored in the database where it can be accessed from the game. The access is read-only,
            any changes to the node returned from the database won't affect the database state.</para>
            <para>The config file in the database is identified by a key which is made of three major parts:
            <list type="">
            <item>A file path relative to <c>GameData</c>.</item>
            <item>The config filename without extension.</item>
            <item>Node path inside the file starting from the root. I.e. the root node should have name as
            well.</item>
            </list>
            </para>
            <para>E.g. key <c>KIS/settings/KISConfig/Global</c> addresses a node <c>KISConfig/Global</c> in file
            stored at <c>GameData/KIS/settings.cfg</c>.
            </para>
            <para>Special case is subfolders <c>PluginData</c>, they are ignored during database scan. Put
            there configs that can change during the gameplay. Remember, that even a tiny change in the
            config will trigger database re-compilation on the next start which may significantly impact
            game loading time.</para>
            <para>Database is actively used by
            <see href="https://github.com/sarbian/ModuleManager">ModuleManager</see> (a.k.a. MM). Be wise
            when choosing if fields should be read from a file or from the database. Module manager
            patches are only applied on the database, they don't affect the config files. E.g. part configs
            are frequently updated by the patches but never updated from the gameplay so, reading them via
            database is the best choice. Various mod's settings, on the other hand, can change during the
            game but will unlikely be a target for a MM patch, put them into <c>PluginData</c> folder and
            read/write via file methods.</para>
            </remarks>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)"/>
            <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute.#ctor(System.String,System.String)">
            <param name="nodePath">
            An absolute path to the node in the game's database. Note that this must be a path to the
            config's <i>root</i>. This path is used to find the right settings <i>file</i>, not the right
            node within a file.
            </param>
            <param name="group">
            A group of the annotation. When saving or loading the persistent fields only the fields of
            this group will be considered. Must not be <c>null</c>.
            </param>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute">
             <summary>
             A simple annotation to associate a persistent group with a configuration file.
             </summary>
             <remarks>Multiple annotations are allowed on the class. It's not required to have unique
             filename/nodePath/group set in every annontation but it's highly recommended.  
             <para>This assignment is ignored in the nested classes. Though, when using nested class as an
             immediate target of the call the annotation will be handled just fine.</para>
             </remarks>
             <example>
             <code>
             [PersistentFieldsFile("settings.cfg", "Root/Default")]
             [PersistentFieldsFile("settings-other.cfg", "", "abc")]
             [PersistentFieldsFile("settings-nested-bad.cfg", "", "nevermind")]
             class ClassWithPersistentFields {
               [PersistentField("field1")]
               private int intField = 0;
             
               [PersistentFieldsFile("settings-nested-good.cfg", "Root/Nested", "nevermind")]
               internal struct ComplexType {
                 [PersistentField("val1", group = "nevermind")]
                 public bool boolVal;
                 [PersistentField("val2", group = "nevermind")]
                 public Color colorVal;
               }
             
               [PersistentField("complexField1", group = "abc")]
               private ComplexType complexField;
             
               void SaveFields() {
                 // Save a default group of fields. 
                 ConfigAccessor.WriteFieldsFromType(instance: this);
                 /* File will be created at "GameData/settings.cfg":
                  * Root
                  * {
                  *   Default
                  *   {
                  *     field1: 0
                  *   }
                  * }
                  */
             
                 // Save group "abc". Note that the complex type only defines fields for group "nevermind"
                 // but it's ignored. The group is only honored on the immediate type, i.e.
                 // ClassWithPersistentFields in this case. 
                 ConfigAccessor.WriteFieldsFromType(instance: this, group: "abc");
                 /* File will be created at "GameData/settings-other.cfg".
                  * {
                  *   complexField1
                  *   {
                  *     val1: False
                  *     val2: 0,0,0,1
                  *   }
                  * }
                  */
             
                 // Try to use incorrect setup and save group "nevermind" for "this". 
                 // File will be created at "GameData/settings-nested-bad.cfg". And it will be empty since
                 // no fields for this group is defined in class ClassWithPersistentFields.
                 ConfigAccessor.WriteFieldsFromType(instance: this, group: "nevermind");
             
                 // Proper use of the nested complex type would be like this.
                 var test = new ComplexType() {
                     boolVal = true,
                     colorVal = Color.white
                 };
                 ConfigAccessor.WriteFieldsFromType(instance: test, group: "nevermind");
                 /* File will be created at "GameData/settings-nested-good.cfg".
                  * Root
                  * {
                  *   Nested
                  *   {
                  *     complexField1
                  *     {
                  *       val1: True
                  *       val2: 1,1,1,1
                  *     }
                  *   }
                  * }
                  */
            
                 // The following call makes the similar output but with different values.    
                 ConfigAccessor.WriteFieldsFromType(instance: complexField, group: "nevermind");
               }
             }
             </code>
             Note that this annotation only adds or re-creates the node specified by <c>nodePath</c>. If
             target file had other nodes they will not be overwritten. Though, you may expect the file
             structure to be re-ordered and comments (if any) lost. The file is actualy changed, it's read,
             updated, and saved.
             </example>
             <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)"/>
             <seealso cref="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFileAttribute.#ctor(System.String,System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.GenericCollectionTypeProto">
            <summary>A proto handler for a simple generic collection.</summary>
            <remarks>
            Generic must have exactly one arguent, implement method <c>Add</c> for adding new items, and
            implement <see cref="T:System.Collections.IEnumerable"/>.
            </remarks>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.#ctor(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.GetItemType">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.GetEnumerator(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.AddItem(System.Object,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.GenericCollectionTypeProto.ClearItems(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.PrimitiveTypesProto">
            <summary>A proto for handling C# primitive types.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PrimitiveTypesProto.CanHandle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PrimitiveTypesProto.SerializeToString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.PrimitiveTypesProto.ParseFromString(System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto">
            <summary>Proto to handle all primitive C# types and common Unity/KSP types.</summary>
            <seealso cref="T:KSPDev.ConfigUtils.PrimitiveTypesProto"/>
            <seealso cref="T:KSPDev.ConfigUtils.KspTypesProto"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.StandardOrdinaryTypesProto.CanHandle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.StandardOrdinaryTypesProto.SerializeToString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.StandardOrdinaryTypesProto.ParseFromString(System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.ConfigUtils.StdPersistentGroups">
            <summary>Group names that have special meaning.</summary>
            <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="F:KSPDev.ConfigUtils.StdPersistentGroups.Default">
            <summary>A public group that can be saved/loaded on every game scene.</summary>
            <remarks>
            By the contract any caller can save/load this group at any time. If the class declares
            persistent fields with a specific save/load logic then they need to have a group different
            from the default.
            </remarks>
        </member>
        <member name="T:KSPDev.ConfigUtils.ConfigAccessor">
            <summary>A service class that simplifies accessing configuration files.</summary>
            <remarks>This class provides a lot of useful methods to deal with values in game's configuration
            files. There are low level methods that deal with nodes and values, and there are high level
            methods that use metadata from the annotated fields.</remarks>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsFromFile(System.String,System.Type,System.Object,System.String,System.String)">
            <summary>Reads values of the annotated persistent fields from a config file.</summary>
            <param name="filePath">
            A relative or an absolute path to the file. It's resolved via
            <see cref="M:KSPDev.FSUtils.KspPaths.MakeAbsPathForGameData(System.String[])"/>.
            </param>
            <param name="type">A type to load fields for.</param>
            <param name="instance">
            An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.
            </param>
            <param name="nodePath">
            An optional path in the file. All type's field will be read relative to this part.
            </param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsFromDatabase(System.String,System.Type,System.Object,System.String)">
            <summary>Reads values of the annotated persistent fields from a config file.</summary>
            <param name="nodePath">An absolute path in the database. No leading "/".</param>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsFromNode(ConfigNode,System.Type,System.Object,System.String)">
            <summary>Reads values of the annotated persistent fields from a config node.</summary>
            <param name="node">A config node to read data from.</param>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(System.Type,System.Object,System.String)">
            <summary>
            Reads persistent fields from the config files specified by the class annotation.
            </summary>
            <param name="type">A type to load fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be loaded.</param>
            <param name="group">A group to load fields for. If <c>null</c> then all groups that are
            defined in the class annotation via <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/> will be
            loaded.</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsDatabaseAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsIntoFile(System.String,System.Type,System.Object,System.String,System.Boolean,System.String)">
            <summary>Writes values of the annotated persistent fields into a file.</summary>
            <remarks>
            All persitent values are <b>added</b> into the file provided. I.e. if node had already had a
            value being persited then it either overwritten (ordinary fields) or extended (collection
            fields).
            </remarks>
            <param name="filePath">
            A relative or an absolute path to the file. It's resolved via
            <see cref="M:KSPDev.FSUtils.KspPaths.MakeAbsPathForGameData(System.String[])"/>.
            </param>
            <param name="rootNodePath">
            A path to the node in the file where the data should be written. If the node already exsists
            it will be deleted.
            </param>
            <param name="type">A type to write fields for.</param>
            <param name="instance">
            An instance of type <paramref name="type"/>. If it's <c>null</c> then only static fields will
            be written.
            </param>
            <param name="mergeMode">
            If <c>true</c> and the file already exists then only will be created.
            </param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsIntoNode(ConfigNode,System.Type,System.Object,System.String)">
            <summary>Writes values of the annotated persistent fields into a config node.</summary>
            <remarks>All persitent values are <b>added</b> into the node provided. I.e. if node had
            already had a value being persited then it either overwritten (ordinary fields) or extended
            (collection fields).</remarks>
            <param name="node">A config node to write data into.</param>
            <param name="type">A type to write fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be written.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/>).</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.WriteFieldsFromType(System.Type,System.Object,System.String)">
            <summary>
            Writes persistent fields into the config files specified by the class annotation.
            </summary>
            <remarks>Method updates the config file(s) by preserving top level nodes that are not
            specified as targets for the requested group.
            <para>Note, that fields cannot be writtent into database. Such annotations will be skipped
            during the save.</para>
            </remarks>
            <param name="type">A type to write fields for.</param>
            <param name="instance">An instance of type <paramref name="type"/>. If it's <c>null</c> then
            only static fields will be written.</param>
            <param name="group">A group to write fields for. If <c>null</c> then all groups that are
            defined in the class annotation via <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/> will be
            written.</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath(ConfigNode,System.String)">
            <summary>Reads a value from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the value. Path components should be separated by '/'
            symbol.</param>
            <returns>String value or <c>null</c> if path or value is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath(ConfigNode,System.String[])">
            <summary>Reads a value from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <returns>String value or <c>null</c> if path or value is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValuesByPath(ConfigNode,System.String)">
            <summary>Reads repeated values from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the values. Path components should be separated by '/'
            symbol.</param>
            <returns>Array of string values or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValuesByPath(ConfigNode,System.String[])">
            <summary>Reads repeated values from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <returns>Array of string values or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodeByPath(ConfigNode,System.String,System.Boolean)">
            <summary>Reads a node from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="createIfMissing">If <c>true</c> than unknown nodes in the path will be
            created.</param>
            <returns>Config node or <c>null</c> if path or node is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodeByPath(ConfigNode,System.String[],System.Boolean)">
            <summary>Reads a node from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="createIfMissing">If <c>true</c> than unknown nodes in the path will be
            created.</param>
            <returns>Config node or <c>null</c> if path or node is not present in the
            <paramref name="node"/>. Returns <paramref name="node"/> if path is empty array.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodesByPath(ConfigNode,System.String)">
            <summary>Reads repeated nodes from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the nodes. Path components should be separated by '/'
            symbol.</param>
            <returns>Array of nodes or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetNodesByPath(ConfigNode,System.String[])">
            <summary>Reads repeated nodes from config node by a path.</summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <returns>Array of nodes or <c>null</c> if path is not present in the
            <paramref name="node"/>.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath(ConfigNode,System.String,System.String)">
            <summary>Sets a value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A string value to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath(ConfigNode,System.String[],System.String)">
            <summary>Sets a value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A string value to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetNodeByPath(ConfigNode,System.String,ConfigNode)">
            <summary>Sets a node in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A config node to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetNodeByPath(ConfigNode,System.String[],ConfigNode)">
            <summary>Sets a node in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A config node to store.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddValueByPath(ConfigNode,System.String,System.String)">
            <summary>Adds a repeated value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the nodes. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A string value to add into the node.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddValueByPath(ConfigNode,System.String[],System.String)">
            <summary>Adds a repeated value in config node by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A string value to add into the node.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddNodeByPath(ConfigNode,System.String,ConfigNode)">
            <summary>Adds a repeated node in the config by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the nodes. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A config node to add.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.AddNodeByPath(ConfigNode,System.String[],ConfigNode)">
            <summary>Adds a repeated node in the config by a path.</summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A config node to add.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath``1(ConfigNode,System.String,``0,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Stores a value of arbitrary type <typeparamref name="T"/> into a config node.
            </summary>
            <param name="node">A node to set data in.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A value to store. The <paramref name="typeProto"/> handler must know how
            to convert the value into string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <typeparam name="T">The value type to store. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.SetValueByPath``1(ConfigNode,System.String[],``0,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Stores a value of arbitrary type <typeparamref name="T"/> into a config node.
            </summary>
            <param name="node">A node to set data in.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A value to store. The <paramref name="typeProto"/> handler must know how
            to convert value's type into string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <typeparam name="T">The value type to store. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath``1(ConfigNode,System.String,``0@,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Reads a value of arbitrary type <typeparamref name="T"/> from a config node.
            </summary>
            <param name="node">A node to read data from.</param>
            <param name="path">A string path to the node. Path components should be separated by '/'
            symbol.</param>
            <param name="value">A variable to read value into. The <paramref name="typeProto"/> handler
            must know how to convert value's type from string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <returns><c>true</c> if value was successfully read and stored.</returns>
            <typeparam name="T">The value type to read. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetValueByPath``1(ConfigNode,System.String[],``0@,KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto)">
            <summary>
            Reads a value of arbitrary type <typeparamref name="T"/> from a config node.
            </summary>
            <param name="node">A node to read data from.</param>
            <param name="pathKeys">An array of values that makes the full path. First node in the array is
            the top most component of the path.</param>
            <param name="value">A variable to read value into. The <paramref name="typeProto"/> handler
            must know how to convert value's type from string.</param>
            <param name="typeProto">A proto capable to handle the type of <paramref name="value"/>. If not
            set then <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/> is used.</param>
            <returns><c>true</c> if value was successfully read and stored.</returns>
            <typeparam name="T">The value type to read. Type proto must be able to handle it.
            </typeparam>
            <exception cref="T:System.ArgumentException">If type cannot be handled by the proto.</exception>
        </member>
        <member name="M:KSPDev.ConfigUtils.ConfigAccessor.GetPersistentFieldsFiles(System.Type,System.String)">
            <summary>Gathers and returns persistent field fields annotations.</summary>
            <param name="type">A type to lookup for the field annotations.</param>
            <param name="group">A group tag (see <see cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>). If
            <c>null</c> then all files defined in the type are returned.</param>
            <returns>Array of persistent fields.</returns>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldsFactory">
            <summary>A helper class to gather persistent field attributes.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFactory.GetPersistentFields(System.Type,System.Boolean,System.Boolean,System.String)">
            <summary>Gathers persitent fields for a type.</summary>
            <param name="type">A type of to gather persistent fields for.</param>
            <param name="needStatic">Specifies if static fields need to be returned.</param>
            <param name="needInstance">Specifies if non-static fields need to be returned.</param>
            <param name="group">A filter group for the persitent fields. Note that group is ignored for
            the inner fields of a compound type.</param>
            <returns>List of persitent fields.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFactory.FindAnnotatedFields(System.Reflection.IReflect,System.Boolean,System.Boolean,System.String)">
            <summary>Finds and returns peristent fields of the requested group.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldsFactory.FieldFilter(System.Reflection.ICustomAttributeProvider,System.String)">
            <summary>Filters only persitent fields of the required group.</summary>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentField">
            <summary>Descriptor of a persitent field.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.PersistentField.fieldInfo">
            <summary>Annotated fields metadata.</summary>
        </member>
        <member name="F:KSPDev.ConfigUtils.PersistentField.cfgPath">
            <summary>Parsed configuration paths.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.#ctor(System.Reflection.FieldInfo,KSPDev.ConfigUtils.PersistentFieldAttribute)">
            <param name="fieldInfo">An annotated field metadata.</param>
            <param name="fieldAttr">An annotation of the field.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.WriteToConfig(ConfigNode,System.Object)">
            <summary>Writes field into a config node.</summary>
            <remarks>
            This method is not expected to fail since converting any type into string is expected to
            succeeed on any value.
            </remarks>
            <param name="node">A node to write state to.</param>
            <param name="instance">An owner of the field. Can be <c>null</c> for static fields.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.ReadFromConfig(ConfigNode,System.Object)">
            <summary>Reads field from a config node.</summary>
            <param name="node">A node to read state from.</param>
            <param name="instance">An owner of the field. Can be <c>null</c> for static fields.</param>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.SerializeCompoundFieldsToNode(System.Object)">
            <summary>Makes a config node from the compound type fields.</summary>
            <param name="instance">Owner of the fields. Can be <c>null</c> for static fields.</param>
            <returns>New configuration node with the data.</returns>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentField.DeserializeCompoundFieldsFromNode(ConfigNode,System.Object)">
            <summary>Sets a compound type field values from the config node.</summary>
            <param name="node">Node to read values from.</param>
            <param name="instance">Owner of the fields.</param>
        </member>
        <member name="T:KSPDev.ConfigUtils.PersistentFieldAttribute">
             <summary>A simple attribute for the fields that need (de)serialization.</summary>
             <remarks>
             This form allows adjusting any <see cref="T:KSPDev.ConfigUtils.AbstractPersistentFieldAttribute"/> property
             in the annotation, and has a shortcut to mark a field as a collection
             (<c><see cref="P:KSPDev.ConfigUtils.PersistentFieldAttribute.isCollection"/> = true</c>).
             <para>
             By default the ordinal values are handled via <see cref="T:KSPDev.ConfigUtils.StandardOrdinaryTypesProto"/>
             and the collection fields via <see cref="T:KSPDev.ConfigUtils.GenericCollectionTypeProto"/>. These proto handlers can
             be changed in the annotation by assigning properties
             <see cref="P:KSPDev.ConfigUtils.PersistentFieldAttribute.ordinaryTypeProto"/> and/or <see cref="P:KSPDev.ConfigUtils.PersistentFieldAttribute.collectionTypeProto"/>.
             </para>
             </remarks>
             <example>
             Below is a simple usage of the attribute.
             <code><![CDATA[
             class ClassWithPersistentFields {
               [PersistentField("my/listField", isCollection = true)]
               private List<string> sampleList = new List<string>();
             
               internal struct ComplexType {
                 [PersistentField("val1", group = "nevermind")]
                 public bool boolVal;
                 [PersistentField("val2")]
                 public Color colorVal;
               }
             
               [PersistentField("my/setField", isCollection = true, group = "abc")]
               private HashSet<ComplexType> sampleSet = new HashSet<ComplexType>();
             
               void SaveConfigs() {
                 // Save a default group of fields: only field "sampleList" qualifies.
                 ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: this);
                 /* The following structure in the file will be created:
                  * {
                  *   my
                  *   {
                  *     listField: string1
                  *     listField: string2
                  *   }
                  * }
                  */
             
                 // Save a specific group of fields: only field "sampleSet" belongs to group "abc".
                 sampleSet.Add(new ComplexType() { boolVal = true, colorVal = Color.black });
                 sampleSet.Add(new ComplexType() { boolVal = false, colorVal = Color.white });
                 ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: this, group: "abc");
                 /* The following structure in the file will be created:
                  * {
                  *     setField
                  *     {
                  *       val1: True
                  *       val2: 0,0,0,1
                  *     }
                  *     setField
                  *     {
                  *       val1: false
                  *       val2: 1,1,1,1
                  *     }
                  *   }
                  * }
                  */
               }
             }
             ]]></code>
             <para>
             Note that the group is ignored in the nested types. I.e. in <c>ComplexType</c> in this case.
             However, if <c>ComplexType</c> was an immediate target of the <c>WriteFieldsIntoFile</c> call
             then the group would be considered.
             </para>
             <para>
             Visibility of the annotated field is also important. The persistent field attributes are only
             visible in the child class if they were public or protected in the parent. The private field
             annotations are not inherited and need to be handled at the level of the declaring class.
             </para>
             <code><![CDATA[
             class Parent {
               [PersistentField("parent_private")]
               private int field1 = 1;
             
               [PersistentField("parent_protected")]
               protected int field2 = 2;
             
               [PersistentField("parent_public")]
               public int field3 = 3;
             }
             
             class Child : Parent {
               [PersistentField("child_private")]
               private int field1 = 10;
             
               void SaveConfig() {
                 // Save all fields in the inherited type. 
                 ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: this);
                 /* The following structure in the file will be created:
                  * {
                  *     parent_protected: 2
                  *     parent_public: 3
                  *     child_private: 10
                  * }
                  */
             
                 // Save all fields in the base type. 
                 ConfigAccessor.WriteFieldsIntoFile("settings.cfg", instance: (Parent) this);
                 /* The following structure in the file will be created:
                  * {
                  *     parent_private: 1
                  *     parent_protected: 2
                  *     parent_public: 3
                  * }
                  */
               }
             }
             ]]></code>
             <para>
             The code above implies that in a common case unsealed class should put the private fields in a
             group other than default to avoid settings collision.
             </para>
             <para>
             When the type of the field is different from a primitive C# type or a common Unity 4 type you
             may need to provide a custom value handler to deal with (de)serializing. E.g. for an ordinary
             type it may look like this:
             </para>
             <code><![CDATA[
             class CustomType {
               [PersistentField("my/custom/type", ordinaryTypeProto = typeof(MyTypeProto))]
               private MyType field1;
             }
             ]]></code>
             <para>
             Or your custom class can implement a KSP interface <see cref="T:IConfigNode"/>, and it will be
             invoked during the field saving and restoring.
             </para>
             <code><![CDATA[
             class NodeCustomType : IConfigNode {
               public virtual void Save(ConfigNode node) {
               }
               public virtual void Load(ConfigNode node) {
               }
             }
             ]]></code>
             <para>
             It's important to note that complex (a.k.a. "compound") types like this are only handled when
             the field's value is not <c>null</c>. I.e. in the following example the value of <c>field1</c>
             will not be restored even if there is a node in the config file:
             </para>
             <code><![CDATA[
             class MyModule : PartModule {
               [PersistentField("field1")]
               public NodeCustomType field1;
            
               [PersistentField("field2")]
               public NodeCustomType field2 = new NodeCustomType();
             }
             ]]></code>
             <para>
             In case of your type is really simple, and you can serialize it into a plain string, you may
             choose to implement <see cref="T:KSPDev.ConfigUtils.IPersistentField"/> instead. It works in a similar way but the
             source/target of the persistense is a string instead of a config node. Simple types deal with
             <c>null</c>'s in a different way (read the docs for the interface).
             </para>
             <para>
             If your custom type is a collection that cannot be handled by the standard proto you can provide
             your own collection proto handler. Note that if you do then the annotated field will be treated
             as a collection. In fact, when you set <c>isCollection = true</c> what actually happens is just
             assigning <see cref="T:KSPDev.ConfigUtils.GenericCollectionTypeProto"/> as a collection proto handler.
             </para>
             <code><![CDATA[
             class CustomTypes {
               [PersistentField("my/custom/type", collectionTypeProto = typeof(MyCollectionProto))]
               private MyCollection field1;
             }
             ]]></code>
             For more examples on custom proto handlers see <see cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/> and
             <see cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>.
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.ConfigAccessor"/>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractOrdinaryValueTypeProto"/>
             <seealso cref="T:KSPDev.ConfigUtils.AbstractCollectionTypeProto"/>
             <seealso cref="T:KSPDev.ConfigUtils.IPersistentField"/>
             <seealso href="https://kerbalspaceprogram.com/api/interface_i_config_node.html">KSP: IConfigNode</seealso>
        </member>
        <member name="M:KSPDev.ConfigUtils.PersistentFieldAttribute.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="P:KSPDev.ConfigUtils.PersistentFieldAttribute.ordinaryTypeProto">
            <summary>A proto for handling the annotated field.</summary>
            <remarks>If field is a collection then this proto will be used to handle values of the
            collection items.</remarks>
        </member>
        <member name="P:KSPDev.ConfigUtils.PersistentFieldAttribute.collectionTypeProto">
            <summary>A proto for handling collection fields.</summary>
            <remarks>If this property is not <c>null</c> than the annotated field is trreated as a
            collection of values.</remarks>
        </member>
        <member name="P:KSPDev.ConfigUtils.PersistentFieldAttribute.isCollection">
            <summary>Specifies if the annotated field is a collection of values.</summary>
        </member>
        <member name="T:KSPDev.ConfigUtils.KspTypesProto">
            <summary>A proto for handling all KSP specific types.</summary>
        </member>
        <member name="M:KSPDev.ConfigUtils.KspTypesProto.CanHandle(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.KspTypesProto.SerializeToString(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.ConfigUtils.KspTypesProto.ParseFromString(System.String,System.Type)">
            <inheritdoc/>
        </member>
        <member name="T:KSPDev.Extensions.Dictionaries">
            <summary>Helper extensions for generic dictionary container.</summary>
        </member>
        <member name="M:KSPDev.Extensions.Dictionaries.SetDefault``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Returns a value from dictionary by the key. If key is not defined yet then a new default entry
            is created and returned.
            </summary>
            <example>
            It's most useful when dealing with dictionaries of a complex type:
            <code><![CDATA[
            var a = new Dictionary<int, HashSet<string>>();
            // An empty string set for key 1 is created, and "abc" is added in it.
            a.SetDefault(1).Add("abc");
            // "def" is added into existing string set at key 1. 
            a.SetDefault(1).Add("def");
            ]]></code>
            </example>
            <param name="dict">Dictionary to get value from.</param>
            <param name="key">Key to lookup.</param>
            <typeparam name="K">Type of the dictionary key.</typeparam>
            <typeparam name="V">Type of the dictionary value.</typeparam>
            <returns>Either an existing value for the key or a default instance of the value.</returns>
        </member>
        <member name="T:KSPDev.FSUtils.KspPaths">
            <summary>A helper class to deal with plugins file structure.</summary>
        </member>
        <member name="F:KSPDev.FSUtils.KspPaths.pluginsRootFolder">
            <summary>Standard plug-ins folder.</summary>
        </member>
        <member name="M:KSPDev.FSUtils.KspPaths.MakeAbsPathForGameData(System.String[])">
            <summary>
            Makes full absolute path from the provided relative path in the game's <c>GameData</c> folder.
            </summary>
            <remarks>
            If joining of all the provided parts gives a full path then it's only normalized. In case of
            path is relative it's resolved against game's <c>GameData</c> folder.
            <para>Note that method doesn't care if the path exists.</para>
            </remarks>
            <param name="pathParts">Path parts for an absolute or relative path.</param>
            <returns>
            Absolute path. All relative casts (e.g. '..') will be resolved, and all
            directory separators will be translated to the platform format (e.g. '/' will become '\' on
            Windows). 
            </returns>
        </member>
        <member name="M:KSPDev.FSUtils.KspPaths.NormalizePath(System.String)">
            <summary>
            Normalizes path by resolving all upcasts. Works for both relative and absolute paths.
            </summary>
            <remarks>Note that method doesn't care if the path exists.</remarks>
            <param name="path">Path to normalize.</param>
            <returns>
            Path with no <c>.</c> or <c>..</c> casts. All directory separators will be translated to
            <c>/</c> regardless to the platform settings.
            </returns>
            <seealso cref="M:KSPDev.FSUtils.KspPaths.MakeRelativePathToGameData(System.String[])"/>
        </member>
        <member name="M:KSPDev.FSUtils.KspPaths.MakeRelativePathToGameData(System.String[])">
            <summary>Returns path relative to the game's GameData folder.</summary>
            <remarks>
            Note that method doesn't care if the path exists. The returned path will always use <c>/</c>
            as directory separator regardless to the platform.
            </remarks>
            <param name="pathParts">Path parts tp consutruct an absolute or relative path.</param>
            <returns>
            Relative path. All relative casts (e.g. '..') will be resolved, and all
            directory separators will be translated to <c>/</c> regardless to the platform settings.
            </returns>
            <example>
            Let's say mod's exact location is not known (e.g. as it is for MiniAVC) and the mod needs to
            load a texture. In order to do it the mod needs to know a <c>GameData</c> relative path which
            can be used as a prefix to the texture. Below is a sample code that figures it out.
            <code><![CDATA[
            var assembly = Assembly.GetExecutingAssembly();
            var relPath = KspPaths.MakeRelativePathToGameData(assembly.Location);
            Debug.LogWarningFormat("Assembly {0} is loaded from {1}", assembly.FullName, relPath);
            // Pretend the mod's DLL lives in 'Plugins' subfolder.
            var textureFolder = KspPaths.NormalizePath(Path.GetDirectoryName(relPath) + "/../Textures");
            // Get a texture from 'Textures' folder that lives in the mods's root.
            var texture = GameDatabase.Instance.GetTexture(textureFolder + "/MyTexture.png", false);
            ]]></code>
            </example>
            <seealso cref="M:KSPDev.FSUtils.KspPaths.NormalizePath(System.String)"/>
        </member>
        <member name="P:KSPDev.FSUtils.KspPaths.pluginsRoot">
            <summary>Returns full path to the plugins root folder (a.k.a. <c>GameData</c>).</summary>
        </member>
        <member name="T:KSPDev.GUIUtils.Formatter">
            <summary>Helper to format various values.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.Formatter.SpecialValue(System.Single,System.String,System.Single,System.String)">
            <summary>Formats float number that has special meaning for a predefined value.</summary>
            <param name="number">Number to format.</param>
            <param name="fmt">Format string for the number.</param>
            <param name="specialValue">Special value of the number.</param>
            <param name="specialString">String to show for the special value.</param>
            <returns>Formatted string.</returns>
            <example>
            <code><![CDATA[
            var fmt = "Value: {0}";
            var spcFmt = "SPECIAL VALUE!";
            Debug.LogFormat(Formatter.SpecialValue(0.5f, fmt, 0.5f, spcFmt);
            // Outputs:
            // SPECIAL VALUE!
            Debug.LogFormat(Formatter.SpecialValue(0.4f, fmt, 0.5f, spcFmt);
            // Outputs:
            // Value: 0.4
            ]]></code>
            </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Formatter.SpecialValue(System.Int32,System.String,System.Int32,System.String)">
            <summary>Formats integer number that has special meaning for a predefined value.</summary>
            <param name="number">Number to format.</param>
            <param name="fmt">Format string for the number.</param>
            <param name="specialValue">Special value of the number.</param>
            <param name="specialString">String to show for the special value.</param>
            <returns>Formatted string.</returns>
            <example>
            <code><![CDATA[
            var fmt = "Value: {0}";
            var spcFmt = "SPECIAL VALUE!";
            Debug.Log(Formatter.SpecialValue(100, fmt, 100, spcFmt);
            // Outputs:
            // SPECIAL VALUE!
            Debug.Log(Formatter.SpecialValue(101, fmt, 100, spcFmt);
            // Outputs:
            // Value: 101
            ]]></code>
            </example>
        </member>
        <member name="T:KSPDev.GUIUtils.MessageBoolValue">
             <summary>A class to wrap a UI string for a boolean value.</summary>
             <remarks>
             <para>
             When string needs to be presented use <see cref="M:KSPDev.GUIUtils.MessageBoolValue.Format(System.Boolean)"/> to make the parameter substitute.
             </para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>MessageBoolValue</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               static readonly MessageBoolValue SwitchMsg = new MessageBoolValue("ON", "OFF");
               static readonly MessageBoolValue StateMsg = new MessageBoolValue("Enabled", "Disabled");
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", SwitchMsg.Format(true));  // ON
                 Debug.LogFormat("Localized: {0}", StateMsg.Format(false));  // Disabled
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageBoolValue.#ctor(System.String,System.String)">
            <summary>Creates a message.</summary>
            <param name="positiveStr">Message string for <c>true</c> value.</param>
            <param name="negativeStr">Message string for <c>false</c> value.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageBoolValue.Format(System.Boolean)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.MessageEnumValue`1">
             <summary>A class to wrap a UI string for an enum value.</summary>
             <typeparam name="T">Enum type to define the strings for.</typeparam>
             <remarks>
             <para>
             When a string needs to be presented, use <see cref="M:KSPDev.GUIUtils.MessageEnumValue`1.Format(`0)"/> to make the parameter substitute.
             </para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of doing switches when an enum value should be presented on UI, just define a message
             that declares a map between the values and their UI representations. You don't need to specify
             every single value in the map, there is an option to set a UI string for an unknown value.  
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               enum MyEnum {
                 Disabled,
                 Enabled,
                 UnusedValue1,
                 UnusedValue2,
                 UnusedValue3,
               }
            
               // Lookup with a custom value for an unknown key.
               static readonly MessageEnumValue<MyEnum> Msg1 =
                   new MessageEnumValue<MyEnum>("UNKNOWN") {
                     {MyEnum.Enabled, "ENABLED"},
                     {MyEnum.Disabled, "DISABLED"},
                   };
            
               // A more extended lookup.
               static readonly MessageEnumValue<MyEnum> Msg2 =
                   new MessageEnumValue<MyEnum>() {
                     {MyEnum.Enabled, "ENABLED"},
                     {MyEnum.Disabled, "DISABLED"},
                     {MyEnum.UnusedValue1, "Value1"},
                     {MyEnum.UnusedValue2, "Value2"},
                   };
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", Msg1.Format(MyEnum.Disabled));  // DISABLED
                 Debug.LogFormat("Localized: {0}", Msg1.Format(MyEnum.UnusedValue1));  // UNKNOWN
            
                 Debug.LogFormat("Localized: {0}", Msg2.Format(MyEnum.UnusedValue1));  // Value1
                 Debug.LogFormat("Localized: {0}", Msg2.Format(MyEnum.UnusedValue2));  // Value2
                 Debug.LogFormat("Localized: {0}", Msg2.Format(MyEnum.UnusedValue3));  // "" (null)
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.#ctor(System.String)">
            <summary>Creates an empty message with a default value for the unknown entries.</summary>
            <param name="unknownKeyValue">
            Value to return if the lookup dictionary doesn't have the requested key.
            </param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.GetEnumerator">
            <summary>Returns a key/pair enumerator.</summary>
            <returns>Key/value enumerator.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.Add(`0,System.String)">
            <summary>Adds a new lookup for the key.</summary>
            <param name="key">Unique key.</param>
            <param name="value">GUI string for the key.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.Format(`0)">
            <summary>Formats a message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageEnumValue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an untyped key/value enumerator.</summary>
            <returns>Key/value enumerator.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.MessageSpecialFloatValue">
             <summary>
             A class to wrap a UI string with one parameter which may have special meaning.
             </summary>
             <remarks>
             <para>When string needs to be presented use <see cref="M:KSPDev.GUIUtils.MessageSpecialFloatValue.Format(System.Single)"/> to make the parameter
             substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               MessageSpecialFloatValue MyMessage =
                   new MessageSpecialFloatValue("Param: {0}", 0, "Param is ZERO");
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format(1));  // Param: 1
                 Debug.LogFormat("Localized: {0}", MyMessage.Format(0));  // Param is ZERO
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageSpecialFloatValue.#ctor(System.String,System.Single,System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
            <param name="specialValue">Value to use a special message string for.</param>
            <param name="specialString">Special message string for the value.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.MessageSpecialFloatValue.Format(System.Single)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.ScreenMessaging">
            <summary>Helper class to present global UI messages.</summary>
            <remarks>The actual representation of the different priority messages depends on the KSP
            version. As a rule of thumb use the following reasons when deciding how to show a message:
            <list>
            <item>Important messages should be show as "priority". It's assumed that UI layout is build so
                what that such messages won't be missed.</item>
            <item>Messages that only give status update and can be safely ignored by the player should be
                reported as "info". They will show up in UI but not necessarily bring user's attention.
                </item>
            </list>
            </remarks>
            <example>
            <code>
            class MyMod : MonoBehaviour {
              void Update() {
                if (Input.GetKeyDown("1")) {
                  ScreenMessaging.ShowPriorityScreenMessage("Key pressed in frame #{0}", Time.frameCount);
                }
              }
            }
            </code>
            </example>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.DefaultMessageTimeout">
            <summary>Default timeout for a regular UI message.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.DefaultErrorTimeout">
            <summary>Default timeout for a UI message that reports an error.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.DefaultWarningTimeout">
            <summary>Default timeout for a UI message that warns about unusual conditions.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.ErrorColor">
            <summary>Default color for the error messages.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.ScreenMessaging.WarningColor">
            <summary>Default color for the warning messages.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.SetColorToRichText(System.String,UnityEngine.Color)">
            <summary>Wraps string into Unity rich-text tags to set a color.</summary>
            <remarks>Note, that Unity rich-text is not the same as RTF specification.</remarks>
            <param name="str">String to wrap.</param>
            <param name="color">Color to apply to the string.</param>
            <returns>Unity rich-text string.</returns>
            <seealso href="https://docs.unity3d.com/Manual/StyledText.html">
            Unity 3D: Rich-Text styled text</seealso>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowScreenMessage(ScreenMessageStyle,System.Single,System.String,System.Object[])">
            <summary>Shows a formatted message with the specified location and timeout.</summary>
            <param name="style">A <c>ScreenMessageStyle</c> specifier.</param>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_screen_messages.html">
            KSP: ScreenMessages</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/_screen_messages_8cs.html#ac19a4c3800d327889475848ccbbf9317">
            KSP: ScreenMessageStyle</seealso>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowScreenMessage(ScreenMessageStyle,System.Single,UnityEngine.Color,System.String,System.Object[])">
            <summary>Shows a formatted message with the specified location and timeout.</summary>
            <param name="style"><see cref="T:ScreenMessageStyle"/> specifier.</param>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="color">Color to apply on the string.</param>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_screen_messages.html">
            KSP: ScreenMessages</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/_screen_messages_8cs.html#ac19a4c3800d327889475848ccbbf9317">
            KSP: ScreenMessageStyle</seealso>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowPriorityScreenMessageWithTimeout(System.Single,System.String,System.Object[])">
            <summary>Shows an important message with the specified timeout.</summary>
            <remarks>It's no defined how exactly the message is shown. The only thing required is that
            player won't miss it.</remarks>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="fmt">A formatting string.</param>
            <param name="args">Arguments for the formatting string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowPriorityScreenMessage(System.String,System.Object[])">
            <summary>Shows an important message with a default timeout.</summary>
            <remarks>It's no defined how exactly the message is shown. The only thing required is that
            player won't miss it.</remarks>
            <param name="fmt">A formatting string.</param>
            <param name="args">Arguments for the formatting string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowInfoScreenMessageWithTimeout(System.Single,System.String,System.Object[])">
            <summary>Shows an info message with the specified timeout.</summary>
            <remarks>It's no defined how exactly the message is shown.</remarks>
            <param name="duration">Delay before hiding the message in seconds.</param>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowInfoScreenMessage(System.String,System.Object[])">
            <summary>Shows an info message with a default timeout.</summary>
            <remarks>It's no defined how exactly the message is shown.</remarks>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowErrorScreenMessage(System.String,System.Object[])">
            <summary>Shows an error message with a default timeout.</summary>
            <remarks>
            It's no defined how exactly the message is shown, but it's guaranteed it looks like an error
            and player will perceive it like that.
            </remarks>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.ScreenMessaging.ShowWarningScreenMessage(System.String,System.Object[])">
            <summary>Shows a warning message with a default timeout.</summary>
            <remarks>
            It's no defined how exactly the message is shown, but it's guaranteed it looks like an error
            and player will perceive it like that.
            </remarks>
            <param name="fmt"><c>string.Format()</c> formatting string.</param>
            <param name="args">Arguments for the formattign string.</param>
        </member>
        <member name="T:KSPDev.GUIUtils.HintOverlay">
             <summary>A wrapper class to present simple overlay window with text.</summary>
             <remarks>
             <para>Overlay windows doesn't have border or title. Main purpose of such windows is "hints".
             I.e. short lived piece of information presented for the current context. The hint won't be shown
             in UI until explicitly requsted via call to a <c>ShowAt*</c> method.</para>
             <para>Keep in mind that this window contains graphics objects that will be destroyed on scene
             re-loading. I.e. it must be re-created on every scene change.</para>
             </remarks>
             <example>
             In a common case initialization of the hint window is done on the game object awakening, and
             it's either shown or hidden in <c>OnGUI</c> method.
             <code>
             class MyMod : MonoBehaviour {
               HintOverlay hint;
            
               void Awake() {
                 hint = new HintOverlay(12, 3, Color.white, new Color(0f, 0f, 0f, 0.5f));
               }
            
               void OnGUI() {
                 hint.text = string.Format("Current frame is: {0}", Time.frameCount);
                 hint.ShowAtCursor();
               }
             }
             </code>
             <para>In the example above text of the hint is set on every frame update since frame count is updated
             this frequently. Though, if your data is updated less frequently you may save some performance
             by updating text in the methods different from <c>OnGUI</c>.</para>
             </example>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.BackgroundTextureSize">
            <summary>Size of the sample texture that fills hint window backgroud.</summary>
            <remarks>Small values may impact rendering performance. Large values will increase memory
            footpring. Choose it wise.</remarks>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.RightSideMousePadding">
            <summary>Padding when showing hint on the right side of the mouse cursor.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.LeftSideMousePadding">
            <summary>Padding when showing hint on the left side of the mouse cursor.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.textSize">
            <summary>Precalculated UI text size for the currently assigned text.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.HintOverlay.hintWindowStyle">
            <summary>Precalculated style for the hint overlay window.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.#ctor(System.Int32,System.Int32,UnityEngine.Color,UnityEngine.Color)">
            <summary>Constructs an overaly.</summary>
            <param name="fontSize">Size of the text font in the hint.</param>
            <param name="padding">Padding between the text and the window boundaries.</param>
            <param name="textColor">Color of the hint text.</param>
            <param name="backgroundColor">Color of the hint background. If alpha component is different
            from <c>1.0</c> then background will be semi-transparent.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.ShowAtCursor">
            <summary>Shows hint text at the current mouse pointer.</summary>
            <remarks>When possible the window is shown on the right side of the cursor. Though, if part of
            the window goes out of the screen then it will be shown on the left side. If bottom boundary
            of the window hits bottom boundary of the screen then hint is aligned vertically so what the
            full content is visible. </remarks>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.ShowAtPosition(System.Single,System.Single)">
            <summary>Shows hint at the absolute screen position.</summary>
            <remarks>If hint content goes out of the screen it's clipped.</remarks>
            <param name="x">X position is screen coordinates.</param>
            <param name="y">Y position is screen coordinates.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.HintOverlay.CreateSampleTextureFromColor(UnityEngine.Color)">
            <summary>Creates a clear color texture to fill background with.</summary>
            <param name="color">A background color.</param>
            <returns>Texture of a default size.</returns>
        </member>
        <member name="P:KSPDev.GUIUtils.HintOverlay.text">
            <summary>The hint overlay text.</summary>
            <remarks>Linefeed symbols are correctly handled. Use them to make multiline content. Setting
            text is an expensive operation since it results in window size recalculation. Don't update it
            more frequently than the underlaying data does.</remarks>
        </member>
        <member name="T:KSPDev.GUIUtils.Message">
             <summary>A class to wrap a simple UI string.</summary>
             <remarks>
             <para>Messages of this type don't have parameters and can be just casted to a string.</para> 
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message MyMessage = "This is a message without parameters";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage);
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="messageString">A message string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message.op_Implicit(System.String)~KSPDev.GUIUtils.Message">
            <summary>Allows casting string to message.</summary>
            <remarks>Instead of creating new insatnce for every string just do the cast as it was a
            regular literal constant.</remarks>
            <param name="messageString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message.op_Implicit(KSPDev.GUIUtils.Message)~System.String">
            <summary>Allows casting messages to string.</summary>
            <param name="msg">A message to cast.</param>
            <returns>Message value.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`1">
             <summary>A class to wrap a UI string with one parameter.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter type via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`1.Format(`0)"/> to make the parameter substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string> MyMessage = "Param: {0}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!"));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`1.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`1.Format(`0)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`1.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`2">
             <summary>A class to wrap a UI string with two parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`2.Format(`0,`1)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int> MyMessage = "Params: {0}, {1}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`2.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`2.Format(`0,`1)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`2.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`3">
             <summary>A class to wrap a UI string with three parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <typeparam name="T3">Type of the third substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`3.Format(`0,`1,`2)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int, float> MyMessage = "Params: {0}, {1}, {2}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123, 321f));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`3.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`3.Format(`0,`1,`2)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <param name="arg3">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`3.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1,`2}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`4">
             <summary>A class to wrap a UI string with four parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <typeparam name="T3">Type of the third substitute argument in the string.</typeparam>
             <typeparam name="T4">Type of the fourth substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`4.Format(`0,`1,`2,`3)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int, float, int> MyMessage = "Params: {0}, {1}, {2}, {3}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123, 321f, 456));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`4.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`4.Format(`0,`1,`2,`3)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <param name="arg3">An argument to substitute.</param>
            <param name="arg4">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`4.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1,`2,`3}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.Message`5">
             <summary>A class to wrap a UI string with five parameters.</summary>
             <typeparam name="T1">Type of the first substitute argument in the string.</typeparam>
             <typeparam name="T2">Type of the second substitute argument in the string.</typeparam>
             <typeparam name="T3">Type of the third substitute argument in the string.</typeparam>
             <typeparam name="T4">Type of the fourth substitute argument in the string.</typeparam>
             <typeparam name="T5">Type of the fifth substitute argument in the string.</typeparam>
             <remarks>
             <para>Define parameter types via generic argument. When string needs to be presented use
             <see cref="M:KSPDev.GUIUtils.Message`5.Format(`0,`1,`2,`3,`4)"/> to make parameters substitute.</para>
             <para>
             In the future it may support localization but for now it's only a convinience wrapper.
             </para>
             </remarks>
             <example>
             Instead of presenting hardcoded strings on UI move them all into a special section, and assign
             to fields of type <c>Message</c>.
             <code><![CDATA[
             class MyMod : MonoBehaviour {
               Message<string, int, float, int, float> MyMessage = "Params: {0}, {1}, {2}, {3}, {4}";
            
               void Awake() {
                 Debug.LogFormat("Localized: {0}", MyMessage.Format("Blah!", 123, 321f, 456, 456f));
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`5.#ctor(System.String)">
            <summary>Creates a message.</summary>
            <param name="fmtString">A message format string.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`5.Format(`0,`1,`2,`3,`4)">
            <summary>Formats message string with the provided arguments.</summary>
            <param name="arg1">An argument to substitute.</param>
            <param name="arg2">An argument to substitute.</param>
            <param name="arg3">An argument to substitute.</param>
            <param name="arg4">An argument to substitute.</param>
            <param name="arg5">An argument to substitute.</param>
            <returns>Complete message string.</returns>
        </member>
        <member name="M:KSPDev.GUIUtils.Message`5.op_Implicit(System.String)~KSPDev.GUIUtils.Message{`0,`1,`2,`3,`4}">
            <summary>Allows casting strings to message.</summary>
            <param name="fmtString">A string value to assign.</param>
            <returns>Message instance.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.GuiActionsList">
             <summary>A helper to accumulate GUI actions.</summary>
             <remarks>Unity may issue multiple GUI passes during a frame, and it requires number of UI
             elements not to change between the passes. Unity expects the number of UI
             controls in every pass to be exactly the same as in the very first one:
             <see href="http://docs.unity3d.com/ScriptReference/EventType.Layout.html">EventType.Layout</see>.
             When UI interactions affect representation all the changes must be postponed till the frame
             rendering is ended. This helper can be used to store actions that will be executed at the
             beginning of the next frame.</remarks>
             <example>
             <code>
             public class MyUI : MonoBehaviour {
               private readonly GuiActionsList guiActions = new GuiActionsList();
               private bool showLabel = false;
            
               void OnGUI() {
                 if (guiActions.ExecutePendingGuiActions()) {
                   // ...do other stuff that affects UI... 
                 }
            
                 if (GUILayout.Button(new GUIContent("Test Button"))) {
                   // If "showLabel" is changed right here then Unity GUI will complain saying the number
                   // of UI controls has changed. So, postpone the change until current frame is ended.
                   guiActions.Add(() => {
                     showLabel = !showLabel;  // This will be done at the beginning of the next frame.
                   });
                 }
                 
                 if (showLabel) {
                   GUILayout.Label("Test label");
                 }
               }
             }
             </code>
             <para>If you were using simple approach and updated <c>showLabel</c> right away Unity would
             likely thrown an error like this:</para>
             <para><c>[EXCEPTION] ArgumentException: Getting control 1's position in a group with only 1
             controls when doing Repaint</c></para>
             <seealso href="http://docs.unity3d.com/Manual/GUIScriptingGuide.html"/>
             <seealso href="http://docs.unity3d.com/ScriptReference/EventType.html"/>
             </example>
        </member>
        <member name="F:KSPDev.GUIUtils.GuiActionsList.guiActions">
            <summary>A list of pending actions.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.GuiActionsList.Add(KSPDev.GUIUtils.GuiActionsList.GuiAction)">
            <summary>Adds an action to the pending list.</summary>
            <param name="actionFn">An action callback.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.GuiActionsList.ExecutePendingGuiActions">
            <summary>Executes actions when it's safe to do the changes.</summary>
            <remarks>It's safe to call this method in every pass. It will detect when it's safe to apply
            the changes and apply the changes only once per a frame.</remarks>
            <returns><c>true</c> if actions have been applied.</returns>
        </member>
        <member name="T:KSPDev.GUIUtils.GuiActionsList.GuiAction">
            <summary>GUI action type.</summary>
        </member>
        <member name="T:KSPDev.GUIUtils.UISoundPlayer">
             <summary>Helper class to play sounds in game GUI. Such sounds are not 3D aligned.</summary>
             <remarks>
             Use this player when soucre of the sound is player keyboard actions or a mouse pointer. This
             class implements all the boilerplate to load and play sound resources.
             </remarks>
             <example>
             Here is an example of playing two different sounds on pressing "O" or "P" keys.
             <code><![CDATA[
             class MyModule : PartModule {
               public override OnAwake() {
                 // We don't want to loose latency on "ooo.ogg" playing.
                 UISoundPlayer.instance.CacheSound("ooo.ogg");
               }
            
               public override OnUpdate() {
                 if (Input.GetKeyDown("O")) {
                   UISoundPlayer.instance.Play("ooo.ogg");  // Played from cache. No delay.
                 }
                 if (Input.GetKeyDown("P")) {
                   UISoundPlayer.instance.Play("ppp.ogg");  // May delay game while loading the resource.
                 }
               }
             }
             ]]></code>
             </example>
        </member>
        <member name="F:KSPDev.GUIUtils.UISoundPlayer.instance">
            <summary>Returns instance for the current scene.</summary>
        </member>
        <member name="F:KSPDev.GUIUtils.UISoundPlayer.audioCache">
            <summary>Global scene cache for all the sounds.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.Play(System.String,System.Boolean)">
            <summary>Plays the specified sound.</summary>
            <remarks>
            Every request is cached unless requested otherwise. Subsequent calls to the play method won't
            require audio clip loading.
            </remarks>
            <param name="audioPath">File path relative to <c>GameData</c>.</param>
            <param name="dontCache">If <c>true</c> then audio will not be cached.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.CacheSound(System.String)">
            <summary>Loads the sound into cache but doesn't play it.</summary>
            <remarks>
            Use this method when sound is expected to frequently played in the scene. If it worth spending
            a bit more time in the loading to win some latency during the play time then it pre-caching
            sounds is a good idea.
            </remarks>
            <param name="audioPath">File path relative to <c>GameData</c>.</param>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.Awake">
            <summary>Initializes <see cref="F:KSPDev.GUIUtils.UISoundPlayer.instance"/>.</summary>
        </member>
        <member name="M:KSPDev.GUIUtils.UISoundPlayer.GetOrLoadAudio(System.String,System.Boolean)">
            <summary>Loads audio sample and plays it.</summary>
            <param name="audioPath">File path relative to <c>GameData</c>.</param>
            <param name="dontCache">If <c>true</c> then audio will not be cached.</param>
            <returns>Audio resource if loaded or found in the cache, otherwise <c>null</c>.</returns>
        </member>
        <member name="T:KSPDev.InputUtils.KeyModifiers">
            <summary>Flags to specify key modifiers combination.</summary>
            <remarks>Modifiers can be joined to get a combination. E.g. <c>AnyAlt | AnyShift</c>.</remarks>
            <seealso cref="M:KSPDev.InputUtils.EventChecker.IsModifierCombinationPressed(KSPDev.InputUtils.KeyModifiers)"/>
        </member>
        <member name="F:KSPDev.InputUtils.KeyModifiers.None">
            <summary>No modifier keys are pressed.</summary>
            <remarks>This value only makes sense when used alone. Combining it with any other value
            will result in ignoring value <c>None</c>.</remarks>
        </member>
        <member name="F:KSPDev.InputUtils.KeyModifiers.AnyAlt">
            <summary>Left or right ALT key pressed.</summary>
        </member>
        <member name="F:KSPDev.InputUtils.KeyModifiers.AnyShift">
            <summary>Left or right SHIFT key pressed.</summary>
        </member>
        <member name="F:KSPDev.InputUtils.KeyModifiers.AnyControl">
            <summary>Left or right CONTROL key pressed.</summary>
        </member>
        <member name="T:KSPDev.InputUtils.EventChecker">
            <summary>A helper to verify various event handling conditions.</summary>
        </member>
        <member name="M:KSPDev.InputUtils.EventChecker.IsModifierCombinationPressed(KSPDev.InputUtils.KeyModifiers)">
            <summary>Verifies that the requested key modifiers are pressed.</summary>
            <remarks>The check will succeed only if the exact set of modifier keys is pressed. If there
            are more or less modifiers pressed the check will fail. E.g. if there are <c>LeftAlt</c> and
            <c>LeftShift</c> pressed but the check is executed against
            <c>AnyShift</c> then it will fail. Though, checking for <c>AnyShift | AnyAlt</c> will succeed.
            <para>In case of checking for <c>None</c> the check will require no modifier keys to be
            pressed. If you deal with mouse button events it's a good idea to verify if no modifiers are
            pressed even if you don't care about other combinations. It will let other modders to use
            mouse buttons and not to interfere with your mod.</para>
            </remarks>
            <param name="modifiers">A combination of key modifiers to verify.</param>
            <returns><c>true</c> when exactly the requested combination is pressed.</returns>
            <seealso cref="T:KSPDev.InputUtils.KeyModifiers"/>
        </member>
        <member name="T:KSPDev.InputUtils.KeyboardInputSwitch">
             <summary>
             Wrapper around keyboard key code that incapsulates persiting and handling into a single class.  
             </summary>
             <remarks>
             Fields of this type are correctly handled by <see cref="T:KSPField"/> and
             <see cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/> attributes.
             </remarks>
             <example>
             <para>
             To define a key binding just create a class with the key code as a parameter and notify the
             switch about frame updates so what it could update its state:
             </para>
             <code><![CDATA[
             class MyClass : MonoBehaviour {
               KeyboardInputSwitch mySwitch = new KeyboardInputSwitch(KeyCode.Alpha1);
            
               void Update() {
                 if (mySwitch.Update()) {
                   Debug.Log("The key is being hold");
                 }
               }
             }
             ]]></code>
             <para>
             In case of switch state needs to be checked from other methods use <see cref="P:KSPDev.InputUtils.KeyboardInputSwitch.isHold"/>
             property:
             </para>
             <code><![CDATA[
             class MyClass : MonoBehaviour {
               KeyboardInputSwitch mySwitch = new KeyboardInputSwitch(KeyCode.Alpha1);
            
               void Update() {
                 mySwitch.Update();
               }
            
               void FixedUpdate() {
                 if (mySwitch.isHold) {
                   Debug.Log("The key is being hold");
                 }
               }
             }
             ]]></code>
             <para>
             When code needs to react to the event of changing switch state it can register for the state
             change event:
             </para>
             <code><![CDATA[
             class MyClass : MonoBehaviour {
               KeyboardInputSwitch mySwitch = new KeyboardInputSwitch(KeyCode.Alpha1);
            
               void Awake() {
                 mySwitch.OnStateChanged += OnSwitchStateChange;
                 mySwitch.OnPress += delegate{
                   Debug.Log("Key pressed");
                 };
                 mySwitch.OnRelease += delegate{
                   Debug.Log("Key is released");
                 };
                 mySwitch.OnClick += delegate{
                   Debug.Log("Key click registered");
                 };
               }
            
               void OnDestroy() {
                 // Do nothing since in this example switch is an instance field, and it will be destroyed
                 // together with the owning class (and, hence, all the listeners).
                 // Though, if it was a static field we would do something like this:
                 mySwitch.OnStateChanged -= OnSwitchStateChange;
                 // Anonymous functions cannot be unregistered, so don't use them on static fields.
               }
            
               void OnSwitchStateChange() {
                 Debug.LogFormat("Switch state changed to: {0}", mySwitch.isHold);
               }
            
               void Update() {
                 mySwitch.Update();
               }
             }
             ]]></code>
             <para>
             In many cases you may want to load key bining from a config file. Due to switch supports
             KSP/KSPDev persistence it can easily be achieved by just adding an attribute:
             </para>
             <code><![CDATA[
             [PersistentFieldsFile("my/mod/settings.cfg", "")]
             class MyClass : PartModule {
               // Note that KSPField attributed fields *must* be public.
               [KSPField]
               public KeyboardInputSwitch switchFromPart = new KeyboardInputSwitch(KeyCode.Alpha1);
            
               // Note that for PersistentField attribute field doesn't need to be public.
               // Though, private fields are handled a bit differently (read the docs!).
               [PersistentField("Keyboard/Bindings")]
               KeyboardInputSwitch switchFromSettings = new KeyboardInputSwitch(KeyCode.Alpha2);
            
               public override void OnLoad(ConfigNode node) {
                 // At this point `switchFromPart` is already loaded from the part's config.
                 base.OnLoad(node);
                 // Load `switchFromSettings` via KSPDev from "my/mod/settings.cfg".
                 KSPDev.ConfigUtils.ConfigAccessor.ReadFieldsInType(typeof(MyClass), this);
               }
             }
             ]]></code>
             <para>Storing of the key binding works in a similar way.</para>
             </example>
             <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldsFileAttribute"/>
             <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">KSP: KSPField</seealso>
        </member>
        <member name="F:KSPDev.InputUtils.KeyboardInputSwitch.ClickDelay">
            <summary>Maximum delay to register click event.</summary>
            <remarks>Value used is the same as in KSP <see cref="T:KeyBinding"/>.</remarks>
            <seealso href="https://kerbalspaceprogram.com/api/class_key_binding.html">KSP: KeyBinding</seealso>
        </member>
        <member name="F:KSPDev.InputUtils.KeyboardInputSwitch.keyCode">
            <summary>Key code for the switch.</summary>
            <remarks>
            It can be changed in runtime but if hold state was <c>true</c> it must be reset by the caller.
            </remarks>
        </member>
        <member name="F:KSPDev.InputUtils.KeyboardInputSwitch.keyboardEnabled">
            <summary>
            Determines if switch should react on keyboard events from <see cref="M:KSPDev.InputUtils.KeyboardInputSwitch.Update"/> method. 
            </summary>
            <remarks>
            Note that if switch is disabled while the key was hold the hold state will <i>not</i> be
            reset. If state needs to be reset then caller must do it explicitly.
            </remarks>
        </member>
        <member name="F:KSPDev.InputUtils.KeyboardInputSwitch.lastPressTime">
            <summary>Last press event timestamp.</summary>
        </member>
        <member name="M:KSPDev.InputUtils.KeyboardInputSwitch.Load(ConfigNode)">
            <summary>
            Loads switch binding when field is attributed with KSP or KSPDev persisting attributes. 
            </summary>
            <param name="node">Node to get values from.</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">KSP: KSPField</seealso>
        </member>
        <member name="M:KSPDev.InputUtils.KeyboardInputSwitch.Save(ConfigNode)">
            <summary>
            Saves switch binding when field is attributed with KSP or KSPDev persisting attributes. 
            </summary>
            <param name="node">Node to get values from.</param>
            <seealso cref="T:KSPDev.ConfigUtils.PersistentFieldAttribute"/>
            <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">KSP: KSPField</seealso>
        </member>
        <member name="M:KSPDev.InputUtils.KeyboardInputSwitch.#ctor">
            <summary>
            Creates a switch with a <see cref="F:UnityEngine.KeyCode.None"/> key binding. It's a default constructor
            needed for config utils to work.
            </summary>
        </member>
        <member name="M:KSPDev.InputUtils.KeyboardInputSwitch.#ctor(UnityEngine.KeyCode)">
            <summary>Main constructor to create a switch for the provided key code.</summary>
            <param name="code">
            Key code to activate the switch. Can be <see cref="F:UnityEngine.KeyCode.None"/> in which case this switch
            can only be changed via code.
            </param>
        </member>
        <member name="M:KSPDev.InputUtils.KeyboardInputSwitch.Update">
            <summary>Checks keyboard status and updates the switch accordingly.</summary>
            <remarks>
            This method handles game's pause and time warp modes, and disables key handling in these
            modes. It also respects UI locking mode set by the game.
            </remarks>
            <returns>Current hold state.</returns>
            <seealso cref="F:KSPDev.InputUtils.KeyboardInputSwitch.keyboardEnabled"/>
        </member>
        <member name="M:KSPDev.InputUtils.KeyboardInputSwitch.SetHoldState(System.Boolean)">
            <summary>Updates hold state and triggers event(s) if any.</summary>
            <param name="newState">New hold state.</param>
            <seealso cref="E:KSPDev.InputUtils.KeyboardInputSwitch.OnStateChanged"/>
        </member>
        <member name="P:KSPDev.InputUtils.KeyboardInputSwitch.isAnyKeyHold">
            <summary>Says if any switch is being hold.</summary>
            <remarks>
            This value is version specific. I.e. multiple versions of the utils DLL will not see each
            other. So if this property returns <c>true</c> then the only safe assumption is that any
            switch <i>within the running</i> mod is being hold. Ideally, when all mods in the game run the
            same version of the utils DLL this property will truly say if <i>any</i> switch across all
            mods is hold.
            </remarks>
        </member>
        <member name="P:KSPDev.InputUtils.KeyboardInputSwitch.isHold">
            <summary>Defines current hold state of the switch.</summary>
            <remarks>
            Note that when reading this property it may not represent actual keyboard key hold state since
            switch state can be assigned from the code.
            </remarks>
        </member>
        <member name="E:KSPDev.InputUtils.KeyboardInputSwitch.OnStateChanged">
            <summary>
            Event that notifies about hold state change. The event is only called when state has actually
            changed.
            </summary>
            <remarks>
            Remember to remove listeners when their owner class is destroyed by the game. If it's not done
            no NRE will happen but "ghost" listeners will continue to react on the events.  
            </remarks>
        </member>
        <member name="E:KSPDev.InputUtils.KeyboardInputSwitch.OnPress">
            <summary>
            Event that notifies that switch key has been pressed.
            </summary>
            <remarks>
            Remember to remove listeners when their owner class is destroyed by the game. If it's not done
            no NRE will happen but "ghost" listeners will continue to react on the events.  
            </remarks>
        </member>
        <member name="E:KSPDev.InputUtils.KeyboardInputSwitch.OnRelease">
            <summary>
            Event that notifies that switch key has been released.
            </summary>
            <remarks>
            Remember to remove listeners when their owner class is destroyed by the game. If it's not done
            no NRE will happen but "ghost" listeners will continue to react on the events.  
            </remarks>
        </member>
        <member name="E:KSPDev.InputUtils.KeyboardInputSwitch.OnClick">
            <summary>
            Event that notifies about "click" event. Click event requires press and release actions
            separted by a maximum delay.
            </summary>
            <remarks>
            Remember to remove listeners when their owner class is destroyed by the game. If it's not done
            no NRE will happen but "ghost" listeners will continue to react on the events.  
            </remarks>
            <seealso cref="F:KSPDev.InputUtils.KeyboardInputSwitch.ClickDelay"/>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IJointEventsListener">
            <summary>Declares callbacks that are called when a joint between two parts is changed.</summary>
            <remarks>
            Events of this inteface are triggered by Unity engine via reflections. It's not required for the
            module to implement the interface to be notified but by implementing it the code becomes more
            consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IJointEventsListener {
              /// <inheritdoc/>
              public void OnJointBreak(float breakForce) {
                Debug.LogInfoFormat("OnJointBreak: {0}", breakForce);
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnJointBreak.html">
            Unity 3D: OnJointBreak</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IJointEventsListener.OnJointBreak(System.Single)">
            <summary>Triggers when connection is broken due to too strong force applied.</summary>
            <param name="breakForce">Actual force that has been applied.</param>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IKSPDevJointLockState">
            <summary>A documented version of the KSP <c>IJointLockState</c> interface.</summary>
            <remarks>
            Inherit from <see cref="T:IJointLockState"/> to let the game know if this part's joint can be
            unlocked. This interface is a full equivalent of <see cref="T:IJointLockState"></see> except it's
            documented. The modules that inherit both interfaces get better code documentation.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IJointLockState, IKSPDevJointLockState {
              /// <inheritdoc/>
              public override bool IsJointUnlocked() {
                return true;
              }
            }
            ]]></code>
            </example>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevJointLockState.IsJointUnlocked">
            <summary>Tells if the parts can move relative to each other.</summary>
            <remarks>
            <para>
            It's important to override this method when the joint is not rigid. For the rigid joints the
            game may create autostruts when appropriate, which will adhere the parts to each other.
            </para>
            <para>This method is called on the child part to check it's joint state to the parent.</para>
            </remarks>
            <returns><c>true</c> if the joint are not fixed relative to each other.</returns>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IKSPActivateOnDecouple">
            <summary>A documented version of the <see cref="T:IActivateOnDecouple"/> interface.</summary>
            <remarks>
            Inherit from <see cref="T:IActivateOnDecouple"/> to be able reacting on the parts decoupling.
            This interface is a full equivalent of <see cref="T:IActivateOnDecouple"/> except it's documented.
            The modules that inherit both interfaces get better code documentation.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IActivateOnDecouple, IKSPActivateOnDecouple {
              /// <inheritdoc/>
              public virtual void DecoupleAction(string nodeName, bool weDecouple) {
                Debug.LogInfo("DecoupleAction");
              }
            }
            ]]></code>
            </example>
            <seealso href="https://kerbalspaceprogram.com/api/interface_i_activate_on_decouple.html">
            KSP: IActivateOnDecouple</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPActivateOnDecouple.DecoupleAction(System.String,System.Boolean)">
            <summary>Called when two parts decouple.</summary>
            <remarks>
            The callback is only called on the part if it has an attach node that connects it to the other
            part. For this event to fire a decoupling logic must be executed. A s imple removal from the
            vessel hierarchy won't trigger the event.
            </remarks>
            <param name="nodeName">The attach node name that has been detached.</param>
            <param name="weDecouple">
            If <c>true</c> then the part being notified was a child in the relation to the detached part.
            </param>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IKSPDevModuleInfo">
            <summary>Documented analogue of IModuleInfo interface.</summary>
            <remarks>
            Inherit from <see cref="T:IModuleInfo"/> to be able customizing module descriptions for the
            editor. <see cref="T:KSPDev.KSPInterfaces.IKSPDevModuleInfo"/> is a full equivalent except it's documented. Inheriting
            modules from both interfaces gives better code documentation.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IPartModule, IModuleInfo, IKSPDevModuleInfo {
              /// <inheritdoc/>
              public override string GetInfo() {
                return "<size=20><color=#ff0000ff><b>BLAH!</b></color></size>";
              }
            }
            ]]></code>
            </example>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetInfo">
            <summary>Returns description for the editor part's browser.</summary>
            <remarks>
            Declared as virtual in <see cref="T:PartModule"/> and, hence, almost always needs to be
            overridden. Though, it's also a part of <see cref="T:IModuleInfo"/>.
            </remarks>
            <returns>
            Rich text to show the in GUI. Regular Unity rich text styles are supported.
            <para>
            Be careful when using &lt;size&gt;. It specifies size of the font in pixels which is an
            absolute value. As of KSP v1.1.3 normal info font size is 11px but in the future versions it
            may change.
            </para>
            </returns>
            <seealso href="https://docs.unity3d.com/Manual/StyledText.html">Unity 3D: Rich text</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetModuleTitle">
            <summary>Returns module title to show in the editor part's details panel.</summary>
            <returns>Title of the module.</returns>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetDrawModulePanelCallback">
            <summary>Returns a method delegate to draw a custom panel.</summary>
            <returns>Delegate or <c>null</c> if not necessary.</returns>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IKSPDevModuleInfo.GetPrimaryField">
            <summary>Return a string to be displayed in the main information box on the tooltip.</summary>
            <returns>String or <c>null</c> if nothing is that important to be up there.</returns>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IPartModule">
             <summary>Interface for KSP part module.</summary>
             <remarks>
             <para>
             Naturally, KSP doesn't declare any part module interface (unfortunately), and all modder's
             modules just inherit from <see cref="T:PartModule"/>. This interface is introduced for the better
             OOP approach. It reveals methods that a regular module can override, and provides documentation
             for each of them.
             </para>
             <para>
             Some methods of the module interface look familiar to the ones from Unity but they are not
             behaving in the same way in every scene. Moreover, not all methods get called in every scene.
             </para>
            
             <para>In the <i>loading scene</i> the callbacks are executed in the following order:</para>
             <list type="table">
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnAwake"/></term>
             <description>
             Notifies about creating new module. If it's a clone operation then all <see cref="T:KSPField"/>
             annotated fields have values from the part's config. Otherwise, all the fields are in the
             initial states.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)"/></term>
             <description>
             The provided config node is the original configuration from the part's definition. All the
             annotated fields are populated before this method gets control.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/></term>
             <description>
             Is <b>not called</b> since the parts being created are prefabs and icon models. They are not
             real parts that behave on a vessel.
             </description>
             </item>
             </list>
            
             <para>In the <i>editor</i> the callbacks are executed in the following order:</para>
             <list type="table">
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnAwake"/></term>
             <description>
             Notifies about creating new module. If it's a clone operation then all <see cref="T:KSPField"/>
             annotated fields have values from the part's config. Otherwise, all the fields are in the
             initial states.
             <para>
             New parts in the editor are created via the clone operation. I.e. each time a part is dragged
             from the toolbar it's get cloned from the prefab.
             </para>
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)"/></term>
             <description>Is <b>not called</b> for the new parts since they are clonned. When a saved vessel
             is loaded in the editor every part on the vessel gets this method called with the values from
             the save file. The annotated fields are populated from the file <i>before</i> this method gets
             control, so it's safe to use them.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnInitialize"/></term>
             <description>Hard to say what it means for the edtior, but important difference from the flight
             scenes is that this method is called before <see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/>.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/></term>
             <description>The code must check if the current scene is editor, and do the behavior changes as
             needed. In the editor parts must not have active behavior.
             </description>
             </item>
             </list>
            
             <para>In the <i>fligth scenes</i> the callbacks are executed in the following order:</para>
             <list type="table">
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnAwake"/></term>
             <description>Notifies about creating new module. All <see cref="T:KSPField"/> annotated fields
             have initial values.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)"/></term>
             <description>The provided config node is the config from the save file. The annotated fields are
             populated from the file <i>before</i> this method gets control, so it's safe to use them.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)"/></term>
             <description>This method is called when all parts in the vessel are created and loaded. The code
             must check if the current scene is flight, and do the behavior changes as needed.
             </description>
             </item>
             <item>
             <term><see cref="M:KSPDev.KSPInterfaces.IPartModule.OnInitialize"/></term>
             <description>Indicates that part should start handling physics if any. It may be called multiple
             times during the part's life. First time it's called when vessel is completely loaded in the
             secene and all parts are started. Other calls may happen when game returns from a physics
             suspended state (e.g. from a warp mode back to x1 time speed).
             <para>
             Code must check if editor scene is loaded since this method is called differently in the editor.
             </para>
             </description>
             </item>
             </list>
            
             </remarks>
             <example>
             <code><![CDATA[
             public class MyModule : PartModule, IPartModule {
               /// <inheritdoc/>
               public override void OnAwake() {
               }
             }
             ]]></code>
             </example>
             <seealso href="https://kerbalspaceprogram.com/api/class_part_module.html">
             KSP: PartModule</seealso>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
             KSP: KSPField</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnAwake">
            <summary>Initializes a new instance of the module on the part.</summary>
            <remarks>
            Called on a newly created part. Note, that this method is a bad place to interact with the
            other modules on the part since module initialization order is not defined.
            <para>See more details on the calling sequence in <see cref="T:KSPDev.KSPInterfaces.IPartModule"/>.</para>
            </remarks>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnLoad(ConfigNode)">
            <summary>Notifies that the part's config is loaded.</summary>
            <remarks>
            All the fields annotated by <see cref="T:KSPField"/> are already loaded at this moment. Use the
            node from this method to handle special values that are not supported by KSP.
            <para>See more details on the calling sequence in <see cref="T:KSPDev.KSPInterfaces.IPartModule"/>.</para>
            </remarks>
            <param name="node">Either the part's config node or a configuration from a save file.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_config_node.html">
            KSP: ConfigNode</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
            KSP: KSPField</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnStart(PartModule.StartState)">
            <summary>Initializes module's state after all other modules have been created.</summary>
            <remarks>
            Note, that this is not the right place to start physics on the part. This callback is good to
            establish connections between the other modules on the part.
            </remarks>
            <para>See more details on the calling sequence in <see cref="T:KSPDev.KSPInterfaces.IPartModule"/>.</para>
            <param name="state">State that specifies the situation of the vessel.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_part_module.html#ac6597127392e002b92f7427cf50244d3">
            KSP: PartModule.StartState</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnInitialize">
            <summary>
            Called on vessel go off rails. Basically, every time the vessel becomes physics.
            </summary>
            <remarks>Can be called multiple times during the part's life.</remarks>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnUpdate">
            <summary>Notifies about a frame update.</summary>
            <remarks>
            Be very careful about placing functionality into this callback even if it's bare "if/else"
            statement. This callback is called on <b>every</b> frame update. It means that even a simple
            piece of code will be called for every part that implements the module. Too many parts with
            such modules may significantly drop FPS.
            </remarks>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.Update.html">
            Unity 3D: Update</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnFixedUpdate">
            <summary>Notifies about a physics frame update.</summary>
            <remarks>
            Physics in Unity is updated every <c>20ms</c> which gives 50 calls per a second. Be
            <i>extremly</i> careful about placing functionality into this callback. All fixed updates are
            required to complete, so if 50 updates take longer than one second then the game's speed will
            degrade.
            <para>In general, don't even override this callback unless it's absolutely required.</para>
            </remarks>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">
            Unity 3D: FixedUpdate</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IPartModule.OnSave(ConfigNode)">
            <summary>Notifies about saving module state.</summary>
            <remarks>
            This isn't required to be saving into a real file. This method is a generic way to save module
            state when it's needed. Note, that saving <c>null</c> is usually a problem for KSP, so always
            give default non-null values to every persisted field.
            <para>
            Persistent fields annotated woth <see cref="T:KSPField"/> are saved before this callback is
            called. Only save values that need special handling. 
            </para>
            </remarks>
            <param name="node">Config node to save data into.</param>
            <seealso href="https://kerbalspaceprogram.com/api/class_config_node.html">
            KSP: ConfigNode</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
            KSP: KSPField</seealso>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsDestroyable">
            <summary>Interface for modules that need to know if script object is destroyed.</summary>
            <remarks>
            Events of this inteface are triggered by Unity engine via reflections. It's not required for the
            module to implement the interface to be notified but by implementing it the code becomes more
            consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsDestroyable {
              /// <inheritdoc/>
              public void OnDestory() {
                Debug.LogInfo("OnDestory");
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDestroy.html">
            Unity 3D: OnDestroy</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsDestroyable.OnDestroy">
            <summary>Triggers when Unity object is about to destroy.</summary>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsPackable">
            <summary>Interface to track the physics state changes in the part's module.</summary>
            <remarks>
            Events of this inteface are triggered by KSP engine via Unity messaging mechanism. It's not
            required for the module to implement the interface to be notified but by implementing it the
            code becomes more consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsPackable {
              /// <inheritdoc/>
              public void OnPartPack() {
                Debug.Log("OnPartPack");
              }
              /// <inheritdoc/>
              public void OnPartUnpack() {
                Debug.Log("OnPartUnpack);
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">
            Unity 3D: GameObject.SendMessage</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_part.html">KSP: Part</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPackable.OnPartPack">
            <summary>Triggers when physics stops on the part.</summary>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPackable.OnPartUnpack">
            <summary>Triggers when physics starts on the part.</summary>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsPartDeathListener">
            <summary>Interface to notify about part's forced destruction.</summary>
            <remarks>
            Events of this inteface are triggered by the KSP engine via Unity messaging mechanism. It's not
            required for the module to implement the interface to be notified but by implementing it the
            code becomes more consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsPartDeathListener {
              /// <inheritdoc/>
              public virtual void OnPartDie() {
                Debug.LogFromat("OnPartDie: {0}", part.name);
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">
            Unity 3D: GameObject.SendMessage</seealso>
            <seealso href="https://kerbalspaceprogram.com/api/class_part.html">KSP: Part</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPartDeathListener.OnPartDie">
            <summary>Triggers when part ois destroyed by the game's logic.</summary>
            <remarks>At this moment the part is already decoupled from the vessel.</remarks>
        </member>
        <member name="T:KSPDev.KSPInterfaces.IsPhysicalObject">
            <summary>Interface for modules that need handling physics.</summary>
            <remarks>
            Events of this inteface are triggered by Unity engine via reflections. It's not required for the
            module to implement the interface to be notified but by implementing it the code becomes more
            consistent and less error prone.
            </remarks>
            <example>
            <code><![CDATA[
            public class MyModule : PartModule, IsPhysicalObject {
              /// <inheritdoc/>
              public void FixedUpdate() {
                // Do physics stuff.
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html">
            Unity 3D: FixedUpdate</seealso>
        </member>
        <member name="M:KSPDev.KSPInterfaces.IsPhysicalObject.FixedUpdate">
            <summary>Notifies that fixed framerate frame is being handled.</summary>
            <remarks>
            This method is called by Unity via reflections, so it's not required to implement the
            interface. Though, it's a good idea to implement this interface in objects/modules that need
            physics updates to make code more readable.
            </remarks>
        </member>
        <member name="T:KSPDev.LogUtils.DbgFormatter">
            <summary>A set of tools to format various game enities for debugging purposes.</summary>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.PartId(Part)">
            <summary>Returns a user friendly unique description of the part.</summary>
            <param name="p">Part to get ID string for.</param>
            <returns>ID string.</returns>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.Vector(UnityEngine.Vector3)">
            <summary>Returns a string represenation of a vector with more precision.</summary>
            <param name="vec">Vector to dump.</param>
            <returns>String representation.</returns>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.Quaternion(UnityEngine.Quaternion)">
            <summary>Returns a string represenation of a quaternion with more precision.</summary>
            <param name="rot">Quaternion to dump.</param>
            <returns>String representation.</returns>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.TranformPath(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>Returns a full string path for the tranform.</summary>
            <param name="obj">Object to make the path for.</param>
            <param name="parent">Optional parent to use a root.</param>
            <returns>Full string path to the root.</returns>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.TranformPath(UnityEngine.GameObject,UnityEngine.Transform)">
            <summary>Returns a full string path for the game object.</summary>
            <param name="obj">Object to make the path for.</param>
            <param name="parent">Optional parent to use a root.</param>
            <returns>Full string path to the root.</returns>
        </member>
        <member name="M:KSPDev.LogUtils.DbgFormatter.C2S``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
            <summary>Flatterns collection items into a comma separated string.</summary>
            <remarks>This method's name is a shorthand for "Collection-To-String". Given a collection
            (e.g. list, set, or anything else implementing <c>IEnumarable</c>) this method transforms it
            into a human readable string.</remarks>
            <param name="collection">A collection to represent as a string.</param>
            <param name="predicate">A predicate to use to extract string representation of an item. If
            <c>null</c> then standard <c>ToString()</c> is used.</param>
            <param name="separator">String to use to glue the parts.</param>
            <returns>Human readable form of the collection.</returns>
            <typeparam name="TSource">Collection's item type.</typeparam>
        </member>
        <member name="T:KSPDev.ModelUtils.AlignTransforms">
            <summary>Helper methods to align transformations relative to each other.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.AlignTransforms.SnapAlign(UnityEngine.Transform,UnityEngine.Transform,UnityEngine.Transform)">
            <summary>
            Aligns the source node so that it's located at the target, and source and target are "looking"
            at each other.
            </summary>
            <param name="source">Node to align.</param>
            <param name="sourceChild">Child node of the source to use as the align point.</param>
            <param name="target">Target node to align with.</param>
        </member>
        <member name="T:KSPDev.ModelUtils.Colliders">
            <summary>Various tools to deal with procedural colliders.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.SetSimpleCollider(UnityEngine.GameObject,UnityEngine.PrimitiveType,System.Boolean)">
            <summary>
            Drops the colliders in all the children objects, and adds one big collider to the parent.
            </summary>
            <remarks>
            The main purpose of this method is to create one fast collider at the cost of precision. All
            the meshes in the object (the parent and the children) are processed to produce a single
            boundary box. Then, this box is applied to the requested primitive type that defines the shape
            of the final collider.
            <para>
            Note, that radius of the sphere and the capsule colliders is the same on both X and Y axis.
            If the combined boundary box has any of the dimensions significantly different then it makes
            sense to choose a different collider type. Or break down the hirearchy into more colliders.
            </para>
            </remarks>
            <param name="parent">Parent object.</param>
            <param name="type">
            Type of the primitive which describes the parent object most precise in terms of the shape.
            Only <see cref="F:UnityEngine.PrimitiveType.Cube"/>, <see cref="F:UnityEngine.PrimitiveType.Sphere"/>,
            <see cref="F:UnityEngine.PrimitiveType.Cylinder"/>, and <see cref="F:UnityEngine.PrimitiveType.Capsule"/> are supported.
            The two latter types produce in the same collider type - the capsule.
            </param>
            <param name="inscribeBoundaryIntoCollider">
            When calculating the total volume of the object, all its meshes produce a single box boundary.
            Then, the collider either wraps this box entirely, or sits inside it entirely. If this
            parameter is <c>true</c> then the collider will cover the boundary box.
            </param>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.html">
            Unity 3D: GameObject</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/PrimitiveType.html">
            Unity 3D: PrimitiveType</seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.UpdateColliders(UnityEngine.GameObject,System.Nullable{System.Boolean},System.Nullable{System.Boolean})">
            <summary>Sets the specified values to colliders of all the objects in the part's model.
            </summary>
            <param name="parent">Game object to start searching for renderers from.</param>
            <param name="isPhysical">
            If <c>true</c> then collider will trigger physical effects. If <c>false</c> then it will only
            trigger collision events. When it's <c>null</c> the collider setting won't be changed.
            </param>
            <param name="isEnabled">
            Defines if colliders should be enabled or disabled. When it's <c>null</c> the collider setting
            won't be changed.
            </param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Collider.html">Unity3D: Collider
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.AdjustCollider(UnityEngine.GameObject,UnityEngine.Vector3,KSPDev.ModelUtils.Colliders.PrimitiveCollider,System.Nullable{UnityEngine.PrimitiveType})">
            <summary>Adds or adjusts a primitive collider on the mesh.</summary>
            <remarks>
            Type of the primitive collider is chosen basing on the primitive type.
            </remarks>
            <param name="primitive">Primitive game object to adjust.</param>
            <param name="meshSize">Size of the collider in local units.</param>
            <param name="colliderType">Determines how a collider type should be selected.</param>
            <param name="shapeType">
            Type of the primitive when <paramref name="colliderType"/> is
            <see cref="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Shape"/>. It will determine the type of the collider. Only
            <see cref="F:UnityEngine.PrimitiveType.Cylinder"/>, <see cref="F:UnityEngine.PrimitiveType.Sphere"/>, and
            <see cref="F:UnityEngine.PrimitiveType.Cube"/> are supported.
            </param>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.SetCollisionIgnores(UnityEngine.Transform,UnityEngine.Transform,System.Boolean)">
            <summary>Disables/enables all the colliders between the objects.</summary>
            <remarks>
            All colliders in all the children of the both objects are explicitly set to not collide with
            each other. The ignore state is reset to <c>false</c> on every scene load.
            </remarks>
            <param name="obj1">Source object.</param>
            <param name="obj2">Target object.</param>
            <param name="ignore">
            If <c>true</c> then the collisions between the objects will be ignored. Otherwise, the
            collisions will be handled.
            </param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Collider.html">
            Unity3D: Collider</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Physics.IgnoreCollision.html">
            Unity3D: Physics.IgnoreCollision</seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Colliders.SetCollisionIgnores(Part,Part,System.Boolean)">
            <summary>Disables/enables all the colliders between the parts.</summary>
            <remarks>The ignore state is reset to <c>false</c> on every scene load.</remarks>
            <param name="part1">Source part.</param>
            <param name="part2">Target part.</param>
            <param name="ignore">
            If <c>true</c> then the collisions between the parts will be ignored. Otherwise, the
            collisions will be handled.
            </param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Collider.html">
            Unity3D: Collider</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Physics.IgnoreCollision.html">
            Unity3D: Physics.IgnoreCollision</seealso>
        </member>
        <member name="T:KSPDev.ModelUtils.Colliders.PrimitiveCollider">
            <summary>Defines how collisions should be checked on a primitive.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.None">
            <summary>No collisions check.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Mesh">
            <summary>Check collisions basing on the mesh. It's performance expensive.</summary>
            <seealso href="https://docs.unity3d.com/ScriptReference/MeshCollider.html">
            Unity3D: MeshCollider</seealso>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Shape">
            <summary>Simple collider which fits the primitive type. It's performance optimized.</summary>
            <seealso href="https://docs.unity3d.com/ScriptReference/PrimitiveType.html">
            Unity3D: PrimitiveType</seealso>
        </member>
        <member name="F:KSPDev.ModelUtils.Colliders.PrimitiveCollider.Bounds">
            <summary>Simple collider which wraps all mesh vertexes. It's performance optimized.</summary>
        </member>
        <member name="T:KSPDev.ModelUtils.Hierarchy">
            <summary>Various tools to deal with game object hierarchy.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.Hierarchy.ReSplitEscapedPath">
            <summary>Regex to split an escaped path.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.MoveToParent(UnityEngine.Transform,UnityEngine.Transform,System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Quaternion},System.Nullable{UnityEngine.Vector3})">
            <summary>Changes transform's parent keeping local postion, rotation and scale.</summary>
            <remarks>
            Normally, Unity preserves world position, rotation and scale when changing parent. It's
            convinient when managing objects in a prefab but is not desired when constructing a new model.
            </remarks>
            <param name="child">Transform to change parent for.</param>
            <param name="parent">Transform to change parent to.</param>
            <param name="newPosition">Local position to set instead of the original one.</param>
            <param name="newRotation">Local rotation to set instead of the original one.</param>
            <param name="newScale">Local scale to set instead of the original one.</param>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.PatternMatch(System.String,System.String)">
            <summary>
            Checks target string against a simple pattern which allows prefix, suffix, and contains match.
            The match is case-sensitive.
            </summary>
            <param name="pattern">
            Pattern to match for:
            <list type="bullet">
            <item>If pattern ends with <c>*</c> then it's a match by prefix.</item>
            <item>If pattern starts with <c>*</c> then it's a match by suffix.</item>
            <item>
            If pattern starts and ends with <c>*</c> then pattern is searched anywhere in the target.
            </item>
            </list>
            </param>
            <param name="target">The target string to check.</param>
            <returns><c>true</c> if pattern matches the target.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.FindTransformInChildren(UnityEngine.Transform,System.String)">
            <summary>Finds a transform by name down the hierarchy.</summary>
            <remarks>
            Implements breadth-first search approach to minimize depth of the found transform.
            </remarks>
            <param name="parent">The transfrom to start from.</param>
            <param name="name">The name of the transfrom.</param>
            <returns>A transform or <c>null</c> if nothing is found.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String)">
            <summary>Finds a transform in the hirerachy by the provided path.</summary>
            <remarks>See path format in <see cref="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String[])"/>.</remarks>
            <param name="parent">The transfrom to start looking from.</param>
            <param name="path">
            The path to the target. The name components must be escaped if they contain special symbols.
            </param>
            <returns>A transform or <c>null</c> if nothing found.</returns>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String[])"/>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.EscapeName(System.String)"/>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String[])">
            <summary>Finds a transform in the hirerachy by the provided path.</summary>
            <remarks>
            Every element of the path may specify an exact transform name or a partial match pattern:
            <list type="bullet">
            <item>
            <c>*</c> - any name matches. Such patterns can be nested to specify the desired level of
            nesting. E.g. <c>*/*/a</c> will look for name <c>a</c> in the grandchildren.
            </item>
            <item>
            <c>*</c> as a prefix - the name is matched by suffix. E.g. <c>*a</c> matches any name that
            ends with <c>a</c>.
            </item>
            <item>
            <c>*</c> as a suffix - the name is matched by prefix. E.g. <c>a*</c> matches any name that
            starts with <c>a</c>.
            </item>
            <item>
            <c>**</c> - any <i>path</i> matches. What will eventually be found depends on the pattern to
            the right of <c>**</c>. The path match pattern does a "breadth-first" search, i.e. it tries to
            find the shortest path possible. E.g. <c>**/a/b</c> will go through all the nodes starting
            from the parent until path <c>a/b</c> is found. Be careful with this pattern since in case of
            not matching anything it will walk thought the <i>whole</i> hirerachy.
            </item>
            </list>
            <para>
            All patterns except <c>**</c> may have a matching index. It can be used to resolve matches
            when there are multiple objects found with the same name and at the <i>same level</i>. E.g. if
            there are two objects with name "a" at the root level then the first one can be accessed by
            pattern <c>a:0</c>, and the second one by pattern <c>a:1</c>.
            </para>
            <para>
            Path search is <i>slow</i> since it needs walking though the hierarchy nodes. In the worst
            case all the nodes will be visited. Don't use this method in the performance demanding
            methods.
            </para>
            </remarks>
            <param name="parent">The transfrom to start looking from.</param>
            <param name="names">The path elements. All special symbols must be unescaped.</param>
            <returns>Transform or <c>null</c> if nothing found.</returns>
            <example>
            Given the following hierarchy:
            <code lang="c++"><![CDATA[
            // a
            // + b
            // | + c
            // | | + c1
            // | | + d
            // | + c
            // |   + d
            // |     + e
            // |       + e1
            // + abc
            ]]></code>
            <para>The following pattern/output will be possible:</para>
            <code><![CDATA[
            // a/b/c/d/e/e1 => node "e1"
            // a/b/*/d/e/e1 => node "e1"
            // a/b/*/*/e/e1 => node "e1"
            // a/b/c/c1 => node "1"
            // a/b/*:0 => branch "a/b/c/c1", node "c"
            // a/b/*:1 => branch "a/b/c/d/e/e1", node "c"
            // a/b/c:1/d => branch "a/b/c/d/e/e1", node "d"
            // **/e1 => node "e1"
            // **/c1 => node "c1"
            // **/c/d => AMBIGUITY! The first found branch will be taken
            // a/**/e1 => node "e1"
            // *bc => node "abc"
            // ab* => node "abc"
            // *b* => node "abc"
            ]]></code>
            </example>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.UnescapeName(System.String)"/>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.GetPartModelTransform(Part)">
            <summary>Returns part's model transform.</summary>
            <param name="part">The part to get model for.</param>
            <returns>
            The part's model transform if one was found. Or the root part's transform otherwise.
            </returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.ListHirerahcy(UnityEngine.Transform,System.String)">
            <summary>
            Returns the paths to all the transformations in the object. Each item is a full path to the
            transformation starting from the <paramref name="parent"/>.
            </summary>
            <param name="parent">The object to start from.</param>
            <param name="pathPrefix">The prefix to add to every path in the result.</param>
            <returns>The paths to all the objects in the hirerachy separated by a LF symbol.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.GetFullPath(UnityEngine.Transform,UnityEngine.Transform)">
            <summary>Returns a full path to the object starting from the specified parent.</summary>
            <param name="obj">The object to find path for.</param>
            <param name="parent">
            The object at which the path must stop. If <c>null</c> then the path is gathered to the root
            object.
            </param>
            <returns>A full path name components. The names are not escaped.</returns>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.FindTransformByPath(UnityEngine.Transform,System.String[])"/>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.SplitAndUnescapePath(System.String)">
            <summary>Splits a path and unescapes the name elements.</summary>
            <remarks>
            The path elements must be separted by a <c>'/'</c> symbol. The name elements must be escaped
            in case of they contain a separator symbol in the content. 
            </remarks>
            <param name="escapedPath">The escaped path to split.</param>
            <returns>An array of unescaped names.</returns>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.UnescapeName(System.String)"/>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.MakePath(System.String[])">
            <summary>Escapes the element names and builds a path.</summary>
            <param name="unescapedNames">The raw name elements of the path.</param>
            <returns>An escaped path built of the provided elements.</returns>
            <seealso cref="M:KSPDev.ModelUtils.Hierarchy.EscapeName(System.String)"/>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.UnescapeName(System.String)">
            <summary>Unescapes all the special symbols in the name.</summary>
            <param name="escapedName">The name where all the special symbols are escaped.</param>
            <returns>An unescaped name.</returns>
        </member>
        <member name="M:KSPDev.ModelUtils.Hierarchy.EscapeName(System.String)">
            <summary>Escapes all the special symbols in the name.</summary>
            <remarks>
            For now the only specil symbol is <c>/</c> (slash) because of it's used as a name separator
            in the hierarchy paths. The escaped separator symbol is simple doubled. I.e. string <c>a/b</c>
            transforms into <c>a//b</c>.
            </remarks>
            <param name="unescapedName">The raw name with any symbols.</param>
            <returns>A name where all the special symbols are properly escaped.</returns>
        </member>
        <member name="T:KSPDev.ModelUtils.KspLayerMask">
            <summary>Flags for the collision layers in KSP.</summary>
            <remarks>
            It's not a full set of the layers. More investigation is needed to reveal all of them.
            </remarks>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.NONE">
            <summary>Just a default value that doesn't match any layer.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.PARTS">
            <summary>Layer for a regular part.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.SERVICE_LAYER">
            <summary>Layer to set bounds of a celestial body.</summary>
            <remarks>
            A very rough boundary of a planet, moon or asteroid. Used for macro objects detection.
            </remarks>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.SURFACE">
            <summary>"Zero" level of a static structure on the surface.</summary>
            <remarks>E.g. a launchpad.</remarks>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.KERBALS">
            <summary>Layer of kerbonaut models.</summary>
        </member>
        <member name="F:KSPDev.ModelUtils.KspLayerMask.FX">
            <summary>A layer for FX.</summary>
            <remarks>E.g. <c>PadFXReceiver</c> on the Kerbins VAB launchpad.</remarks>
        </member>
        <member name="T:KSPDev.ModelUtils.Meshes">
            <summary>Various tools to deal with procedural meshes.</summary>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.RescaleTextureToLength(UnityEngine.GameObject,System.Single,UnityEngine.Renderer)">
            <summary>
            Rescales texture so what one sample covers exactly one unit of the primitive length.
            </summary>
            <remarks>
            Normally one texture sample covers the whole primitive regardless to its length. By calling
            this method you ensure that one sample keeps its ratio comparing to a linear unit. If
            primitive is too short to fit the texture then the texture is truncated. If primitive is too
            long to be covered by one sample then the texture will be tiled to fill the space.
            <para>
            This methods assumes UV data on the primitive was created for a length of 1m. With this
            assumption in mind the Z axis of the local scale is cosidered "the length".
            <see cref="M:KSPDev.ModelUtils.Meshes.CreatePrimitive(UnityEngine.PrimitiveType,UnityEngine.Vector3,UnityEngine.Material,UnityEngine.Transform)"/> method guarantees that newly created primitive always has length
            of one meter but if primitive was created by other means its default length can be different.
            </para>
            </remarks>
            <param name="obj">Game object to adjust material on. Z axis scale gives the length.</param>
            <param name="lengthUnit">Length to be completly covered by one sample of the texture.
            </param>
            <param name="renderer">Specific renderer to adjust texture in. If <c>null</c> then first
            renderer on the object will be updated. Note, that getting renderer from the object is an
            expensive operation. When performance is the key it makes sense caching the renderer, and
            passing it in every rescale call.</param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Renderer.html">Unity3D: Renderer
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.UpdateMaterials(UnityEngine.GameObject,System.String,System.Nullable{UnityEngine.Color})">
            <summary>
            Sets the specified values to material of all the renderers in the part's model.
            </summary>
            <remarks>
            Shared material is affected, so if there are unrelated meshes that use the same material then
            they will be affected as well. In general, it's a bad idea to share material between several
            parts. And it's a good practice to share materials within the same part.
            </remarks>
            <param name="parent">Game object to start searching for renderers from.</param>
            <param name="newShaderName">
            New shader name. If <c>null</c> then it will not be changed.
            </param>
            <param name="newColor">Color to set. If <c>null</c> then it will not be changed.</param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Shader.html">Unity3D: Shader</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreateCylinder(System.Single,System.Single,UnityEngine.Material,UnityEngine.Transform,KSPDev.ModelUtils.Colliders.PrimitiveCollider)">
            <summary>Creates a cylinder.</summary>
            <param name="diameter">XY of the cylinder.</param>
            <param name="length">Z-axis of the cylinder.</param>
            <param name="material">Material for the primitive.</param>
            <param name="parent">Parent transfrom to atatch primitive to.</param>
            <param name="colliderType">Type of the collider to create on the primitive.</param>
            <returns>Sphere game object.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity3D: Transform
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreateBox(System.Single,System.Single,System.Single,UnityEngine.Material,UnityEngine.Transform,KSPDev.ModelUtils.Colliders.PrimitiveCollider)">
            <summary>Creates a box.</summary>
            <param name="width">X-axis of the box.</param>
            <param name="height">Y-axis of the box.</param>
            <param name="length">Z-axis of the box.</param>
            <param name="material">Material for the primitive.</param>
            <param name="parent">Parent transfrom to atatch primitive to.</param>
            <param name="colliderType">Type of the collider to create on the primitive.</param>
            <returns>Sphere game object.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity3D: Transform
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreateSphere(System.Single,UnityEngine.Material,UnityEngine.Transform,KSPDev.ModelUtils.Colliders.PrimitiveCollider)">
            <summary>Creates an ideal sphere.</summary>
            <param name="diameter">Diameter of the sphere.</param>
            <param name="material">Material for the primitive.</param>
            <param name="parent">Parent transfrom to atatch primitive to.</param>
            <param name="colliderType">Type of the collider to create on the primitive.</param>
            <returns>Sphere game object.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">Unity3D: Transform
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.CreatePrimitive(UnityEngine.PrimitiveType,UnityEngine.Vector3,UnityEngine.Material,UnityEngine.Transform)">
            <summary>Creates a primitive mesh and attaches it to the model.</summary>
            <remarks>
            For <see cref="F:UnityEngine.PrimitiveType.Cylinder"/> Z and Y axis will be swapped to make Z "the length".
            <para>
            Collider on the primitive will be destroyed. Consider using
            <see cref="M:KSPDev.ModelUtils.Colliders.AdjustCollider(UnityEngine.GameObject,UnityEngine.Vector3,KSPDev.ModelUtils.Colliders.PrimitiveCollider,System.Nullable{UnityEngine.PrimitiveType})"/> to setup the right collider when needed.
            </para>
            </remarks>
            <param name="type">Type of the primitive.</param>
            <param name="meshScale">
            Scale to bring all mesh vertices to. New primitive have base size of 1m but some shapes may
            have exceptions (e.g. height of a cylinder is 2m). The scale is applied on the mesh, i.e. it's
            applied on the vertices, not the transform.</param>
            <param name="material">Material to use for the primitive.</param>
            <param name="parent">Parent transform to attach primitive to.</param>
            <returns>Game object of the new primitive.</returns>
            <seealso href="https://docs.unity3d.com/ScriptReference/GameObject.CreatePrimitive.html">
            Unity3D: GameObject.CreatePrimitive</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Material.html">Unity3D: Material
            </seealso>
        </member>
        <member name="M:KSPDev.ModelUtils.Meshes.TranslateMesh(UnityEngine.GameObject,System.Nullable{UnityEngine.Vector3},System.Nullable{UnityEngine.Quaternion},System.Nullable{UnityEngine.Vector3})">
            <summary>Translates meshes's verticies.</summary>
            <remarks>
            This is different from setting postion, rotation and scale to the transform. This method
            <i>actually</i> changes vetricies in the mesh. It's not performance effective, so avoid doing
            it frequiently.
            </remarks>
            <param name="model">Model object to change the mesh in.</param>
            <param name="offset">
            Offset for the verticies. If not specified then the offset is zero. The offset is added
            <i>after</i> the scale and the rotation have been applied.  
            </param>
            <param name="rotation">
            Rotation for the verticies. If not set then no rotation is added.
            </param>
            <param name="scale">
            Scale for the vertex positions. If not specified then the scale is not affected.
            </param>
        </member>
        <member name="T:KSPDev.ProcessingUtils.AsyncCall">
            <summary>Set of tools to execute a delayed code.</summary>
            <remarks>
            Use these tools when code needs to be executed with some delay or at a specific moment of the
            game.
            </remarks>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.CallOnEndOfFrame(UnityEngine.MonoBehaviour,System.Action)">
            <summary>Delays execution of the delegate till the end of the current frame.</summary>
            <remarks>
            Caller can continue executing its logic. The delegate will be called at the end of
            the frame via Unity StartCoroutine mechanism. The delegate will be called only once.
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then the async call will not be invoked.
            </param>
            <param name="action">Delegate to execute.</param>
            <returns>Coroutine instance.</returns>
            <example>
            <code><![CDATA[
            class MyComponent : MonoBehaviour {
              void Update() {
                // Call the method at the end of the current frame.
                AsyncCall.CallOnEndOfFrame(this, () => Debug.LogFormat("Async call!"));
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html">
            Unity 3D: WaitForEndOfFrame</seealso>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.CallOnTimeout(UnityEngine.MonoBehaviour,System.Single,System.Action)">
            <summary>Delays execution of the delegate for the specified amount of time.</summary>
            <remarks>
            Caller can continue executing its logic. The delegate will be called once the timeout is
            expired via Unity StartCoroutine mechanism. The delegate will be called only once.
            <para>Using returned instance caller may cancel the call before the timeout expired.</para>
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then the async call will not be invoked.
            </param>
            <param name="seconds">Timeout in seconds.</param>
            <param name="action">Delegate to execute.</param>
            <returns>Coroutine instance.</returns>
            <example>
            <code><![CDATA[
            class MyComponent : MonoBehaviour {
              void Update() {
                // Call the method at the end of the current frame.
                AsyncCall.CallOnTimeout(this, 5.0f, () => Debug.LogFormat("Async call!"));
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForSeconds.html">
            Unity 3D: WaitForSeconds</seealso>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.CallOnFixedUpdate(UnityEngine.MonoBehaviour,System.Action)">
            <summary>Delays execution of the delegate till the next fixed update.</summary>
            <remarks>
            Caller can continue executing its logic. The delegate will be called at the beginning of the
            next fixed (physics) update via Unity StartCoroutine mechanism. The delegate will be called
            only once.
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then the async call will not be invoked.
            </param>
            <param name="action">Delegate to execute.</param>
            <returns>Coroutine instance.</returns>
            <example>
            <code><![CDATA[
            class MyComponent : MonoBehaviour {
              void Update() {
                // Call the method at the end of the current frame.
                AsyncCall.CallOnFixedUpdate(this, () => Debug.LogFormat("Async call!"));
              }
            }
            ]]></code>
            </example>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForFixedUpdate.html">
            Unity 3D: WaitForFixedUpdate</seealso>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.WaitForPhysics(UnityEngine.MonoBehaviour,System.Int32,System.Func{System.Boolean},System.Action,System.Action,System.Action{System.Int32},System.Boolean)">
            <summary>
            Delays execution until the specified condition is reached. Waiting is limited by the specified
            number of fixed frame updates.
            </summary>
            <remarks>
            Can be used when a particular state of the game is required to perform an action. Method
            provides ability to define for how long to wait, what to do while waiting, and what to execute
            when target state is reached or missed.
            </remarks>
            <param name="mono">
            Unity object to run coroutine on. If this object dies then waiting will be aborted without
            calling any callbacks.
            </param>
            <param name="maxFrames">Number of fixed frame updates to wait before giving up.</param>
            <param name="waitUntilFn">
            State checking function. It should return <c>true</c> once target state is reached. The very
            first execution happens immediately, <i>before</i> exiting from the method. If this
            this execution returned <c>true</c> then the successful callback is also called immediately. 
            </param>
            <param name="success">Callback to execute when state has been successfully reached.</param>
            <param name="failure">
            Callabck to execute when state has not been reached before frame update limit is exhausted.
            </param>
            <param name="update">
            Callback to execute every fixed frame update while waiting. This callabck will be called at
            least once, and teh first call happens immediately. The argument tells how many frames the
            method was waiting so far. For the very first call it's, obviously, zero.
            </param>
            <param name="traceUpdates">When <c>true</c> every wiating cycle will be logged.</param>
            <returns>Enumerator that can be used as coroutine target.</returns>
            <example>
            <code><![CDATA[
            class MyComponent : MonoBehaviour {
              void Awake() {
                var count = 5;
                Debug.Log("Before start waiting");
                AsyncCall.WaitForPhysics(
                    this, 10,
                    () => --count == 0,
                    success: () => Debug.Log("Success!"),
                    failure: () => Debug.Log("Failure!"),
                    update: x => Debug.LogFormat("...waiting: {0}", x));
                Debug.Log("After start waiting");
              }
            }
            ]]></code>
            <para>
            This example will print the following:
            </para>
            <code><![CDATA[
            // Before start waiting
            // ...waiting: 0
            // After start waiting
            // ...waiting: 1
            // ...waiting: 2
            // ...waiting: 3
            // ...waiting: 4
            // Success!
            ]]></code>
            <para>If you adjust <c>count</c> to <c>11</c> then the last message will be "Failure!".</para>
            </example>
            <seealso cref="M:KSPDev.ProcessingUtils.AsyncCall.AsyncWaitForPhysics(System.Int32,System.Func{System.Boolean},System.Action,System.Action,System.Action{System.Int32},System.Boolean)"/>
            <seealso href="https://docs.unity3d.com/Manual/Coroutines.html">Unity 3D: Coroutines</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/WaitForFixedUpdate.html">
            Unity 3D: WaitForFixedUpdate</seealso>
        </member>
        <member name="M:KSPDev.ProcessingUtils.AsyncCall.AsyncWaitForPhysics(System.Int32,System.Func{System.Boolean},System.Action,System.Action,System.Action{System.Int32},System.Boolean)">
            <summary>Async version of <see cref="M:KSPDev.ProcessingUtils.AsyncCall.WaitForPhysics(UnityEngine.MonoBehaviour,System.Int32,System.Func{System.Boolean},System.Action,System.Action,System.Action{System.Int32},System.Boolean)"/>.</summary>
            <param name="maxFrames">Number of fixed frame updates to wait before giving up.</param>
            <param name="waitUntilFn">
            State checking function. It should return <c>true</c> once target state is reached. The very
            first execution happens immediately, <i>before</i> exiting from the method. If this
            this execution returned <c>true</c> then the successful callback is also called immediately. 
            </param>
            <param name="success">Callback to execute when state has been successfully reached.</param>
            <param name="failure">
            Callabck to execute when state has not been reached before frame update limit is exhausted.
            </param>
            <param name="update">
            Callback to execute every fixed frame update while waiting. This callabck will be called at
            least once, and teh first call happens immediately. The argument tells how many frames the
            method was waiting so far. For the very first call it's, obviously, zero.
            </param>
            <param name="traceUpdates">When <c>true</c> every wiating cycle will be logged.</param>
            <returns>Enumerator that can be used as a coroutine target.</returns>
            <seealso cref="M:KSPDev.ProcessingUtils.AsyncCall.WaitForPhysics(UnityEngine.MonoBehaviour,System.Int32,System.Func{System.Boolean},System.Action,System.Action,System.Action{System.Int32},System.Boolean)"/>
            <example>
            This method is useful when synchronous wait is needed within a coroutine. Instead of
            implementing own loops just return the waiting enumerator. The code below will log 10 waiting
            lines between "Started" and "Ended" records. 
            <code><![CDATA[
            class MyComponent : MonoBehaviour {
              void Awake() {
                StartCoroutine(MyDelayedFn());
              }
              IEnumerator MyDelayedFn() {
                Debug.Log("Started!");
                yield return AsyncCall.AsyncWaitForPhysics(
                   10,
                   () => false,
                   update: frame => Debug.LogFormat("...waiting frame {0}...", frame));
                Debug.Log("Ended!");
              }
            }
            ]]></code>
            </example>
            <seealso cref="M:KSPDev.ProcessingUtils.AsyncCall.WaitForPhysics(UnityEngine.MonoBehaviour,System.Int32,System.Func{System.Boolean},System.Action,System.Action,System.Action{System.Int32},System.Boolean)"/>
        </member>
        <member name="T:KSPDev.ProcessingUtils.SimpleStateMachine`1">
             <summary>
             Simple state machine that allows tracking states and checking basic conditions.
             </summary>
             <remarks>
             If module has more that two modes (which can be controlled by a simple boolean) in makes sense
             to define each mode as a state, and intorduce a definite state transition diagram. Once it's
             done most of the mode changes logic can be mvoed in state transition callbacks. Such approach
             significantly simplifies the code and makes it less error prone.
             </remarks>
             <typeparam name="T">
             Enum to use as state constants. Note, that state machine won't consider any value of the enum as
             a valid state. Valid states must be defined via <see cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/>.
             </typeparam>
             <example>
             Here is an example of a module with three states with the following logic:
             <list type="bullet">
             <item>State <c>One</c> can be transitioned into both <c>Two</c> and <c>Three</c>.</item>
             <item>States <c>Two</c> and <c>Three</c> can only return back to <c>One</c>.</item>
             <item>In states <c>Two</c> and <c>Three</c> different menu options are available.</item>
             <item>In state <c>One</c> no menu options are available.</item>
             </list>
             <code><![CDATA[
             class MyModule : PartModule {
               enum MyState {
                 One, Two, Three
               }
            
               [KSPField(isPersistant = true)]
               public MyState persistedState = MyState.One;  // ALWAYS provide a default value!
            
               SimpleStateMachine<MyState> linkStateMachine;
            
               [KSPEvent(guiName = "State: TWO")]
               public void StateTwoMenuAction() {
                 Debug.LogInfo("StateTwoMenuAction()");
               }
            
               [KSPEvent(guiName = "State: THREE")]
               public void StateThreeMenuAction() {
                 Debug.LogInfo("StateThreeMenuAction()");
               }
            
               public override OnAwake() {
                 linkStateMachine = new SimpleStateMachine<MyState>(true /* strict */);
                 linkStateMachine.SetTransitionConstraint(
                     MyState.One,
                     new[] {MyState.Two, MyState.Three});
                 linkStateMachine.SetTransitionConstraint(
                     MyState.Two,
                     new[] {MyState.One});
                 linkStateMachine.SetTransitionConstraint(
                     MyState.Three,
                     new[] {MyState.One});
                 linkStateMachine.AddStateHandlers(
                     MyState.One,
                     enterHandler: x => {
                       Events["StateTwoMenuAction"].active = false;
                       Events["StateThreeMenuAction"].active = false;
                     });
                 linkStateMachine.AddStateHandlers(
                     MyState.Two,
                     enterHandler: x => {
                       Events["StateTwoMenuAction"].active = true;
                       Events["StateThreeMenuAction"].active = false;
                     });
                 linkStateMachine.AddStateHandlers(
                     MyState.Three,
                     enterHandler: x => {
                       Events["StateTwoMenuAction"].active = false;
                       Events["StateThreeMenuAction"].active = true;
                     });
               }
            
               public override void OnStart(PartModule.StartState state) {
                 linkStateMachine.Start(persistedState);  // Restore state from the save file.
               }
            
               void OnDestory() {
                 // Usually, this isn't needed. But if code needs to do a cleanup job it makes sense to wrap
                 // it into a handler, and stop the machine in Unity destructor.
                 linkStateMachine.Stop();
               }
            
               public override OnUpdate() {
                 if (Input.GetKeyDown("1")) {
                   // This transition will always succceed. 
                   stateMachine.currentState = MyState.One;
                 }
                 if (Input.GetKeyDown("2")) {
                   // This transition will only succceed if current state is MyState.One. 
                   stateMachine.currentState = MyState.Two;
                 }
                 if (Input.GetKeyDown("3")) {
                   // This transition will only succceed if current state is MyState.One. 
                   stateMachine.currentState = MyState.Three;
                 }
               }
             }
             ]]></code>
             <para>
             The same logic could be achivied in a different way. Instead of enabling/disabling all the menu
             items in every "enter" handler the code could define "leave" handlers that would disable the
             related menu item. This way every state handler would control own menu item without interacting
             with any existing or future items.
             </para>
             </example>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_field.html">
             KSP: KSPField</seealso>
             <seealso href="https://kerbalspaceprogram.com/api/class_k_s_p_event.html">
             KSP: KSPEvent</seealso>
        </member>
        <member name="F:KSPDev.ProcessingUtils.SimpleStateMachine`1.OnDebugStateChange">
            <summary>
            Debug handler for tracking state changes. Avoid using it in normal code logic.
            </summary>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.#ctor(System.Boolean)">
            <summary>Constructs new unstarted state machine.</summary>
            <param name="strict">
            If <c>true</c> then only transitions defined via <see cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/> will be
            allowed.
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.Start(`0)">
            <summary>Starts state machine and makes it available for state transitions.</summary>
            <remarks>
            Until machine is started state transitions are not possible. Attempt to change to any state
            will result in <see cref="T:System.InvalidOperationException"/>.
            <para>Starting of the machine will trigger enter state event.</para>
            </remarks>
            <param name="startState">Initial state of the machine.</param>
            <seealso cref="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStarted"/>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.AddStateHandlers(`0,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange)"/>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.Stop">
            <summary>Stops stat machine making it unavailable for any state transitions.</summary>
            <remarks>
            If machine is not started yet then this call is NO-OP.
            <para>Stoping of the machine will trigger leave state event.</para>
            </remarks>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])">
            <summary>Defines source state and, optionally, allowed trasitions.</summary>
            <remarks>
            State machine figures out full set the allowed states from the transitions. Even if transition
            mode is not strict all the states must be defined via tarnsitions (eitehr as a source or a
            target).
            <para>In strict mode it's required that every transition is declared excplicitly.</para>
            <para>If called multiple times then only last call's setup will be stored.</para>
            <para>State machine must be in stopped state. Otherwise, an exception will thrown.</para>
            </remarks>
            <param name="fromState">Source state.</param>
            <param name="toStates">
            List of states that are allowed as targets for <paramref name="fromState"/>.
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.ResetTransitionConstraint(`0)">
            <summary>Clears transitions for the soucre state if any.</summary>
            <remarks>
            Note, that source state is cleared as well. If it's not mentioned in other transitions then
            state machine will completely forget the state.
            </remarks>
            <param name="fromState">Source state to clear tarnsitions for.</param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.ForceSetState(`0)">
            <summary>Changes current state bypassing any transition or state changes.</summary>
            <remarks>
            It's discouraged to use this method in normal flow. Though, you it may be handy when
            recovering module from an unknown state (e.g. an unexpected exception in the middle of the
            process).
            </remarks>
            <param name="newState">
            New current state. It can be a state that is not mentioned in any state transition.
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.AddStateHandlers(`0,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange)">
            <summary>Adds listeners for state enter/leave events.</summary>
            <remarks>
            Note, that code must not expect that handlers will be called in the same order as they were
            added. Each handler must be independent from the others.
            <para>Multiple calls for the same handler and state won't create multiple entries.</para>
            </remarks>
            <param name="state">State to call callbacke on.</param>
            <param name="enterHandler">
            Callback to call when state machine has switched to a new state. Callback is triggered
            <i>after</i> the state has actually changed.
            </param>
            <param name="leaveHandler">
            Callback to call when state machine is going to leave the current state. Callback is triggered
            <i>before</i> the state has actually changed. 
            </param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.RemoveHandlers(`0,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange,KSPDev.ProcessingUtils.SimpleStateMachine{`0}.OnChange)">
            <summary>Removes enter state change event handler.</summary>
            <remarks>It's safe to call it for non-existing handler.</remarks>
            <param name="state">State to delete handler for.</param>
            <param name="enterHandler">Enter state handler to delete.</param>
            <param name="leaveHandler">Leave state handler to delete.</param>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckCanSwitchTo(`0)">
            <summary>Verifies if transition is allowed.</summary>
            <param name="newState">State to check transition into.</param>
            <returns><c>true</c> if transition is allowed.</returns>
            <seealso cref="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStrict"/>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckIsStarted">
            <summary>Verifies that state machine is started.</summary>
            <exception cref="T:System.InvalidOperationException">If state machine is not yet started.</exception>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckIsNotStarted">
            <summary>Verifies that state machine is <i>not</i> started.</summary>
            <exception cref="T:System.InvalidOperationException">If state machine is already started.</exception>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetState(`0)">
            <summary>
            Changes machine's state if current and new states are different. Checks if transition is
            allowed before actually changing state.
            </summary>
            <param name="newState">State to change to.</param>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.CheckCanSwitchTo(`0)"/>
            <exception cref="T:System.InvalidOperationException">If transition is not allowed.</exception>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.FireLeaveState">
            <summary>Notifies all the leave handlers about leaving the current state.</summary>
        </member>
        <member name="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.FireEnterState">
            <summary>Notifies all the enter handlers about entering the current state.</summary>
        </member>
        <member name="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.currentState">
            <summary>Current state of the machine.</summary>
            <remarks>
            Setting same state as the current one is NO-OP. Setting of a new state may be blocked in
            strict mode.
            </remarks>
            <seealso cref="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStrict"/>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.ForceSetState(`0)"/>
        </member>
        <member name="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStarted">
            <summary>Tells if state machine is started.</summary>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.Start(`0)"/>
        </member>
        <member name="P:KSPDev.ProcessingUtils.SimpleStateMachine`1.isStrict">
            <summary>
            Tells if invalid state transitions will be blocked.  
            </summary>
            <seealso cref="M:KSPDev.ProcessingUtils.SimpleStateMachine`1.SetTransitionConstraint(`0,`0[])"/>
        </member>
        <member name="T:KSPDev.ProcessingUtils.SimpleStateMachine`1.OnChange">
            <summary>Delegate for callback which notifies about state change.</summary>
            <param name="state">Current state of the machine.</param>
        </member>
        <member name="T:KSPDev.ProcessingUtils.SimpleStateMachine`1.OnDebugChange">
            <summary>Special debug delegate to track state changes.</summary>
            <remarks>This callback is called before actual state change.</remarks>
            <param name="fromState">State before change.</param>
            <param name="toState">State after change.</param>
        </member>
        <member name="T:KSPDev.Types.PosAndRot">
            <summary>Type to hold position and rotation of a transform. It can be serialized.</summary>
            <remarks>
            The value serializes into 6 numbers separated by a comma. They form two triplets:
            <list type="bullet">
            <item>The first triplet is a position: x, y, z.</item>
            <item>
            The second triplet is a Euler rotaion around each axis: x, y, z.
            </item>
            </list>
            </remarks>
        </member>
        <member name="F:KSPDev.Types.PosAndRot.pos">
            <summary>Position of the transform.</summary>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.#ctor">
            <summary>Constructs a default instance.</summary>
            <remarks>Required for the persistence to work correctly.</remarks>
            <para>
            By default position is <c>(0,0,0)</c>, Euler angles are <c>(0,0,0)</c>, and the rotation is
            <c>Quaternion.identity</c>.  
            </para>
            <seealso href="https://docs.unity3d.com/ScriptReference/Vector3.html">
            Unity3D: Vector3</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Quaternion-identity.html">
            Unity3D: Quaternion</seealso>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.#ctor(KSPDev.Types.PosAndRot)">
            <summary>Constructs a copy of an object of the same type.</summary>
            <param name="from">Source object.</param>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.#ctor(UnityEngine.Vector3,UnityEngine.Vector3)">
            <summary>Constructs an object from a transform properties.</summary>
            <param name="pos">Position of the transform.</param>
            <param name="euler">Euler rotation of the transform.</param>
            <seealso href="https://docs.unity3d.com/ScriptReference/Vector3.html">
            Unity3D: Vector3</seealso>
            <seealso href="https://docs.unity3d.com/ScriptReference/Transform.html">
            Unity3D: Transform</seealso>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.Clone">
            <summary>Gives a deep copy of the object.</summary>
            <returns>New object.</returns>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.SerializeToString">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.ParseFromString(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.ToString">
            <summary>Shows a human readable representation.</summary>
            <returns>String value.</returns>
        </member>
        <member name="M:KSPDev.Types.PosAndRot.NormlizeAngles">
            <summary>
            Ensures that all the angles are in the range of <c>[0; 360)</c>. 
            </summary>
        </member>
        <member name="P:KSPDev.Types.PosAndRot.euler">
            <summary>Euler rotation.</summary>
            <remarks>
            The rotation angles are automatically adjusted to stay within the [0; 360) range.
            </remarks>
        </member>
        <member name="P:KSPDev.Types.PosAndRot.rot">
            <summary>Orientation of the transform.</summary>
        </member>
        <member name="T:VersionLogger">
            <summary>
            Debugging class that reports which DLL was actually loaded for the Utils assembly.
            </summary>
            <remarks>
            It helps understanding which binary is used in case of multiple mods are using same version of
            KSPDev_utils assembly.
            </remarks>
        </member>
    </members>
</doc>
